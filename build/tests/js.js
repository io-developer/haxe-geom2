// Generated by Haxe 3.4.4
(function ($hx_exports, $global) { "use strict";
$hx_exports["mcover"] = $hx_exports["mcover"] || {};
$hx_exports["mcover"]["util"] = $hx_exports["mcover"]["util"] || {};
$hx_exports["massive"] = $hx_exports["massive"] || {};
$hx_exports["massive"]["munit"] = $hx_exports["massive"]["munit"] || {};
$hx_exports["massive"]["munit"]["util"] = $hx_exports["massive"]["munit"]["util"] || {};
$hx_exports["iodev"] = $hx_exports["iodev"] || {};
$hx_exports["iodev"]["geom2"] = $hx_exports["iodev"]["geom2"] || {};
$hx_exports["iodev"]["geom2"]["intersec"] = $hx_exports["iodev"]["geom2"]["intersec"] || {};
var $hxClasses = {},$estr = function() { return js_Boot.__string_rec(this,''); };
function $extend(from, fields) {
	function Inherit() {} Inherit.prototype = from; var proto = new Inherit();
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var EReg = function(r,opt) {
	this.r = new RegExp(r,opt.split("u").join(""));
};
$hxClasses["EReg"] = EReg;
EReg.__name__ = ["EReg"];
EReg.prototype = {
	match: function(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	,matched: function(n) {
		if(this.r.m != null && n >= 0 && n < this.r.m.length) {
			return this.r.m[n];
		} else {
			throw new js__$Boot_HaxeError("EReg::matched");
		}
	}
	,__class__: EReg
};
var HxOverrides = function() { };
$hxClasses["HxOverrides"] = HxOverrides;
HxOverrides.__name__ = ["HxOverrides"];
HxOverrides.dateStr = function(date) {
	var m = date.getMonth() + 1;
	var d = date.getDate();
	var h = date.getHours();
	var mi = date.getMinutes();
	var s = date.getSeconds();
	return date.getFullYear() + "-" + (m < 10 ? "0" + m : "" + m) + "-" + (d < 10 ? "0" + d : "" + d) + " " + (h < 10 ? "0" + h : "" + h) + ":" + (mi < 10 ? "0" + mi : "" + mi) + ":" + (s < 10 ? "0" + s : "" + s);
};
HxOverrides.strDate = function(s) {
	var _g = s.length;
	switch(_g) {
	case 8:
		var k = s.split(":");
		var d = new Date();
		d["setTime"](0);
		d["setUTCHours"](k[0]);
		d["setUTCMinutes"](k[1]);
		d["setUTCSeconds"](k[2]);
		return d;
	case 10:
		var k1 = s.split("-");
		return new Date(k1[0],k1[1] - 1,k1[2],0,0,0);
	case 19:
		var k2 = s.split(" ");
		var y = k2[0].split("-");
		var t = k2[1].split(":");
		return new Date(y[0],y[1] - 1,y[2],t[0],t[1],t[2]);
	default:
		throw new js__$Boot_HaxeError("Invalid date format : " + s);
	}
};
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
HxOverrides.iter = function(a) {
	return { cur : 0, arr : a, hasNext : function() {
		return this.cur < this.arr.length;
	}, next : function() {
		return this.arr[this.cur++];
	}};
};
var Lambda = function() { };
$hxClasses["Lambda"] = Lambda;
Lambda.__name__ = ["Lambda"];
Lambda.exists = function(it,f) {
	var x = $iterator(it)();
	while(x.hasNext()) {
		var x1 = x.next();
		if(f(x1)) {
			return true;
		}
	}
	return false;
};
Lambda.filter = function(it,f) {
	var l = new List();
	var x = $iterator(it)();
	while(x.hasNext()) {
		var x1 = x.next();
		if(f(x1)) {
			l.add(x1);
		}
	}
	return l;
};
Lambda.count = function(it,pred) {
	var n = 0;
	if(pred == null) {
		var _ = $iterator(it)();
		while(_.hasNext()) {
			var _1 = _.next();
			++n;
		}
	} else {
		var x = $iterator(it)();
		while(x.hasNext()) {
			var x1 = x.next();
			if(pred(x1)) {
				++n;
			}
		}
	}
	return n;
};
var List = function() {
	this.length = 0;
};
$hxClasses["List"] = List;
List.__name__ = ["List"];
List.prototype = {
	add: function(item) {
		var x = new _$List_ListNode(item,null);
		if(this.h == null) {
			this.h = x;
		} else {
			this.q.next = x;
		}
		this.q = x;
		this.length++;
	}
	,push: function(item) {
		var x = new _$List_ListNode(item,this.h);
		this.h = x;
		if(this.q == null) {
			this.q = x;
		}
		this.length++;
	}
	,iterator: function() {
		return new _$List_ListIterator(this.h);
	}
	,__class__: List
};
var _$List_ListNode = function(item,next) {
	this.item = item;
	this.next = next;
};
$hxClasses["_List.ListNode"] = _$List_ListNode;
_$List_ListNode.__name__ = ["_List","ListNode"];
_$List_ListNode.prototype = {
	__class__: _$List_ListNode
};
var _$List_ListIterator = function(head) {
	this.head = head;
};
$hxClasses["_List.ListIterator"] = _$List_ListIterator;
_$List_ListIterator.__name__ = ["_List","ListIterator"];
_$List_ListIterator.prototype = {
	hasNext: function() {
		return this.head != null;
	}
	,next: function() {
		var val = this.head.item;
		this.head = this.head.next;
		return val;
	}
	,__class__: _$List_ListIterator
};
Math.__name__ = ["Math"];
var MathAssert = function() { };
$hxClasses["MathAssert"] = MathAssert;
MathAssert.__name__ = ["MathAssert"];
MathAssert.floatEqual = function(expected,actual,info) {
	if(!MathHelper.floatEqual(expected,actual)) {
		massive_munit_Assert.fail("Float numbers are not equal. Expected '" + Std.string(expected) + "' actual '" + actual + "'",info);
	}
};
MathAssert.floatNotEqual = function(expected,actual,info) {
	if(MathHelper.floatEqual(expected,actual)) {
		massive_munit_Assert.fail("Float numbers are equal. Expected '" + Std.string(expected) + "' actual '" + actual + "'",info);
	}
};
var MathHelper = function() { };
$hxClasses["MathHelper"] = MathHelper;
MathHelper.__name__ = ["MathHelper"];
MathHelper.floatEqual = function(expected,actual,precision) {
	if(precision == null) {
		precision = 0.0001;
	}
	if(expected == "FINITE") {
		return isFinite(actual);
	}
	if(expected == "NOT_FINITE") {
		return !isFinite(actual);
	}
	if(isFinite(expected) && isFinite(actual)) {
		var delta = Math.abs(expected - actual);
		if(delta <= precision) {
			return true;
		}
	} else if(isNaN(expected) && isNaN(actual)) {
		return true;
	} else if(expected == actual) {
		return true;
	}
	return false;
};
var Reflect = function() { };
$hxClasses["Reflect"] = Reflect;
Reflect.__name__ = ["Reflect"];
Reflect.field = function(o,field) {
	try {
		return o[field];
	} catch( e ) {
		haxe_CallStack.lastException = e;
		return null;
	}
};
Reflect.fields = function(o) {
	var a = [];
	if(o != null) {
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		for( var f in o ) {
		if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
			a.push(f);
		}
		}
	}
	return a;
};
Reflect.isFunction = function(f) {
	if(typeof(f) == "function") {
		return !(f.__name__ || f.__ename__);
	} else {
		return false;
	}
};
Reflect.deleteField = function(o,field) {
	if(!Object.prototype.hasOwnProperty.call(o,field)) {
		return false;
	}
	delete(o[field]);
	return true;
};
Reflect.makeVarArgs = function(f) {
	return function() {
		var a = Array.prototype.slice.call(arguments);
		return f(a);
	};
};
var Std = function() { };
$hxClasses["Std"] = Std;
Std.__name__ = ["Std"];
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.parseInt = function(x) {
	var v = parseInt(x,10);
	if(v == 0 && (HxOverrides.cca(x,1) == 120 || HxOverrides.cca(x,1) == 88)) {
		v = parseInt(x);
	}
	if(isNaN(v)) {
		return null;
	}
	return v;
};
var StringBuf = function() {
	this.b = "";
};
$hxClasses["StringBuf"] = StringBuf;
StringBuf.__name__ = ["StringBuf"];
StringBuf.prototype = {
	__class__: StringBuf
};
var StringTools = function() { };
$hxClasses["StringTools"] = StringTools;
StringTools.__name__ = ["StringTools"];
StringTools.htmlEscape = function(s,quotes) {
	s = s.split("&").join("&amp;").split("<").join("&lt;").split(">").join("&gt;");
	if(quotes) {
		return s.split("\"").join("&quot;").split("'").join("&#039;");
	} else {
		return s;
	}
};
StringTools.isSpace = function(s,pos) {
	var c = HxOverrides.cca(s,pos);
	if(!(c > 8 && c < 14)) {
		return c == 32;
	} else {
		return true;
	}
};
StringTools.ltrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,r)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,r,l - r);
	} else {
		return s;
	}
};
StringTools.rtrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,0,l - r);
	} else {
		return s;
	}
};
StringTools.trim = function(s) {
	return StringTools.ltrim(StringTools.rtrim(s));
};
StringTools.lpad = function(s,c,l) {
	if(c.length <= 0) {
		return s;
	}
	while(s.length < l) s = c + s;
	return s;
};
StringTools.rpad = function(s,c,l) {
	if(c.length <= 0) {
		return s;
	}
	while(s.length < l) s += c;
	return s;
};
var TestMain = function() {
	var suites = [];
	suites.push(TestSuite);
	var client = new mcover_coverage_munit_client_MCoverPrintClient();
	var httpClient = new massive_munit_client_HTTPClient(new mcover_coverage_munit_client_MCoverSummaryReportClient());
	var runner = new massive_munit_TestRunner(client);
	runner.addResultClient(httpClient);
	runner.completionHandler = $bind(this,this.completionHandler);
	var seconds = 0;
	var delayStartup = null;
	delayStartup = function() {
		if(seconds > 0) {
			seconds -= 1;
			var delayStartup1 = "Tests will start in " + seconds;
			window.document.getElementById("munit").innerHTML = delayStartup1 + "s...";
			haxe_Timer.delay(delayStartup,1000);
		} else {
			window.document.getElementById("munit").innerHTML = "";
			runner.run(suites);
		}
	};
	var delayStartup2 = delayStartup;
	delayStartup2();
};
$hxClasses["TestMain"] = TestMain;
TestMain.__name__ = ["TestMain"];
TestMain.main = function() {
	new TestMain();
};
TestMain.prototype = {
	completionHandler: function(successful) {
		try {
			eval("testResult(" + (successful == null ? "null" : "" + successful) + ");");
		} catch( e ) {
			haxe_CallStack.lastException = e;
		}
	}
	,__class__: TestMain
};
var massive_munit_TestSuite = function() {
	this.tests = [];
	this.index = 0;
};
$hxClasses["massive.munit.TestSuite"] = massive_munit_TestSuite;
massive_munit_TestSuite.__name__ = ["massive","munit","TestSuite"];
massive_munit_TestSuite.prototype = {
	add: function(test) {
		this.tests.push(test);
		this.sortTests();
	}
	,hasNext: function() {
		return this.index < this.tests.length;
	}
	,next: function() {
		if(this.hasNext()) {
			return this.tests[this.index++];
		} else {
			return null;
		}
	}
	,repeat: function() {
		if(this.index > 0) {
			this.index--;
		}
	}
	,sortTests: function() {
		this.tests.sort($bind(this,this.sortByName));
	}
	,sortByName: function(x,y) {
		var xName = Type.getClassName(x);
		var yName = Type.getClassName(y);
		if(xName == yName) {
			return 0;
		}
		if(xName > yName) {
			return 1;
		} else {
			return -1;
		}
	}
	,__class__: massive_munit_TestSuite
};
var TestSuite = function() {
	massive_munit_TestSuite.call(this);
	this.add(iodev_geom2_intersec_LineIntersecTest);
	this.add(iodev_geom2_macros_CircleIntersecMacrosTest);
	this.add(iodev_geom2_macros_LineIntersecMacrosTest);
	this.add(iodev_geom2_macros_VecMacrosTest);
	this.add(iodev_geom2_macros_VecMacrosTest_$argTest);
	this.add(iodev_geom2_VecBuilderTest);
	this.add(iodev_geom2_VecTest);
};
$hxClasses["TestSuite"] = TestSuite;
TestSuite.__name__ = ["TestSuite"];
TestSuite.__super__ = massive_munit_TestSuite;
TestSuite.prototype = $extend(massive_munit_TestSuite.prototype,{
	__class__: TestSuite
});
var ValueType = $hxClasses["ValueType"] = { __ename__ : ["ValueType"], __constructs__ : ["TNull","TInt","TFloat","TBool","TObject","TFunction","TClass","TEnum","TUnknown"] };
ValueType.TNull = ["TNull",0];
ValueType.TNull.toString = $estr;
ValueType.TNull.__enum__ = ValueType;
ValueType.TInt = ["TInt",1];
ValueType.TInt.toString = $estr;
ValueType.TInt.__enum__ = ValueType;
ValueType.TFloat = ["TFloat",2];
ValueType.TFloat.toString = $estr;
ValueType.TFloat.__enum__ = ValueType;
ValueType.TBool = ["TBool",3];
ValueType.TBool.toString = $estr;
ValueType.TBool.__enum__ = ValueType;
ValueType.TObject = ["TObject",4];
ValueType.TObject.toString = $estr;
ValueType.TObject.__enum__ = ValueType;
ValueType.TFunction = ["TFunction",5];
ValueType.TFunction.toString = $estr;
ValueType.TFunction.__enum__ = ValueType;
ValueType.TClass = function(c) { var $x = ["TClass",6,c]; $x.__enum__ = ValueType; $x.toString = $estr; return $x; };
ValueType.TEnum = function(e) { var $x = ["TEnum",7,e]; $x.__enum__ = ValueType; $x.toString = $estr; return $x; };
ValueType.TUnknown = ["TUnknown",8];
ValueType.TUnknown.toString = $estr;
ValueType.TUnknown.__enum__ = ValueType;
var Type = function() { };
$hxClasses["Type"] = Type;
Type.__name__ = ["Type"];
Type.getSuperClass = function(c) {
	return c.__super__;
};
Type.getClassName = function(c) {
	var a = c.__name__;
	if(a == null) {
		return null;
	}
	return a.join(".");
};
Type.getEnumName = function(e) {
	var a = e.__ename__;
	return a.join(".");
};
Type.resolveClass = function(name) {
	var cl = $hxClasses[name];
	if(cl == null || !cl.__name__) {
		return null;
	}
	return cl;
};
Type.resolveEnum = function(name) {
	var e = $hxClasses[name];
	if(e == null || !e.__ename__) {
		return null;
	}
	return e;
};
Type.createInstance = function(cl,args) {
	var _g = args.length;
	switch(_g) {
	case 0:
		return new cl();
	case 1:
		return new cl(args[0]);
	case 2:
		return new cl(args[0],args[1]);
	case 3:
		return new cl(args[0],args[1],args[2]);
	case 4:
		return new cl(args[0],args[1],args[2],args[3]);
	case 5:
		return new cl(args[0],args[1],args[2],args[3],args[4]);
	case 6:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5]);
	case 7:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6]);
	case 8:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7]);
	case 9:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8]);
	case 10:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8],args[9]);
	case 11:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8],args[9],args[10]);
	case 12:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8],args[9],args[10],args[11]);
	case 13:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8],args[9],args[10],args[11],args[12]);
	case 14:
		return new cl(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8],args[9],args[10],args[11],args[12],args[13]);
	default:
		throw new js__$Boot_HaxeError("Too many arguments");
	}
};
Type.createEmptyInstance = function(cl) {
	function empty() {}; empty.prototype = cl.prototype;
	return new empty();
};
Type.createEnum = function(e,constr,params) {
	var f = Reflect.field(e,constr);
	if(f == null) {
		throw new js__$Boot_HaxeError("No such constructor " + constr);
	}
	if(Reflect.isFunction(f)) {
		if(params == null) {
			throw new js__$Boot_HaxeError("Constructor " + constr + " need parameters");
		}
		return f.apply(e,params);
	}
	if(params != null && params.length != 0) {
		throw new js__$Boot_HaxeError("Constructor " + constr + " does not need parameters");
	}
	return f;
};
Type["typeof"] = function(v) {
	var _g = typeof(v);
	switch(_g) {
	case "boolean":
		return ValueType.TBool;
	case "function":
		if(v.__name__ || v.__ename__) {
			return ValueType.TObject;
		}
		return ValueType.TFunction;
	case "number":
		if(Math.ceil(v) == v % 2147483648.0) {
			return ValueType.TInt;
		}
		return ValueType.TFloat;
	case "object":
		if(v == null) {
			return ValueType.TNull;
		}
		var e = v.__enum__;
		if(e != null) {
			return ValueType.TEnum(e);
		}
		var c = js_Boot.getClass(v);
		if(c != null) {
			return ValueType.TClass(c);
		}
		return ValueType.TObject;
	case "string":
		return ValueType.TClass(String);
	case "undefined":
		return ValueType.TNull;
	default:
		return ValueType.TUnknown;
	}
};
Type.enumEq = function(a,b) {
	if(a == b) {
		return true;
	}
	try {
		if(a[0] != b[0]) {
			return false;
		}
		var _g1 = 2;
		var _g = a.length;
		while(_g1 < _g) {
			var i = _g1++;
			if(!Type.enumEq(a[i],b[i])) {
				return false;
			}
		}
		var e = a.__enum__;
		if(e != b.__enum__ || e == null) {
			return false;
		}
	} catch( e1 ) {
		haxe_CallStack.lastException = e1;
		return false;
	}
	return true;
};
var data_CircleIntersecTestData = function() { };
$hxClasses["data.CircleIntersecTestData"] = data_CircleIntersecTestData;
data_CircleIntersecTestData.__name__ = ["data","CircleIntersecTestData"];
data_CircleIntersecTestData.forCrossFull = function() {
	return [{ title : "cross-full-1", cx : -400, cy : 0, crad : 40, lx0 : -400, ly0 : 70, lx1 : -400, ly1 : -70, dstax : -400, dstay : 40, dstbx : -400, dstby : -40},{ title : "cross-full-2", cx : -200, cy : 0, crad : 40, lx0 : -260, ly0 : 0, lx1 : -140, ly1 : 0, dstax : -240, dstay : 0, dstbx : -160, dstby : 0},{ title : "cross-full-3", cx : 0, cy : 0, crad : 44.537089, lx0 : -60, ly0 : 50, lx1 : 50, ly1 : -40, dstax : -34.019959, dstay : 28.743603, dstbx : 34.911048, dstby : -27.654494},{ title : "cross-full-4", cx : 206.755223, cy : -11.639146, crad : 33.641125, lx0 : 185.989272, ly0 : -78.782387, lx1 : 273.206265, ly1 : 62.426078, dstax : 206.681805, dstay : -45.280191, dstbx : 236.803387, dstby : 3.488085},{ title : "cross-full-5", cx : 398.601929, cy : 3.105726, crad : 53.743145, lx0 : 325.536547, ly0 : 8.874045, lx1 : 452.439579, ly1 : -48.328458, dstax : 344.941386, dstay : 0.127167, dstbx : 431.907311, dstby : -39.073383}];
};
data_CircleIntersecTestData.forCrossIn = function() {
	return [{ title : "cross-in-1", cx : -400, cy : -300, crad : 40, lx0 : -400, ly0 : -370, lx1 : -400, ly1 : -280, dstax : -400, dstay : -340, dstbx : -400, dstby : -260},{ title : "cross-in-2", cx : -200, cy : -300, crad : 30, lx0 : -260, ly0 : -300, lx1 : -180, ly1 : -300, dstax : -230, dstay : -300, dstbx : -170, dstby : -300},{ title : "cross-in-3", cx : 4.330889, cy : -295.083827, crad : 37.657036, lx0 : -24.182221, ly0 : -346.703447, lx1 : 29.321054, ly1 : -286.095003, dstax : -9.52454, dstay : -330.099244, dstbx : 37.357096, dstby : -276.991784},{ title : "cross-in-4", cx : 205.452968, cy : -294.12244, crad : 21.178455, lx0 : 167.847369, ly0 : -268.018871, lx1 : 199.550177, ly1 : -307.508061, dstax : 184.853946, dstay : -289.202355, dstbx : 205.804101, dstby : -315.297984},{ title : "cross-in-5", cx : 394.653853, cy : -287.777288, crad : 46.95072, lx0 : 386.053236, ly0 : -202.536411, lx1 : 359.747697, ly1 : -303.078661, dstax : 374.894267, dstay : -245.187044, dstbx : 356.567686, dstby : -315.232963}];
};
data_CircleIntersecTestData.forCrossOut = function() {
	return [{ title : "cross-out-1", cx : -400, cy : -600, crad : 40, lx0 : -400, ly0 : -580, lx1 : -400, ly1 : -670, dstax : -400, dstay : -560, dstbx : -400, dstby : -640},{ title : "cross-out-2", cx : -200, cy : -600, crad : 30, lx0 : -180, ly0 : -600, lx1 : -260, ly1 : -600, dstax : -170, dstay : -600, dstbx : -230, dstby : -600},{ title : "cross-out-3", cx : 4.330889, cy : -595.083827, crad : 37.657036, lx0 : 22.788699, ly0 : -595.863659, lx1 : -24.182221, ly1 : -646.703447, dstax : 38.376497, dstay : -578.991936, dstbx : -9.02161, dstby : -630.294097},{ title : "cross-out-4", cx : 205.452968, cy : -594.12244, crad : 21.178455, lx0 : 199.402694, ly0 : -607.324356, lx1 : 167.847369, ly1 : -568.018871, dstax : 205.804101, dstay : -615.297984, dstbx : 184.853946, dstby : -589.202355},{ title : "cross-out-5", cx : 394.653853, cy : -587.777288, crad : 46.95072, lx0 : 363.827332, ly0 : -587.485913, lx1 : 386.053236, ly1 : -502.536411, dstax : 356.567686, dstay : -615.232963, dstbx : 374.894267, dstby : -545.187044}];
};
data_CircleIntersecTestData.forInside = function() {
	return [{ title : "inside-1", cx : -400, cy : -900, crad : 60, lx0 : -428.445773, ly0 : -928.445773, lx1 : -367.397724, ly1 : -867.397724, dstax : -442.426407, dstay : -942.426407, dstbx : -357.573593, dstby : -857.573593},{ title : "inside-2", cx : -200, cy : -900, crad : 50, lx0 : -200, ly0 : -936.989049, lx1 : -200, ly1 : -878.344466, dstax : -200, dstay : -950, dstbx : -200, dstby : -850},{ title : "inside-3", cx : 0, cy : -900, crad : 60, lx0 : -47.365186, ly0 : -900, lx1 : 38.678916, ly1 : -900, dstax : -60, dstay : -900, dstbx : 60, dstby : -900},{ title : "inside-4", cx : 213.034809, cy : -892.981892, crad : 50.564183, lx0 : 246.679655, ly0 : -918.385286, lx1 : 197.559787, ly1 : -926.497986, dstax : 257.768462, dstay : -916.553844, dstbx : 178.256453, dstby : -929.68615},{ title : "inside-5", cx : 421.090408, cy : -937.197281, crad : 59.751551, lx0 : 382.813699, ly0 : -911.286308, lx1 : 388.960134, ly1 : -970.292082, dstax : 380.906408, dstay : -892.976314, dstbx : 390.882906, dstby : -988.750696}];
};
data_CircleIntersecTestData.forTouch = function() {
	return [{ title : "touch-1", cx : -400, cy : -1200, crad : 50, lx0 : -500, ly0 : -1300, lx1 : -435.355339, ly1 : -1235.355339, dstax : -435.355339, dstay : -1235.355339, dstbx : -364.644661, dstby : -1164.644661},{ title : "touch-2", cx : -200, cy : -1200, crad : 31.622777, lx0 : -200, ly0 : -1320, lx1 : -200, ly1 : -1231.622777, dstax : -200, dstay : -1231.622777, dstbx : -200, dstby : -1168.377223},{ title : "touch-3", cx : 0, cy : -1200, crad : 40, lx0 : 40, ly0 : -1200, lx1 : 131.146844, ly1 : -1200, dstax : -40, dstay : -1200, dstbx : 40, dstby : -1200},{ title : "touch-4", cx : 213.509184, cy : -1211.9888, crad : 30.733607, lx0 : 243.969938, ly0 : -1207.902598, lx1 : 321.899756, ly1 : -1244.726578, dstax : 197.325081, dstay : -1185.861622, dstbx : 243.969938, dstby : -1207.902598},{ title : "touch-5", cx : 392.926999, cy : -1193.714763, crad : 46.076084, lx0 : 436.320561, ly0 : -1072.595764, lx1 : 426.285159, ly1 : -1161.930512, dstax : 426.285159, dstay : -1161.930512, dstbx : 418.401785, dstby : -1232.108002}];
};
data_CircleIntersecTestData.forTangentIn = function() {
	return [{ title : "tangent-in-1", cx : -400, cy : -1500, crad : 30, lx0 : -470, ly0 : -1470, lx1 : -430, ly1 : -1470, dstax : -400, dstay : -1470, dstbx : -400, dstby : -1470},{ title : "tangent-in-2", cx : -200, cy : -1500, crad : 40, lx0 : -240, ly0 : -1440, lx1 : -240, ly1 : -1480, dstax : -240, dstay : -1500, dstbx : -240, dstby : -1500},{ title : "tangent-in-3", cx : 0, cy : -1500, crad : 30, lx0 : 80, ly0 : -1530, lx1 : 30, ly1 : -1530, dstax : 0, dstay : -1530, dstbx : 0, dstby : -1530},{ title : "tangent-in-4", cx : 200, cy : -1500, crad : 40, lx0 : 240, ly0 : -1590, lx1 : 240, ly1 : -1530, dstax : 240, dstay : -1500, dstbx : 240, dstby : -1500}];
};
data_CircleIntersecTestData.forTangentOut = function() {
	return [{ title : "tangent-out-1", cx : -400, cy : -1800, crad : 30, lx0 : -430, ly0 : -1770, lx1 : -470, ly1 : -1770, dstax : -400, dstay : -1770, dstbx : -400, dstby : -1770},{ title : "tangent-out-2", cx : -200, cy : -1800, crad : 40, lx0 : -240, ly0 : -1780, lx1 : -240, ly1 : -1740, dstax : -240, dstay : -1800, dstbx : -240, dstby : -1800},{ title : "tangent-out-3", cx : 0, cy : -1800, crad : 30, lx0 : 30, ly0 : -1830, lx1 : 80, ly1 : -1830, dstax : 0, dstay : -1830, dstbx : 0, dstby : -1830},{ title : "tangent-out-4", cx : 200, cy : -1800, crad : 40, lx0 : 240, ly0 : -1830, lx1 : 240, ly1 : -1890, dstax : 240, dstay : -1800, dstbx : 240, dstby : -1800}];
};
data_CircleIntersecTestData.forProjectIn = function() {
	return [{ title : "project-in-1", cx : -400, cy : -2100, crad : 50.990195, lx0 : -500, ly0 : -2200, lx1 : -444.923669, ly1 : -2144.923669, dstax : -436.055513, dstay : -2136.055513, dstbx : -363.944487, dstby : -2063.944487},{ title : "project-in-2", cx : -200, cy : -2100, crad : 31.622777, lx0 : -200, ly0 : -2220, lx1 : -200, ly1 : -2144.150643, dstax : -200, dstay : -2131.622777, dstbx : -200, dstby : -2068.377223},{ title : "project-in-3", cx : 0, cy : -2100, crad : 40, lx0 : 131.146844, ly0 : -2100, lx1 : 57.42941, ly1 : -2100, dstax : 40, dstay : -2100, dstbx : -40, dstby : -2100},{ title : "project-in-4", cx : 213.509184, cy : -2111.9888, crad : 30.733607, lx0 : 321.899756, ly0 : -2144.726578, lx1 : 274.742228, ly1 : -2122.44335, dstax : 243.969938, dstay : -2107.902598, dstbx : 197.325081, dstby : -2085.861622},{ title : "project-in-5", cx : 392.926999, cy : -2093.714763, crad : 46.076084, lx0 : 436.320561, ly0 : -1972.595764, lx1 : 427.950733, ly1 : -2047.103638, dstax : 426.285159, dstay : -2061.930512, dstbx : 418.401785, dstby : -2132.108002}];
};
data_CircleIntersecTestData.forProjectOut = function() {
	return [{ title : "project-out-1", cx : -400, cy : -2400, crad : 50.990195, lx0 : -444.923669, ly0 : -2444.923669, lx1 : -500, ly1 : -2500, dstax : -363.944487, dstay : -2363.944487, dstbx : -436.055513, dstby : -2436.055513},{ title : "project-out-2", cx : -200, cy : -2400, crad : 31.622777, lx0 : -200, ly0 : -2444.150643, lx1 : -200, ly1 : -2520, dstax : -200, dstay : -2368.377223, dstbx : -200, dstby : -2431.622777},{ title : "project-out-3", cx : 0, cy : -2400, crad : 40, lx0 : 57.42941, ly0 : -2400, lx1 : 131.146844, ly1 : -2400, dstax : -40, dstay : -2400, dstbx : 40, dstby : -2400},{ title : "project-out-4", cx : 213.509184, cy : -2411.9888, crad : 30.733607, lx0 : 274.742228, ly0 : -2422.44335, lx1 : 321.899756, ly1 : -2444.726578, dstax : 197.325081, dstay : -2385.861622, dstbx : 243.969938, dstby : -2407.902598},{ title : "project-out-5", cx : 392.926999, cy : -2393.714763, crad : 46.076084, lx0 : 427.950733, ly0 : -2347.103638, lx1 : 436.320561, ly1 : -2272.595764, dstax : 418.401785, dstay : -2432.108002, dstbx : 426.285159, dstby : -2361.930512}];
};
data_CircleIntersecTestData.forNone = function() {
	return [{ title : "none-1", cx : -400, cy : -2700, crad : 40, lx0 : -380, ly0 : -2770, lx1 : -330, ly1 : -2720, dstax : "NOT_FINITE", dstay : "NOT_FINITE", dstbx : "NOT_FINITE", dstby : "NOT_FINITE"},{ title : "none-2", cx : -200, cy : -2700, crad : 30, lx0 : -250, ly0 : -2740, lx1 : -250, ly1 : -2680, dstax : "NOT_FINITE", dstay : "NOT_FINITE", dstbx : "NOT_FINITE", dstby : "NOT_FINITE"},{ title : "none-3", cx : 0, cy : -2700, crad : 50, lx0 : 30, ly0 : -2770, lx1 : -40, ly1 : -2770, dstax : "NOT_FINITE", dstay : "NOT_FINITE", dstbx : "NOT_FINITE", dstby : "NOT_FINITE"},{ title : "none-4", cx : 202.977044, cy : -2696.950653, crad : 31.767682, lx0 : 186.127879, ly0 : -2739.149285, lx1 : 268.038018, ly1 : -2712.615015, dstax : "NOT_FINITE", dstay : "NOT_FINITE", dstbx : "NOT_FINITE", dstby : "NOT_FINITE"},{ title : "none-5", cx : 407.17556, cy : -2709.064125, crad : 35.506807, lx0 : 449.163256, ly0 : -2788.180002, lx1 : 446.855928, ly1 : -2696.46372, dstax : "NOT_FINITE", dstay : "NOT_FINITE", dstbx : "NOT_FINITE", dstby : "NOT_FINITE"}];
};
var data_LineIntersecTestData = function() { };
$hxClasses["data.LineIntersecTestData"] = data_LineIntersecTestData;
data_LineIntersecTestData.__name__ = ["data","LineIntersecTestData"];
data_LineIntersecTestData.forCross = function() {
	return [{ title : "cross-1", ax0 : -608.772972, ay0 : -37.930583, ax1 : -608.772972, ay1 : 12.069417, bx0 : -638.772972, by0 : 2.069417, bx1 : -568.772972, by1 : 2.069417, dstx : -608.772972, dsty : 2.069417},{ title : "cross-2", ax0 : -370, ay0 : 30, ax1 : -430, ay1 : -30, bx0 : -370, by0 : -30, bx1 : -430, by1 : 30, dstx : -400, dsty : 0},{ title : "cross-3", ax0 : -200, ay0 : 30, ax1 : -200, ay1 : -30, bx0 : -230, by0 : 0, bx1 : -170, by1 : 0, dstx : -200, dsty : 0},{ title : "cross-4", ax0 : -30, ay0 : 0, ax1 : 30, ay1 : 0, bx0 : 0, by0 : 30, bx1 : 0, by1 : -30, dstx : 0, dsty : 0},{ title : "cross-5", ax0 : 183.385386, ay0 : -49.329762, ax1 : 213.245226, ay1 : 47.117521, bx0 : 129.040477, by0 : 23.229649, bx1 : 246.389648, by1 : -39.774613, dstx : 194.901995, dsty : -12.131115},{ title : "cross-6", ax0 : 423.349529, ay0 : -15.291585, ax1 : 334.773299, ay1 : 16.097078, bx0 : 454.308211, by0 : 4.917554, bx1 : 380.351359, by1 : -28.621018, dstx : 415.712366, dsty : -12.585212},{ title : "cross-7", ax0 : 607.507514, ay0 : -23.255157, ax1 : 625.755194, ay1 : 29.206923, bx0 : 609.14788, by0 : -22.481721, bx1 : 561.161923, by1 : 21.89239, dstx : 608.110276, dsty : -21.522216},{ title : "cross-8", ax0 : 841.353349, ay0 : 49.62506, ax1 : 803.267595, ay1 : -17.571315, bx0 : 706.629898, by0 : -61.933238, bx1 : 808.754698, by1 : -12.512438, dstx : 805.144737, dsty : -14.259391}];
};
data_LineIntersecTestData.forTouch = function() {
	return [{ title : "touch-1", ax0 : -830, ay0 : -330, ax1 : -780, ay1 : -280, bx0 : -800, by0 : -300, bx1 : -770, by1 : -330, dstx : -800, dsty : -300},{ title : "touch-2", ax0 : -630, ay0 : -330, ax1 : -600, ay1 : -300, bx0 : -580, by0 : -320, bx1 : -630, by1 : -270, dstx : -600, dsty : -300},{ title : "touch-3", ax0 : -406.412196, ay0 : -295.815547, ax1 : -386.412196, ay1 : -345.815547, bx0 : -366.412196, by0 : -295.815547, bx1 : -446.412196, by1 : -295.815547, dstx : -406.412196, dsty : -295.815547},{ title : "touch-4", ax0 : -204.360612, ay0 : -275.581947, ax1 : -204.360612, ay1 : -345.581947, bx0 : -254.360612, by0 : -325.581947, bx1 : -204.360612, by1 : -295.581947, dstx : -204.360612, dsty : -295.581947},{ title : "touch-5", ax0 : 0, ay0 : -350, ax1 : 0, ay1 : -300, bx0 : 50, by0 : -300, bx1 : 0, by1 : -300, dstx : 0, dsty : -300},{ title : "touch-6", ax0 : 196.624775, ay0 : -304.767256, ax1 : 196.624775, ay1 : -354.767256, bx0 : 196.624775, by0 : -304.767256, bx1 : 146.624775, by1 : -304.767256, dstx : 196.624775, dsty : -304.767256},{ title : "touch-7", ax0 : 404.449261, ay0 : -295.809304, ax1 : 344.449261, ay1 : -295.809304, bx0 : 404.449261, by0 : -345.809304, bx1 : 404.449261, by1 : -295.809304, dstx : 404.449261, dsty : -295.809304},{ title : "touch-8", ax0 : 600, ay0 : -330, ax1 : 600, ay1 : -260, bx0 : 600, by0 : -300, bx1 : 540, by1 : -300, dstx : 600, dsty : -300},{ title : "touch-9", ax0 : 805.938551, ay0 : -265.139829, ax1 : 805.938551, ay1 : -335.139829, bx0 : 745.938551, by0 : -295.139829, bx1 : 805.938551, by1 : -295.139829, dstx : 805.938551, dsty : -295.139829},{ title : "touch-10", ax0 : 1035.548535, ay0 : -304.284661, ax1 : 945.548535, ay1 : -304.284661, bx0 : 995.548535, by0 : -364.284661, bx1 : 995.548535, by1 : -304.284661, dstx : 995.548535, dsty : -304.284661},{ title : "touch-11", ax0 : 1200, ay0 : -240, ax1 : 1200, ay1 : -300, bx0 : 1180, by0 : -300, bx1 : 1260, by1 : -300, dstx : 1200, dsty : -300}];
};
data_LineIntersecTestData.forProjectIn = function() {
	return [{ title : "project-in-1", ax0 : -456.462842, ay0 : -594.878444, ax1 : -406.462842, ay1 : -594.878444, bx0 : -396.462842, by0 : -644.878444, bx1 : -396.462842, by1 : -544.878444, dstx : -396.462842, dsty : -594.878444},{ title : "project-in-2", ax0 : -275.353773, ay0 : -595.908307, ax1 : -205.353773, ay1 : -595.908307, bx0 : -195.353773, by0 : -545.908307, bx1 : -195.353773, by1 : -645.908307, dstx : -195.353773, dsty : -595.908307},{ title : "project-in-3", ax0 : 0, ay0 : -560, ax1 : 0, ay1 : -610, bx0 : -60, by0 : -620, bx1 : 60, by1 : -620, dstx : 0, dsty : -620},{ title : "project-in-4", ax0 : 200, ay0 : -560, ax1 : 200, ay1 : -620, bx0 : 240, by0 : -630, bx1 : 160, by1 : -630, dstx : 200, dsty : -630},{ title : "project-in-5", ax0 : 369.633179, ay0 : -565.617297, ax1 : 398.205226, ay1 : -604.059688, bx0 : 380, by0 : -650, bx1 : 430, by1 : -570, dstx : 403.912987, dsty : -611.739221},{ title : "project-in-6", ax0 : 643.961501, ay0 : -557.017663, ax1 : 593.473891, ay1 : -615.206773, bx0 : 656.854903, by0 : -596.008045, bx1 : 561.828948, by1 : -632.986471, dstx : 586.314655, dsty : -623.458096},{ title : "project-in-7", ax0 : 748.674772, ay0 : -655.564652, ax1 : 801.653499, ay1 : -627.30933, bx0 : 806.901774, by0 : -636.723734, bx1 : 809.130799, by1 : -558.707855, dstx : 807.256131, dsty : -624.321261},{ title : "project-in-8", ax0 : 1019.724225, ay0 : -573.536528, ax1 : 999.754232, ay1 : -592.226394, bx0 : 976.307683, by0 : -557.964847, bx1 : 1009.000051, by1 : -629.29365, dstx : 994.335341, dsty : -597.297919}];
};
data_LineIntersecTestData.forProjectOut = function() {
	return [{ title : "project-out-1", ax0 : -410, ay0 : -910, ax1 : -460, ay1 : -910, bx0 : -400, by0 : -960, bx1 : -400, by1 : -860, dstx : -400, dsty : -910},{ title : "project-out-2", ax0 : -208.890931, ay0 : -911.029862, ax1 : -278.890931, ay1 : -911.029862, bx0 : -198.890931, by0 : -861.029862, bx1 : -198.890931, by1 : -961.029862, dstx : -198.890931, dsty : -911.029862},{ title : "project-out-3", ax0 : 0, ay0 : -910, ax1 : 0, ay1 : -850, bx0 : -60, by0 : -920, bx1 : 60, by1 : -920, dstx : 0, dsty : -920},{ title : "project-out-4", ax0 : 201.532065, ay0 : -908.2039, ax1 : 201.532065, ay1 : -848.2039, bx0 : 241.532065, by0 : -918.2039, bx1 : 161.532065, by1 : -918.2039, dstx : 201.532065, dsty : -918.2039},{ title : "project-out-5", ax0 : 394.668068, ay0 : -919.181243, ax1 : 366.096021, ay1 : -880.738853, bx0 : 376.462842, by0 : -965.121556, bx1 : 426.462842, by1 : -885.121556, dstx : 400.375829, dsty : -926.860776},{ title : "project-out-6", ax0 : 589.936733, ay0 : -930.328329, ax1 : 640.424343, ay1 : -872.139219, bx0 : 653.317745, by0 : -911.1296, bx1 : 558.29179, by1 : -948.108026, dstx : 582.777496, dsty : -938.579652},{ title : "project-out-7", ax0 : 798.116341, ay0 : -942.430886, ax1 : 745.137613, ay1 : -970.686208, bx0 : 803.364616, by0 : -951.84529, bx1 : 805.593641, by1 : -873.829411, dstx : 803.718972, dsty : -939.442816},{ title : "project-out-8", ax0 : 996.217073, ay0 : -907.347949, ax1 : 1016.187067, ay1 : -888.658084, bx0 : 972.770524, by0 : -873.086402, bx1 : 1005.462893, by1 : -944.415206, dstx : 990.798183, dsty : -912.419475}];
};
data_LineIntersecTestData.forCastIn = function() {
	return [{ title : "cast-in-1", ax0 : 0, ay0 : -1160, ax1 : 0, ay1 : -1220, bx0 : -70, by0 : -1230, bx1 : -10, by1 : -1230, dstx : 0, dsty : -1230},{ title : "cast-in-2", ax0 : 160, ay0 : -1240, ax1 : 190, ay1 : -1210, bx0 : 250, by0 : -1250, bx1 : 210, by1 : -1210, dstx : 200, dsty : -1200},{ title : "cast-in-3", ax0 : 356.403286, ay0 : -1121.958422, ax1 : 408.199421, ay1 : -1219.365983, bx0 : 445.513873, by0 : -1148.862314, bx1 : 422.111053, by1 : -1215.096432, dstx : 415.651029, dsty : -1233.379442},{ title : "cast-in-4", ax0 : 522.841378, ay0 : -1183.891013, ax1 : 620.140028, ay1 : -1205.98503, bx0 : 540.025268, by0 : -1223.546144, bx1 : 613.316012, by1 : -1214.384801, dstx : 641.575192, dsty : -1210.852404},{ title : "cast-in-5", ax0 : 776.275765, ay0 : -1318.119989, ax1 : 785.500345, ay1 : -1196.985712, bx0 : 804.790941, by0 : -1294.416443, bx1 : 790.125804, by1 : -1192.532331, dstx : 787.32255, dsty : -1173.057092}];
};
data_LineIntersecTestData.forCastOut = function() {
	return [{ title : "cast-out-1", ax0 : 0, ay0 : -1520, ax1 : 0, ay1 : -1460, bx0 : -70, by0 : -1530, bx1 : -10, by1 : -1530, dstx : 0, dsty : -1530},{ title : "cast-out-2", ax0 : 189.166667, ay0 : -1508.420403, ax1 : 159.166667, ay1 : -1538.420403, bx0 : 249.166667, by0 : -1548.420403, bx1 : 209.166667, by1 : -1508.420403, dstx : 199.166667, dsty : -1498.420403},{ title : "cast-out-3", ax0 : 407.366087, ay0 : -1517.786386, ax1 : 355.569952, ay1 : -1420.378824, bx0 : 444.680539, by0 : -1447.282717, bx1 : 421.277719, by1 : -1513.516835, dstx : 414.817696, dsty : -1531.799845},{ title : "cast-out-4", ax0 : 619.306695, ay0 : -1504.405433, ax1 : 522.008044, ay1 : -1482.311416, bx0 : 539.191934, by0 : -1521.966547, bx1 : 612.482678, by1 : -1512.805204, dstx : 640.741859, dsty : -1509.272806},{ title : "cast-out-5", ax0 : 784.667012, ay0 : -1495.406115, ax1 : 775.442432, ay1 : -1616.540392, bx0 : 803.957608, by0 : -1592.836846, bx1 : 789.292471, by1 : -1490.952734, dstx : 786.489217, dsty : -1471.477495}];
};
data_LineIntersecTestData.forCastAway = function() {
	return [{ title : "cast-away-1", ax0 : 0, ay0 : -1830, ax1 : 0, ay1 : -1770, bx0 : -10, by0 : -1840, bx1 : -70, by1 : -1840, dstx : 0, dsty : -1840},{ title : "cast-away-2", ax0 : 189.444444, ay0 : -1809.960795, ax1 : 159.444444, ay1 : -1839.960795, bx0 : 209.444444, by0 : -1809.960795, bx1 : 249.444444, by1 : -1849.960795, dstx : 199.444444, dsty : -1799.960795},{ title : "cast-away-3", ax0 : 407.643865, ay0 : -1819.326778, ax1 : 355.84773, ay1 : -1721.919216, bx0 : 421.555497, by0 : -1815.057227, bx1 : 444.958317, by1 : -1748.823109, dstx : 415.095473, dsty : -1833.340237},{ title : "cast-away-4", ax0 : 619.584473, ay0 : -1805.945825, ax1 : 522.285822, ay1 : -1783.851808, bx0 : 612.760456, by0 : -1814.345596, bx1 : 539.469712, by1 : -1823.506939, dstx : 641.019637, dsty : -1810.813198},{ title : "cast-away-5", ax0 : 784.94479, ay0 : -1796.946507, ax1 : 775.72021, ay1 : -1918.080784, bx0 : 789.570249, by0 : -1792.493126, bx1 : 804.235386, by1 : -1894.377238, dstx : 786.766994, dsty : -1773.017887}];
};
data_LineIntersecTestData.forParallel = function() {
	return [{ title : "parallel-1", ax0 : -1404.641002, ay0 : -2153.936926, ax1 : -1404.641002, ay1 : -2113.936926, bx0 : -1394.641002, by0 : -2063.936926, bx1 : -1394.641002, by1 : -2103.936926, dstx : "NOT_FINITE", dsty : "NOT_FINITE"},{ title : "parallel-2", ax0 : -1194.07049, ay0 : -2054.326411, ax1 : -1194.07049, ay1 : -2104.326411, bx0 : -1194.07049, by0 : -2154.326411, bx1 : -1194.07049, by1 : -2104.326411, dstx : "NOT_FINITE", dsty : "NOT_FINITE"},{ title : "parallel-3", ax0 : -994.681406, ay0 : -2153.044743, ax1 : -994.681406, ay1 : -2113.044743, bx0 : -994.681406, by0 : -2113.044743, bx1 : -994.681406, by1 : -2073.044743, dstx : "NOT_FINITE", dsty : "NOT_FINITE"},{ title : "parallel-4", ax0 : -795.47506, ay0 : -2105.607706, ax1 : -795.47506, ay1 : -2065.607706, bx0 : -795.47506, by0 : -2105.607706, bx1 : -795.47506, by1 : -2145.607706, dstx : "NOT_FINITE", dsty : "NOT_FINITE"},{ title : "parallel-5", ax0 : -610, ay0 : -2080, ax1 : -610, ay1 : -2140, bx0 : -600, by0 : -2080, bx1 : -600, by1 : -2140, dstx : "NOT_FINITE", dsty : "NOT_FINITE"},{ title : "parallel-6", ax0 : -400, ay0 : -2150, ax1 : -400, ay1 : -2090, bx0 : -390, by0 : -2090, bx1 : -390, by1 : -2150, dstx : "NOT_FINITE", dsty : "NOT_FINITE"},{ title : "parallel-7", ax0 : -200, ay0 : -2120, ax1 : -200, ay1 : -2060, bx0 : -190, by0 : -2120, bx1 : -190, by1 : -2060, dstx : "NOT_FINITE", dsty : "NOT_FINITE"},{ title : "parallel-8", ax0 : -40, ay0 : -2090, ax1 : 40, ay1 : -2090, bx0 : -40, by0 : -2100, bx1 : 40, by1 : -2100, dstx : "NOT_FINITE", dsty : "NOT_FINITE"},{ title : "parallel-9", ax0 : 200, ay0 : -2100, ax1 : 160, ay1 : -2100, bx0 : 200, by0 : -2100, bx1 : 230, by1 : -2100, dstx : "NOT_FINITE", dsty : "NOT_FINITE"},{ title : "parallel-10", ax0 : 390, ay0 : -2090, ax1 : 360, ay1 : -2090, bx0 : 440, by0 : -2090, bx1 : 400, by1 : -2090, dstx : "NOT_FINITE", dsty : "NOT_FINITE"},{ title : "parallel-11", ax0 : 550, ay0 : -2090, ax1 : 590, ay1 : -2090, bx0 : 640, by0 : -2090, bx1 : 600, by1 : -2090, dstx : "NOT_FINITE", dsty : "NOT_FINITE"},{ title : "parallel-12", ax0 : 750, ay0 : -2120, ax1 : 790, ay1 : -2080, bx0 : 840, by0 : -2050, bx1 : 810, by1 : -2080, dstx : "NOT_FINITE", dsty : "NOT_FINITE"},{ title : "parallel-13", ax0 : 1020, ay0 : -2120, ax1 : 1010, ay1 : -2090, bx0 : 1040, by0 : -2140, bx1 : 1030, by1 : -2110, dstx : "NOT_FINITE", dsty : "NOT_FINITE"},{ title : "parallel-14", ax0 : 1180, ay0 : -2140, ax1 : 1190, ay1 : -2090, bx0 : 1180, by0 : -2140, bx1 : 1190, by1 : -2090, dstx : "NOT_FINITE", dsty : "NOT_FINITE"}];
};
var data_VecTestData = function() { };
$hxClasses["data.VecTestData"] = data_VecTestData;
data_VecTestData.__name__ = ["data","VecTestData"];
data_VecTestData.forEquals = function() {
	return [{ title : "equals 0", ax : 0.0, ay : 0.0, bx : 0.0, by : 0.0, res : true},{ title : "equals 1", ax : 1.01, ay : -20.0, bx : 1.01, by : -20.0, res : true},{ title : "equals 2", ax : -1.01, ay : 20.0, bx : 1.01, by : -20.0, res : false},{ title : "equals 3", ax : 1.0, ay : 0.0, bx : 0.0, by : 0.0, res : false},{ title : "equals 4", ax : 1.0, ay : -2.1, bx : 3.0, by : 1.0, res : false},{ title : "equals 5", ax : -Infinity, ay : 1.0, bx : -Infinity, by : 1.0, res : true},{ title : "equals 6", ax : NaN, ay : 1.0, bx : NaN, by : 1.0, res : false}];
};
data_VecTestData.forNegate = function() {
	return [{ title : "negate 0", ax : 0.0, ay : 0.0, dstx : 0.0, dsty : 0.0},{ title : "negate 1", ax : 1.0, ay : 0.0, dstx : -1.0, dsty : 0.0},{ title : "negate 2", ax : 54.23414, ay : -2.1, dstx : -54.23414, dsty : 2.1},{ title : "negate 3", ax : -341.0, ay : -243.1, dstx : 341.0, dsty : 243.1},{ title : "negate 4", ax : Infinity, ay : -Infinity, dstx : -Infinity, dsty : Infinity},{ title : "negate 5", ax : NaN, ay : 0.0, dstx : NaN, dsty : 0.0}];
};
data_VecTestData.forSwapXY = function() {
	return [{ title : "swapXY 0", ax : 0.0, ay : 0.0, dstx : 0.0, dsty : 0.0},{ title : "swapXY 1", ax : 1.0, ay : 0.0, dstx : 0.0, dsty : 1.0},{ title : "swapXY 2", ax : 54.23414, ay : -2.1, dstx : -2.1, dsty : 54.23414},{ title : "swapXY 3", ax : -341.0, ay : -243.1, dstx : -243.1, dsty : -341.0},{ title : "swapXY 4", ax : Infinity, ay : -Infinity, dstx : -Infinity, dsty : Infinity},{ title : "swapXY 5", ax : NaN, ay : 0.0, dstx : 0.0, dsty : NaN}];
};
data_VecTestData.forAdd = function() {
	return [{ title : "add 0", ax : 0.0, ay : 0.0, bx : 0.0, by : 0.0, dstx : 0.0, dsty : 0.0},{ title : "add 1", ax : 1.0, ay : 0.0, bx : 0.0, by : 0.0, dstx : 1.0, dsty : 0.0},{ title : "add 2", ax : 1.0, ay : -2.1, bx : 3.0, by : 1.0, dstx : 4.0, dsty : -1.1}];
};
data_VecTestData.forSub = function() {
	return [{ title : "sub 0", ax : 0.0, ay : 0.0, bx : 0.0, by : 0.0, dstx : 0.0, dsty : 0.0},{ title : "sub 1", ax : 1.0, ay : 0.0, bx : 0.0, by : 0.0, dstx : 1.0, dsty : 0.0},{ title : "sub 2", ax : 1.0, ay : -2.1, bx : 3.0, by : 1.0, dstx : -2.0, dsty : -3.1}];
};
data_VecTestData.forMul = function() {
	return [{ title : "mul 0", ax : 0.0, ay : 0.0, bx : 0.0, by : 0.0, dstx : 0.0, dsty : 0.0},{ title : "mul 1", ax : 1.0, ay : 0.0, bx : 0.0, by : 0.0, dstx : 0.0, dsty : 0.0},{ title : "mul 2", ax : 1.0, ay : -2.1, bx : 3.0, by : 2.0, dstx : 3.0, dsty : -4.2}];
};
data_VecTestData.forDiv = function() {
	return [{ title : "div 0", ax : 0.0, ay : 0.0, bx : 0.0, by : 0.0, dstx : NaN, dsty : NaN},{ title : "div 1", ax : 0.0, ay : 0.0, bx : 1.0, by : -3.0, dstx : 0.0, dsty : 0.0},{ title : "div 2", ax : 1.0, ay : -4.2, bx : 3.0, by : 2.0, dstx : 0.33333, dsty : -2.1}];
};
data_VecTestData.forMagnitude = function() {
	return [{ title : "magnitude 0", x : 0.0, y : 0.0, mag : 0.0},{ title : "magnitude 1", x : 1.0, y : 0.0, mag : 1.0},{ title : "magnitude 2", x : 0.0, y : -2.0, mag : 4.0},{ title : "magnitude 3", x : 1.0, y : -1.0, mag : 2.0}];
};
data_VecTestData.forMagnitudeBetween = function() {
	return [{ title : "magnitudeBetween 0", ax : 0.0, ay : 0.0, bx : 0.0, by : 0.0, res : 0.0},{ title : "magnitudeBetween 1", ax : 2.0, ay : 0.0, bx : -1.0, by : -3.0, res : 18.0},{ title : "magnitudeBetween 2", ax : 1.0, ay : -4.2, bx : 3.0, by : 2.0, res : 42.44},{ title : "magnitudeBetween 3", ax : -38.96409149747342, ay : -48.07111429981887, bx : 40.19438698887825, by : 41.63253072183579, res : 14312.80864644523},{ title : "magnitudeBetween 4", ax : -28.477004496380687, ay : -40.91400697361678, bx : -4.715183493681252, by : 34.78811744134873, res : 6295.435778303246},{ title : "magnitudeBetween 5", ax : -46.28241539467126, ay : -9.67974488157779, bx : 11.831343290396035, by : -6.18134387768805, res : 3389.4477580902517},{ title : "magnitudeBetween 6", ax : 0.3379691857844591, ay : -45.38187102880329, bx : 26.44029213115573, by : 31.278894771821797, res : 6558.204276282744},{ title : "magnitudeBetween 7", ax : -17.822278337553144, ay : -12.160695623606443, bx : -21.072908607311547, by : -32.873678067699075, res : 439.5942388799591},{ title : "magnitudeBetween 8", ax : -24.697448988445103, ay : 17.946900497190654, bx : -31.333478493615985, by : 45.23853969294578, res : 788.8704575847759},{ title : "magnitudeBetween 9", ax : 1.7591102048754692, ay : -21.37788264080882, bx : -31.363432831130922, by : 4.821444675326347, res : 1783.507608990082},{ title : "magnitudeBetween 10", ax : -6.044126371853054, ay : -25.546874897554517, bx : -11.131311976350844, by : 40.25179953314364, res : 4355.345014211622},{ title : "magnitudeBetween 11", ax : -23.39778123423457, ay : -49.56638829316944, bx : -20.32672460190952, by : 20.323040895164013, res : 4893.963701110024},{ title : "magnitudeBetween 12", ax : 24.80296918656677, ay : -3.721625986509025, bx : 49.16150670032948, by : 31.35373000986874, res : 1823.6189480820192}];
};
data_VecTestData.forNormalize = function() {
	return [{ title : "normalize 0", x : 0.0, y : 0.001, nlen : 0.0, nx : 0.0, ny : 0.0},{ title : "normalize 1", x : 1.0, y : -10.0, nlen : 0.0, nx : 0.0, ny : 0.0},{ title : "normalize 2", x : 1.0, y : 0.0, nlen : 1.0, nx : 1.0, ny : 0.0},{ title : "normalize 3", x : 10.0, y : 0.0, nlen : 0.5, nx : 0.5, ny : 0.0},{ title : "normalize 4", x : 10.0, y : 0.0, nlen : 5.0, nx : 5.0, ny : 0.0},{ title : "normalize 5", x : 1456.546, y : -103.4578, nlen : 16.357, nx : 16.31589334, ny : -1.158910484128135},{ title : "normalize by zero", x : 1.0, y : 0.0, nlen : 0.0, nx : 0.0, ny : 0.0},{ title : "normalize by +inf", x : 1.0, y : 0.01, nlen : Infinity, nx : Infinity, ny : Infinity},{ title : "normalize zero len", x : 0.0, y : 0.0, nlen : 1.0, nx : NaN, ny : NaN},{ title : "normalize inf len", x : Infinity, y : Infinity, nlen : 1.0, nx : NaN, ny : NaN},{ title : "normalize inf len by zero", x : Infinity, y : Infinity, nlen : 0.0, nx : NaN, ny : NaN}];
};
data_VecTestData.forLength = function() {
	return [{ title : "length 0", x : 0.0, y : 0.0, len : 0.0},{ title : "length 1", x : 1.0, y : 0.0, len : 1.0},{ title : "length 2", x : 0.0, y : -2.0, len : 2.0},{ title : "length 3", x : 1.0, y : -1.0, len : 1.41421356}];
};
data_VecTestData.forLengthBetween = function() {
	return [{ title : "lengthBetween 0", ax : 0.0, ay : 0.0, bx : 0.0, by : 0.0, res : 0.0},{ title : "lengthBetween 1", ax : 2.0, ay : 0.0, bx : -1.0, by : -3.0, res : 4.242640687119285},{ title : "lengthBetween 2", ax : 1.0, ay : -4.2, bx : 3.0, by : 2.0, res : 6.514598989960933},{ title : "lengthBetween 3", ax : -22.220536414533854, ay : -24.781520827673376, bx : 0.8620108710601926, by : 3.173346002586186, res : 36.2529801352831},{ title : "lengthBetween 4", ax : -23.458581953309476, ay : -46.47534827236086, bx : 11.273438460193574, by : 35.08489611558616, res : 88.64754202247029},{ title : "lengthBetween 5", ax : 5.682936403900385, ay : 25.33840574324131, bx : -35.23991843685508, by : 10.706756240688264, res : 43.459926547143446},{ title : "lengthBetween 6", ax : 17.617744277231395, ay : 35.90192322153598, bx : 36.449413327500224, by : 7.8260248294100165, res : 33.80662405126892},{ title : "lengthBetween 7", ax : -21.748583437874913, ay : -15.01226609107107, bx : -46.94942878559232, by : -35.63151000998914, res : 32.56126266021344},{ title : "lengthBetween 8", ax : -48.710581683553755, ay : 10.31326747033745, bx : 22.797767934389412, by : 43.28649442177266, res : 78.74438240708251},{ title : "lengthBetween 9", ax : -7.253401610068977, ay : -40.721820504404604, bx : -39.292955002747476, by : 22.987509076483548, res : 71.31207231071417},{ title : "lengthBetween 10", ax : -34.850347763858736, ay : 35.83398952614516, bx : 11.504359543323517, by : -1.7751858802512288, res : 59.69262068533787},{ title : "lengthBetween 11", ax : 43.42229473404586, ay : 41.396211134269834, bx : 11.552519258111715, by : -33.629608480259776, res : 81.51414722438302},{ title : "lengthBetween 12", ax : 45.4042972298339, ay : -10.42542567010969, bx : -33.30966159701347, by : 13.354177493602037, res : 82.22747011077401}];
};
data_VecTestData.forDotProd = function() {
	return [{ title : "dotProd 0", ax : 0.0, ay : 0.0, bx : 0.0, by : 0.0, res : 0.0},{ title : "dotProd 1", ax : 2.0, ay : 0.0, bx : -1.0, by : -3.0, res : -2.0},{ title : "dotProd 2", ax : 1.0, ay : -4.2, bx : 3.0, by : 2.0, res : -5.4},{ title : "dotProd 3", ax : 47.04338014125824, ay : 41.600377997383475, bx : -7.775258366018534, by : 49.848217284306884, res : 1707.9302465137625},{ title : "dotProd 4", ax : 13.895986741408706, ay : 32.130327518098056, bx : 33.63645456265658, by : -10.840066755190492, res : 119.11683146835526},{ title : "dotProd 5", ax : -9.384664660319686, ay : 31.32027257233858, bx : 28.89059311710298, by : 8.493502135388553, res : -5.109726267642202},{ title : "dotProd 6", ax : 12.495414796285331, ay : -33.63708222750574, bx : 11.544698313809931, by : 25.364289293065667, res : -708.9248904640624},{ title : "dotProd 7", ax : 30.630953120999038, ay : -12.730123731307685, bx : 0.7369721308350563, by : -49.46204936131835, res : 652.2321671647222},{ title : "dotProd 8", ax : -39.45935405790806, ay : 21.81887098122388, bx : -5.340210371650755, by : -34.585622837767005, res : -543.8979907038286},{ title : "dotProd 9", ax : 8.180483686737716, ay : -31.08943896368146, bx : -43.09277778957039, by : 11.445035133510828, res : -708.3394869442687},{ title : "dotProd 10", ax : 27.631175983697176, ay : 2.5192717788740993, bx : -15.129962493665516, by : 31.017273082397878, res : -339.9177155550934},{ title : "dotProd 11", ax : -46.24206635635346, ay : 18.34020607639104, bx : -39.26879654172808, by : -41.21174004394561, res : 1060.0384902441137},{ title : "dotProd 12", ax : 27.5544814998284, ay : 19.330651429481804, bx : 31.365368771366775, by : 41.50482788681984, res : 1666.5718340666713}];
};
data_VecTestData.forSkewProd = function() {
	return [{ title : "skewProd 0", ax : 0.0, ay : 0.0, bx : 0.0, by : 0.0, res : 0.0},{ title : "skewProd 1", ax : 2.0, ay : 0.0, bx : -1.0, by : -3.0, res : -6.0},{ title : "skewProd 2", ax : 1.0, ay : -4.2, bx : 3.0, by : 2.0, res : 14.6},{ title : "skewProd 3", ax : -31.5633233403787, ay : 0.9075907059013844, bx : 26.655443920753896, by : 9.39316563308239, res : -320.6717572308643},{ title : "skewProd 4", ax : 33.405668660998344, ay : 28.653522254899144, bx : 34.452908602543175, by : 10.346550238318741, res : -641.5637543433277},{ title : "skewProd 5", ax : 23.420891305431724, ay : -21.65605081245303, bx : -46.27028307877481, by : 8.640190144069493, res : -799.670647238019},{ title : "skewProd 6", ax : -42.99659754615277, ay : 45.28900713194162, bx : 9.87201298121363, by : -33.14346980769187, res : 977.9627662915884},{ title : "skewProd 7", ax : 10.824489081278443, ay : 40.02647218294442, bx : 14.365277579054236, by : -7.316884398460388, res : -654.1929186984006},{ title : "skewProd 8", ax : 13.029147568158805, ay : 3.5721450811252, bx : -32.70659688860178, by : -12.275223759934306, res : -43.10299260438964},{ title : "skewProd 9", ax : 14.901434327475727, ay : -41.062885290011764, bx : 11.082433257251978, by : -9.253554814495146, res : 317.18544621285315},{ title : "skewProd 10", ax : -3.5290833096951246, ay : 20.008989213965833, bx : -37.96465874183923, by : -28.654310735873878, res : 860.7578970461452},{ title : "skewProd 11", ax : -36.96292138192803, ay : 45.57672147639096, bx : -2.5320588378235698, by : -3.272634372115135, res : 236.36906742160613},{ title : "skewProd 12", ax : 43.8064054120332, ay : -20.471213897690177, bx : 15.215010056272149, by : 13.754338724538684, res : 913.9978636590236}];
};
data_VecTestData.forPolar = function() {
	return [{ title : "polar 0", radians : 0.0, len : 0.0, dstx : 0.0, dsty : 0.0},{ title : "polar 1", radians : 0.0, len : 1.0, dstx : 1.0, dsty : 0.0},{ title : "polar 2", radians : 0.0, len : 11.742, dstx : 11.742, dsty : 0.0},{ title : "polar 3", radians : 1.5707963267948966, len : 11.742, dstx : 0.0, dsty : 11.742},{ title : "polar 4", radians : 3.141592653589793, len : 11.742, dstx : -11.742, dsty : 0.0},{ title : "polar 5", radians : 14.509838470257819, len : 0.17437741626054049, dstx : -0.0634916679090821, dsty : 0.16240779355629656},{ title : "polar 6", radians : 6.252936506643891, len : 14.13229804020375, dstx : 14.125833077949785, dsty : -0.4274198767563454},{ title : "polar 7", radians : -8.688094490207732, len : -9.643486887216568, dstx : 7.142938346062579, dsty : 6.478832543619775},{ title : "polar 8", radians : -34.74226433318108, len : -16.380987549200654, dstx : 16.10223389993207, dsty : -3.009122217349316},{ title : "polar 9", radians : -24.98743024189025, len : -11.59700124990195, dstx : -11.474779558229361, dsty : -1.6792474743970873},{ title : "polar 10", radians : 42.49081136658788, len : 46.303243935108185, dstx : 3.668486704683142, dsty : -46.157692795586044},{ title : "polar 11", radians : -2.3477925453335047, len : 18.95254955161363, dstx : -13.28840614824936, dsty : -13.513600428662178},{ title : "polar 12", radians : 14.018593775108457, len : 41.752883372828364, dstx : 4.9391787511121965, dsty : 41.45971277287831},{ title : "polar 13", radians : 41.17666238453239, len : -47.137765446677804, dstx : 44.50252642614957, dsty : 15.540079568518024},{ title : "polar 14", radians : -31.610971386544406, len : 40.85586192086339, dstx : 40.08119302449997, dsty : -7.918296472691001}];
};
data_VecTestData.forRadiansOf = function() {
	return [{ title : "radiansOf 0", x : 0.0, y : 0.0, res : 0.0},{ title : "radiansOf 1", x : 1.0, y : 0.0, res : 0.0},{ title : "radiansOf 2", x : 0.0, y : 1.0, res : 1.5707963267948966},{ title : "radiansOf 3", x : 0.0, y : -1.0, res : -1.5707963267948966},{ title : "radiansOf 4", x : -1.0, y : 0.0, res : 3.141592653589793},{ title : "radiansOf 5", x : -27.568654040805995, y : 37.242086487822235, res : 2.2080316380770757},{ title : "radiansOf 6", x : -0.16655644867569208, y : 47.726040333509445, res : 1.574286156903415},{ title : "radiansOf 7", x : -49.202754511497915, y : 36.68372789397836, res : 2.500937609237117},{ title : "radiansOf 8", x : 31.515119643881917, y : 42.41541980300099, res : 0.9317832622272681},{ title : "radiansOf 9", x : -13.976780651137233, y : 23.565658484585583, res : 2.1061264922614558},{ title : "radiansOf 10", x : -11.307154153473675, y : -30.703870835714042, res : -1.9236491090633192},{ title : "radiansOf 11", x : 8.540880121290684, y : -33.845746237784624, res : -1.323609734282312},{ title : "radiansOf 12", x : 48.24588450137526, y : 22.986004245467484, res : 0.4446181153236716},{ title : "radiansOf 13", x : 37.64873093459755, y : 44.32667447254062, res : 0.8666814461990682},{ title : "radiansOf 14", x : -41.51440777350217, y : -31.13270888570696, res : -2.4981392900374573}];
};
data_VecTestData.forRadiansBetween = function() {
	return [{ title : "radiansBetween 0", ax : 0.0, ay : 0.0, bx : 0.0, by : 0.0, res : NaN},{ title : "radiansBetween 1", ax : 1.0, ay : 0.0, bx : 0.0, by : 0.0, res : NaN},{ title : "radiansBetween 2", ax : 1.0, ay : 0.0, bx : 1.0, by : 0.0, res : 0.0},{ title : "radiansBetween 3", ax : 0.0, ay : -1.0, bx : 0.0, by : -1.0, res : 0.0},{ title : "radiansBetween 4", ax : -1.0, ay : 1.0, bx : -1.0, by : 1.0, res : 0.0},{ title : "radiansBetween 5", ax : -10.0, ay : 0.1, bx : -10.0, by : 0.1, res : 0.0},{ title : "radiansBetween 6", ax : -10.0, ay : 0.0, bx : 0.0, by : 0.1, res : 1.5707963267948966},{ title : "radiansBetween 7", ax : 10.0, ay : 0.0, bx : 0.0, by : 0.1, res : 1.5707963267948966},{ title : "radiansBetween 8", ax : 10.0, ay : 0.1, bx : -0.1, by : 10.0, res : 1.5707963267948966},{ title : "radiansBetween 9", ax : 10.0, ay : 0.1, bx : -10.0, by : -0.1, res : 3.141592653589793},{ title : "radiansBetween 10", ax : 38.19597293186883, ay : -18.51688402526394, bx : 9.757460034348483, by : 5.217162212371741, res : 0.9424113819368083},{ title : "radiansBetween 11", ax : 28.393740041669254, ay : 15.878574055696113, bx : 10.352626989773286, by : 15.055349857096763, res : 0.4585150243854874},{ title : "radiansBetween 12", ax : -83.3952854416544, ay : -36.32413368093553, bx : -21.421696769942944, by : 42.11167310024376, res : 1.511008436069265},{ title : "radiansBetween 13", ax : -71.25884887558314, ay : -7.921986049537702, bx : -82.36755412414998, by : 2.8443954966558382, res : 0.14523657293194292},{ title : "radiansBetween 14", ax : -1.3245845565364525, ay : 1.6210676419366956, bx : -35.604384982232624, by : 10.413432159515175, res : 0.6011714779593884},{ title : "radiansBetween 15", ax : 36.36138803278546, ay : 5.896933122530507, bx : 1.7781581247346803, by : 31.35231899870623, res : 1.3533657385095772},{ title : "radiansBetween 16", ax : -39.24901017307988, ay : -11.0044699380445, bx : 0.0895634445938724, by : 2.4977002199888534, res : 1.8799964186541083},{ title : "radiansBetween 17", ax : -20.515759458872726, ay : -24.292915685641933, bx : -55.32077130750409, by : -39.33215666536997, res : 0.2514350715885403},{ title : "radiansBetween 18", ax : -37.06479090162807, ay : -44.17686699080061, bx : -53.41854762087541, by : 77.7278330235114, res : 1.841395724700266},{ title : "radiansBetween 19", ax : -15.295348196379907, ay : -70.7276612709782, bx : -36.69991704345685, by : 43.1809999520649, res : 2.2241742059204452}];
};
data_VecTestData.forRadiansBetweenNormals = function() {
	return [{ title : "radiansBetweenNormals 0", ax : 0.0, ay : 0.0, bx : 0.0, by : 0.0, res : 1.5707963267948966},{ title : "radiansBetweenNormals 1", ax : 1.0, ay : 0.0, bx : 0.0, by : 0.0, res : 1.5707963267948966},{ title : "radiansBetweenNormals 2", ax : 1.0, ay : 0.0, bx : 1.0, by : 0.0, res : 0.0},{ title : "radiansBetweenNormals 3", ax : 0.0, ay : -1.0, bx : 0.0, by : -1.0, res : 0.0},{ title : "radiansBetweenNormals 4", ax : 1.0, ay : 0.0, bx : 0.0, by : 1.0, res : 1.5707963267948966},{ title : "radiansBetweenNormals 5", ax : 1.0, ay : 0.0, bx : 0.0, by : -1.0, res : 1.5707963267948966},{ title : "radiansBetweenNormals 6", ax : 1.0, ay : 0.0, bx : -1.0, by : 0.0, res : 3.141592653589793},{ title : "radiansBetweenNormals 7", ax : -0.17424853098411236, ay : -0.9847017058225698, bx : -0.2539700431525964, by : 0.9672120849023074, res : 2.7096673985349264},{ title : "radiansBetweenNormals 8", ax : 0.6181470482248117, ay : -0.7860624827397326, bx : -0.6573430400476058, by : 0.7535914859530803, res : 3.0906883226600845},{ title : "radiansBetweenNormals 9", ax : -0.9159576755565045, ay : 0.4012748890587661, bx : 0.775802355850649, by : -0.6309759937244704, res : 2.8716903273716863},{ title : "radiansBetweenNormals 10", ax : -0.7720909511931137, ay : 0.6355120479469394, bx : -0.9248072530053542, by : -0.38043599302470155, res : 1.078939228412481},{ title : "radiansBetweenNormals 11", ax : 0.80219331825753, ay : -0.5970643852575475, bx : -0.23707989769829207, by : -0.9714901554351271, res : 1.1703186551209628},{ title : "radiansBetweenNormals 12", ax : 0.9921357487816692, ay : 0.1251665130513611, bx : 0.744600362441626, by : 0.6675105244502136, res : 0.6053647219734043},{ title : "radiansBetweenNormals 13", ax : -0.7021979178585697, ay : 0.7119818004381078, bx : 0.982437589825841, by : 0.18659148452486432, res : 2.161584636893666},{ title : "radiansBetweenNormals 14", ax : -0.7785378320539624, ay : -0.6275976769083169, bx : 0.986943577651767, by : 0.1610663668551898, res : 2.6249000119073114},{ title : "radiansBetweenNormals 15", ax : 0.19279544970968474, ay : 0.981238969146273, bx : 0.5850624022567444, by : 0.8109882770210475, res : 0.4309467501133504},{ title : "radiansBetweenNormals 16", ax : -0.8018508378369592, ay : 0.5975242537840338, bx : 0.9488072039063575, by : 0.31585580541664854, res : 2.1798241502883253}];
};
data_VecTestData.forRadiansBetween_notnormal = function() {
	return [{ title : "radiansBetween_notnormal 0", ax : -1.0, ay : 1.0, bx : -1.0, by : 1.0, res : 0.0},{ title : "radiansBetween_notnormal 1", ax : -10.0, ay : 0.7, bx : -10.0, by : 0.7, res : 0.0},{ title : "radiansBetween_notnormal 2", ax : 10.0, ay : 0.7, bx : -10.0, by : -0.7, res : 3.141592653589793},{ title : "radiansBetween_notnormal 3", ax : 38.19597293186883, ay : -18.51688402526394, bx : 9.757460034348483, by : 5.217162212371741, res : 0.9424113819368083},{ title : "radiansBetween_notnormal 4", ax : 28.393740041669254, ay : 15.878574055696113, bx : 10.352626989773286, by : 15.055349857096763, res : 0.4585150243854874},{ title : "radiansBetween_notnormal 5", ax : -83.3952854416544, ay : -36.32413368093553, bx : -21.421696769942944, by : 42.11167310024376, res : 1.511008436069265},{ title : "radiansBetween_notnormal 6", ax : -71.25884887558314, ay : -7.921986049537702, bx : -82.36755412414998, by : 2.8443954966558382, res : 0.14523657293194292},{ title : "radiansBetween_notnormal 7", ax : -1.3245845565364525, ay : 1.6210676419366956, bx : -35.604384982232624, by : 10.413432159515175, res : 0.6011714779593884},{ title : "radiansBetween_notnormal 8", ax : 36.36138803278546, ay : 5.896933122530507, bx : 1.7781581247346803, by : 31.35231899870623, res : 1.3533657385095772},{ title : "radiansBetween_notnormal 9", ax : -39.24901017307988, ay : -11.0044699380445, bx : 0.0895634445938724, by : 2.4977002199888534, res : 1.8799964186541083},{ title : "radiansBetween_notnormal 10", ax : -20.515759458872726, ay : -24.292915685641933, bx : -55.32077130750409, by : -39.33215666536997, res : 0.2514350715885403},{ title : "radiansBetween_notnormal 11", ax : -37.06479090162807, ay : -44.17686699080061, bx : -53.41854762087541, by : 77.7278330235114, res : 1.841395724700266},{ title : "radiansBetween_notnormal 12", ax : -15.295348196379907, ay : -70.7276612709782, bx : -36.69991704345685, by : 43.1809999520649, res : 2.2241742059204452}];
};
data_VecTestData.forNormalBisector = function() {
	return [{ title : "normalBisector 0", ax : 0.0, ay : 0.0, bx : 0.0, by : 0.0, dstx : NaN, dsty : NaN},{ title : "normalBisector 1", ax : 1.0, ay : 0.0, bx : -1.0, by : 0.0, dstx : NaN, dsty : NaN},{ title : "normalBisector 2", ax : 1.0, ay : 0.0, bx : 1.0, by : 0.0, dstx : 1.0, dsty : 0.0},{ title : "normalBisector 3", ax : 777.0, ay : 0.0, bx : 0.13, by : 0.0, dstx : 1.0, dsty : 0.0},{ title : "normalBisector 4", ax : 777.0, ay : 777.0, bx : 0.13, by : 0.13, dstx : 0.7071067811865475, dsty : 0.7071067811865475},{ title : "normalBisector 5", ax : 0.8987595052710436, ay : -0.4384419593115476, bx : -0.6334226515230947, by : 0.7738060122133015, dstx : 0.6204733657504913, dsty : 0.7842275195338768},{ title : "normalBisector 6", ax : -0.9300793462853079, ay : -0.36735869339583394, bx : -0.9461479315957312, by : 0.32373460046328023, dstx : -0.9997298058828112, dsty : -0.02324468174694177},{ title : "normalBisector 7", ax : 0.6883388353674831, ay : -0.7253893076996221, bx : -0.396418268676861, by : -0.9180700170788937, dstx : 0.17488815927891835, dsty : -0.9845883057115962},{ title : "normalBisector 8", ax : 0.8329695705099865, ay : 0.5533188001544936, bx : -0.4142859575803549, by : -0.9101467713241246, dstx : 0.7610892599818776, dsty : -0.6486471601265499},{ title : "normalBisector 9", ax : 0.9997558878398577, ay : -0.022094450197683944, bx : -0.9890770148308524, by : 0.14739965648972778, dstx : 0.08491509072377285, dsty : 0.9963881911019287},{ title : "normalBisector 10", ax : -0.6849834017594324, ay : 0.7285586725268433, bx : -0.9569460230561077, by : 0.29026592799896334, dstx : -0.8497106516310231, dsty : 0.5272492849732298},{ title : "normalBisector 11", ax : 0.22537046545568967, ay : -0.9742731410134869, bx : -0.43401225807990873, by : 0.9009069651392305, dstx : -0.9433758302156627, dsty : -0.33172585513479186},{ title : "normalBisector 12", ax : -0.8084909853295303, ay : 0.5885085612298984, bx : 0.40539363715633053, by : 0.9141422203099261, dstx : -0.25909686993000974, dsty : 0.96585134052424},{ title : "normalBisector 13", ax : 0.9830992922224067, ay : -0.1830731592336876, bx : -0.9170345939247182, by : -0.39880766485277996, dstx : 0.11281170293444602, dsty : -0.9936163845675202},{ title : "normalBisector 14", ax : -0.12147805839163929, ay : 0.9925941171140384, bx : -0.9503336475134021, by : 0.31123296484124663, dstx : -0.6350262499971127, dsty : 0.7724905577510993}];
};
data_VecTestData.forRotate = function() {
	return [{ title : "rotate 0", x : 0.0, y : 0.0, rad : 0.0, dstx : 0.0, dsty : 0.0},{ title : "rotate 1", x : 0.0, y : 0.0, rad : 10.0, dstx : 0.0, dsty : 0.0},{ title : "rotate 2", x : 1.0, y : 0.0, rad : 0.0, dstx : 1.0, dsty : 0.0},{ title : "rotate 3", x : 1.0, y : 0.0, rad : 1.5707963267948966, dstx : 0.0, dsty : 1.0},{ title : "rotate 4", x : 1.0, y : 0.0, rad : -1.5707963267948966, dstx : 0.0, dsty : -1.0},{ title : "rotate 5", x : 1.0, y : 2.0, rad : 1.5707963267948966, dstx : -2.0, dsty : 1.0},{ title : "rotate 6", x : 1.0, y : 2.0, rad : 3.141592653589793, dstx : -1.0, dsty : -2.0},{ title : "rotate 7", x : -3.013579332013442, y : -3.000822925372475, rad : -3.181268088519573, dstx : 3.1302354663042946, dsty : 2.8789276728098505},{ title : "rotate 8", x : 4.705043723843297, y : 1.8347091013910575, rad : -0.42722708312794566, dstx : 5.042355294348116, dsty : -0.27972668010739576},{ title : "rotate 9", x : -1.3964926983165067, y : 2.481885543801475, rad : 2.187229513656348, dstx : -1.2177316299338519, dsty : -2.5743110508329616},{ title : "rotate 10", x : -2.058277176520919, y : 4.518319678369592, rad : 4.344833008944988, dstx : 4.956146201171824, dsty : 0.2972078127151414},{ title : "rotate 11", x : 1.8665824508204363, y : 2.7124298022395674, rad : 0.6560787605121732, dstx : -0.1755593476975412, dsty : 3.2879453148165676},{ title : "rotate 12", x : -0.9245365670316769, y : 0.26326060992164085, rad : -0.23840986425057054, dstx : -0.8362147591471811, dsty : 0.4741507029410106},{ title : "rotate 13", x : -4.870204705674042, y : 2.447505417115033, rad : -1.596584536600858, dstx : 2.572271568352119, dsty : 4.805475587350782},{ title : "rotate 14", x : -0.2799353275637007, y : 0.35087944300724744, rad : -0.07702389499172568, dstx : -0.2521059681718761, dsty : 0.3713795254929835},{ title : "rotate 15", x : -7.826530029369389, y : 5.7000803817835015, rad : 3.760652400087565, dstx : 9.6817008155971, dsty : -0.1007867882233421},{ title : "rotate 16", x : -1.1817468536321514, y : -5.8868629400884345, rad : 4.044634641613811, dstx : -3.890682168041147, dsty : 4.5732125654448605}];
};
data_VecTestData.forRotateQuart = function() {
	return [{ title : "rotateQuart 0", x : 0.0, y : 0.0, times : 0, dstx : 0.0, dsty : 0.0},{ title : "rotateQuart 1", x : 0.0, y : 0.0, times : 17, dstx : 0.0, dsty : 0.0},{ title : "rotateQuart 2", x : 1.0, y : 0.0, times : 0, dstx : 1.0, dsty : 0.0},{ title : "rotateQuart 3", x : 1.0, y : 0.0, times : 1, dstx : 0.0, dsty : 1.0},{ title : "rotateQuart 4", x : 1.0, y : 0.0, times : -1, dstx : 0.0, dsty : -1.0},{ title : "rotateQuart 5", x : 1.0, y : 2.0, times : 1, dstx : -2.0, dsty : 1.0},{ title : "rotateQuart 6", x : 1.0, y : 2.0, times : 2, dstx : -1.0, dsty : -2.0},{ title : "rotateQuart 7", x : 4.274210721872946, y : 4.483460162338479, times : -28, dstx : 4.274210721872938, dsty : 4.483460162338486},{ title : "rotateQuart 8", x : -0.008215158387224517, y : 0.003349779995701022, times : 30, dstx : 0.0082151583872245, dsty : -0.003349779995701066},{ title : "rotateQuart 9", x : -4.324447908070471, y : 2.3902853454368405, times : -35, dstx : -2.3902853454368236, dsty : -4.324447908070481},{ title : "rotateQuart 10", x : -1.460307419982559, y : 1.163484382462644, times : -38, dstx : 1.460307419982566, dsty : -1.163484382462635},{ title : "rotateQuart 11", x : 0.6240253008423334, y : -4.7830663948362595, times : 48, dstx : 0.6240253008423193, dsty : -4.78306639483626},{ title : "rotateQuart 12", x : -2.8544411213547995, y : -5.441135411383697, times : -19, dstx : 5.441135411383705, dsty : -2.8544411213547836},{ title : "rotateQuart 13", x : -6.744545330689634, y : 5.520133996571679, times : -45, dstx : 5.520133996571673, dsty : 6.744545330689641},{ title : "rotateQuart 14", x : -2.3524160221137755, y : 2.0820337609806714, times : -36, dstx : -2.35241602211378, dsty : 2.082033760980666},{ title : "rotateQuart 15", x : -5.164123281832695, y : -6.413223461143079, times : -10, dstx : 5.164123281832691, dsty : 6.413223461143081},{ title : "rotateQuart 16", x : 3.662873228471797, y : -8.008855972630144, times : 2, dstx : -3.662873228471796, dsty : 8.008855972630144}];
};
data_VecTestData.forMirrorBy = function() {
	return [{ title : "mirrorBy 0", vx : 1.0, vy : 0.0, dirx : 0.0, diry : 1.0, dstx : -1.0, dsty : 0.0},{ title : "mirrorBy 1", vx : 1.0, vy : 2.0, dirx : 0.0, diry : 1.0, dstx : -1.0, dsty : 2.0},{ title : "mirrorBy 2", vx : 1.0, vy : 2.0, dirx : 0.0, diry : -1.0, dstx : -1.0, dsty : 2.0},{ title : "mirrorBy 3", vx : 1.0, vy : 2.0, dirx : 1.0, diry : 0.0, dstx : 1.0, dsty : -2.0},{ title : "mirrorBy 4", vx : 1.0, vy : 2.0, dirx : -1.0, diry : 0.0, dstx : 1.0, dsty : -2.0},{ title : "mirrorBy 5", vx : 3.4775319998888943, vy : 4.062027327607352, dirx : -2.042367781754823, diry : 5.589339639666629, dstx : -5.277166250555775, dsty : 0.8630244402537464},{ title : "mirrorBy 6", vx : 2.3525030712809825, vy : -0.5148572858079316, dirx : 4.556621331791734, diry : -1.971458656670129, dstx : 1.985899056868291, dsty : -1.3621870873949724},{ title : "mirrorBy 7", vx : 9.286157706620472, vy : 1.714082318296426, dirx : -1.5735851565178411, diry : -3.2600095317922473, dstx : -4.434572031888044, dsty : 8.336988307543653},{ title : "mirrorBy 8", vx : 3.419074564410317, vy : -3.86396108818317, dirx : -1.5807050176728439, diry : -1.3236867487455155, dstx : -3.203487687451018, dsty : 4.044494134541549},{ title : "mirrorBy 9", vx : -1.7214649141196774, vy : 1.0882601464590007, dirx : -5.654557064969443, diry : 8.027556783132951, dstx : -0.4450032213812917, dsty : 1.9873911869273013},{ title : "mirrorBy 10", vx : -3.618878082192606, vy : -1.7886413156193008, dirx : 1.2478141420956794, diry : -2.7207121561474206, dstx : 3.716563474850907, dsty : 1.5756497920282069},{ title : "mirrorBy 11", vx : -0.5689450025573392, vy : -3.858809884456279, dirx : -6.46806961191773, diry : -6.46760085037266, dstx : -3.8588511090668685, dsty : -0.5686653307226095},{ title : "mirrorBy 12", vx : -1.665164737629622, vy : 5.205694030041662, dirx : -0.5119580963114118, diry : 8.813009821460428, dstx : 1.0511884077070028, dsty : 5.363490176122162},{ title : "mirrorBy 13", vx : 4.286269267710801, vy : -1.2156279309929119, dirx : -5.5036706466287, diry : 2.308362599523776, dstx : 3.8710045193523452, dsty : -2.2057151931031154},{ title : "mirrorBy 14", vx : -4.741823090622956, vy : 1.1615816500307872, dirx : -5.119429756919686, diry : -3.5494749752765355, dstx : -0.5751577863725535, dsty : -4.848025543788761}];
};
data_VecTestData.forMirrorByNormal = function() {
	return [{ title : "mirrorByNormal 0", vx : 1.0, vy : 0.0, dirx : 0.0, diry : 1.0, dstx : -1.0, dsty : 0.0},{ title : "mirrorByNormal 1", vx : 1.0, vy : 2.0, dirx : 0.0, diry : 1.0, dstx : -1.0, dsty : 2.0},{ title : "mirrorByNormal 2", vx : 1.0, vy : 2.0, dirx : 0.0, diry : -1.0, dstx : -1.0, dsty : 2.0},{ title : "mirrorByNormal 3", vx : 1.0, vy : 2.0, dirx : 1.0, diry : 0.0, dstx : 1.0, dsty : -2.0},{ title : "mirrorByNormal 4", vx : 1.0, vy : 2.0, dirx : -1.0, diry : 0.0, dstx : 1.0, dsty : -2.0},{ title : "mirrorByNormal 5", vx : -2.9785884580489568, vy : 4.22093814337464, dirx : 0.21584550386560125, diry : 0.9764275285247772, dstx : 4.48023653850637, dsty : 2.5721175267957475},{ title : "mirrorByNormal 6", vx : -7.22106307992534, vy : -0.662600516419793, dirx : 0.46061726405015524, diry : 0.8875988598792529, dstx : 3.61510260413551, dsty : -6.286002275706975},{ title : "mirrorByNormal 7", vx : -8.911013857463038, vy : -1.9736681924727193, dirx : 0.5374697879155235, diry : 0.8432830053297897, dstx : 1.9736101297159108, dsty : -8.911026717374355},{ title : "mirrorByNormal 8", vx : 4.916940818240452, vy : 0.5104302368979239, dirx : -0.921031152291162, diry : -0.3894889170556904, dstx : 3.7913398110199563, dsty : 3.172158330568308},{ title : "mirrorByNormal 9", vx : 2.0805257961464236, vy : 0.7901166436416659, dirx : -0.7852951748233292, diry : 0.6191215457397657, dstx : -0.2827517024310359, dsty : -2.2074699032518277},{ title : "mirrorByNormal 10", vx : 0.3795992338395784, vy : -0.5375241258390443, dirx : -0.9189893163430373, diry : -0.3942824323341797, dstx : -0.12795915197370544, dsty : 0.6454875828525238},{ title : "mirrorByNormal 11", vx : -3.9789661647355117, vy : -7.342764056670765, dirx : -0.9998899508881192, diry : -0.014835299557291003, dstx : -4.19505496729772, dsty : 7.221486658119426},{ title : "mirrorByNormal 12", vx : -0.22480493974186158, vy : 2.197346499049321, dirx : -0.3547508897588984, diry : -0.9349608581193493, dstx : 1.6258461954359849, dsty : 1.495156529130974},{ title : "mirrorByNormal 13", vx : -3.508627491771716, vy : -0.5222887353499306, dirx : -0.9320882112866169, diry : 0.3622313713367673, dstx : -2.2352001203540093, dsty : 2.75447505362803},{ title : "mirrorByNormal 14", vx : -1.2104542424460163, vy : 5.0361597762568975, dirx : 0.20256308911148355, diry : -0.9792692147359751, dstx : -0.8868635557353385, dsty : 5.103094923529442}];
};
var haxe_StackItem = $hxClasses["haxe.StackItem"] = { __ename__ : ["haxe","StackItem"], __constructs__ : ["CFunction","Module","FilePos","Method","LocalFunction"] };
haxe_StackItem.CFunction = ["CFunction",0];
haxe_StackItem.CFunction.toString = $estr;
haxe_StackItem.CFunction.__enum__ = haxe_StackItem;
haxe_StackItem.Module = function(m) { var $x = ["Module",1,m]; $x.__enum__ = haxe_StackItem; $x.toString = $estr; return $x; };
haxe_StackItem.FilePos = function(s,file,line) { var $x = ["FilePos",2,s,file,line]; $x.__enum__ = haxe_StackItem; $x.toString = $estr; return $x; };
haxe_StackItem.Method = function(classname,method) { var $x = ["Method",3,classname,method]; $x.__enum__ = haxe_StackItem; $x.toString = $estr; return $x; };
haxe_StackItem.LocalFunction = function(v) { var $x = ["LocalFunction",4,v]; $x.__enum__ = haxe_StackItem; $x.toString = $estr; return $x; };
var haxe_CallStack = function() { };
$hxClasses["haxe.CallStack"] = haxe_CallStack;
haxe_CallStack.__name__ = ["haxe","CallStack"];
haxe_CallStack.getStack = function(e) {
	if(e == null) {
		return [];
	}
	var oldValue = Error.prepareStackTrace;
	Error.prepareStackTrace = function(error,callsites) {
		var stack = [];
		var _g = 0;
		while(_g < callsites.length) {
			var site = callsites[_g];
			++_g;
			if(haxe_CallStack.wrapCallSite != null) {
				site = haxe_CallStack.wrapCallSite(site);
			}
			var method = null;
			var fullName = site.getFunctionName();
			if(fullName != null) {
				var idx = fullName.lastIndexOf(".");
				if(idx >= 0) {
					var className = HxOverrides.substr(fullName,0,idx);
					var methodName = HxOverrides.substr(fullName,idx + 1,null);
					method = haxe_StackItem.Method(className,methodName);
				}
			}
			stack.push(haxe_StackItem.FilePos(method,site.getFileName(),site.getLineNumber()));
		}
		return stack;
	};
	var a = haxe_CallStack.makeStack(e.stack);
	Error.prepareStackTrace = oldValue;
	return a;
};
haxe_CallStack.callStack = function() {
	try {
		throw new Error();
	} catch( e ) {
		haxe_CallStack.lastException = e;
		if (e instanceof js__$Boot_HaxeError) e = e.val;
		var a = haxe_CallStack.getStack(e);
		a.shift();
		return a;
	}
};
haxe_CallStack.exceptionStack = function() {
	return haxe_CallStack.getStack(haxe_CallStack.lastException);
};
haxe_CallStack.makeStack = function(s) {
	if(s == null) {
		return [];
	} else if(typeof(s) == "string") {
		var stack = s.split("\n");
		if(stack[0] == "Error") {
			stack.shift();
		}
		var m = [];
		var rie10 = new EReg("^   at ([A-Za-z0-9_. ]+) \\(([^)]+):([0-9]+):([0-9]+)\\)$","");
		var _g = 0;
		while(_g < stack.length) {
			var line = stack[_g];
			++_g;
			if(rie10.match(line)) {
				var path = rie10.matched(1).split(".");
				var meth = path.pop();
				var file = rie10.matched(2);
				var line1 = Std.parseInt(rie10.matched(3));
				m.push(haxe_StackItem.FilePos(meth == "Anonymous function" ? haxe_StackItem.LocalFunction() : meth == "Global code" ? null : haxe_StackItem.Method(path.join("."),meth),file,line1));
			} else {
				m.push(haxe_StackItem.Module(StringTools.trim(line)));
			}
		}
		return m;
	} else {
		return s;
	}
};
var haxe_IMap = function() { };
$hxClasses["haxe.IMap"] = haxe_IMap;
haxe_IMap.__name__ = ["haxe","IMap"];
var haxe_Http = function(url) {
	this.url = url;
	this.headers = new List();
	this.params = new List();
	this.async = true;
	this.withCredentials = false;
};
$hxClasses["haxe.Http"] = haxe_Http;
haxe_Http.__name__ = ["haxe","Http"];
haxe_Http.prototype = {
	setHeader: function(header,value) {
		this.headers = Lambda.filter(this.headers,function(h) {
			return h.header != header;
		});
		this.headers.push({ header : header, value : value});
		return this;
	}
	,setPostData: function(data) {
		this.postData = data;
		return this;
	}
	,request: function(post) {
		var me = this;
		me.responseData = null;
		var r = this.req = js_Browser.createXMLHttpRequest();
		var onreadystatechange = function(_) {
			if(r.readyState != 4) {
				return;
			}
			var s;
			try {
				s = r.status;
			} catch( e ) {
				haxe_CallStack.lastException = e;
				s = null;
			}
			if(s != null && "undefined" !== typeof window) {
				var protocol = window.location.protocol.toLowerCase();
				var rlocalProtocol = new EReg("^(?:about|app|app-storage|.+-extension|file|res|widget):$","");
				var isLocal = rlocalProtocol.match(protocol);
				if(isLocal) {
					if(r.responseText != null) {
						s = 200;
					} else {
						s = 404;
					}
				}
			}
			if(s == undefined) {
				s = null;
			}
			if(s != null) {
				me.onStatus(s);
			}
			if(s != null && s >= 200 && s < 400) {
				me.req = null;
				me.onData(me.responseData = r.responseText);
			} else if(s == null) {
				me.req = null;
				me.onError("Failed to connect or resolve host");
			} else {
				switch(s) {
				case 12007:
					me.req = null;
					me.onError("Unknown host");
					break;
				case 12029:
					me.req = null;
					me.onError("Failed to connect to host");
					break;
				default:
					me.req = null;
					me.responseData = r.responseText;
					me.onError("Http Error #" + r.status);
				}
			}
		};
		if(this.async) {
			r.onreadystatechange = onreadystatechange;
		}
		var uri = this.postData;
		if(uri != null) {
			post = true;
		} else {
			var _g_head = this.params.h;
			while(_g_head != null) {
				var val = _g_head.item;
				_g_head = _g_head.next;
				var p = val;
				if(uri == null) {
					uri = "";
				} else {
					uri += "&";
				}
				var s1 = p.param;
				var uri1 = encodeURIComponent(s1) + "=";
				var s2 = p.value;
				uri += uri1 + encodeURIComponent(s2);
			}
		}
		try {
			if(post) {
				r.open("POST",this.url,this.async);
			} else if(uri != null) {
				var question = this.url.split("?").length <= 1;
				r.open("GET",this.url + (question ? "?" : "&") + uri,this.async);
				uri = null;
			} else {
				r.open("GET",this.url,this.async);
			}
		} catch( e1 ) {
			haxe_CallStack.lastException = e1;
			if (e1 instanceof js__$Boot_HaxeError) e1 = e1.val;
			me.req = null;
			this.onError(e1.toString());
			return;
		}
		r.withCredentials = this.withCredentials;
		if(!Lambda.exists(this.headers,function(h) {
			return h.header == "Content-Type";
		}) && post && this.postData == null) {
			r.setRequestHeader("Content-Type","application/x-www-form-urlencoded");
		}
		var _g_head1 = this.headers.h;
		while(_g_head1 != null) {
			var val1 = _g_head1.item;
			_g_head1 = _g_head1.next;
			var h1 = val1;
			r.setRequestHeader(h1.header,h1.value);
		}
		r.send(uri);
		if(!this.async) {
			onreadystatechange(null);
		}
	}
	,onData: function(data) {
	}
	,onError: function(msg) {
	}
	,onStatus: function(status) {
	}
	,__class__: haxe_Http
};
var haxe_Log = function() { };
$hxClasses["haxe.Log"] = haxe_Log;
haxe_Log.__name__ = ["haxe","Log"];
haxe_Log.trace = function(v,infos) {
	js_Boot.__trace(v,infos);
};
var haxe_Resource = function() { };
$hxClasses["haxe.Resource"] = haxe_Resource;
haxe_Resource.__name__ = ["haxe","Resource"];
haxe_Resource.getString = function(name) {
	var _g = 0;
	var _g1 = haxe_Resource.content;
	while(_g < _g1.length) {
		var x = _g1[_g];
		++_g;
		if(x.name == name) {
			if(x.str != null) {
				return x.str;
			}
			var b = haxe_crypto_Base64.decode(x.data);
			return b.toString();
		}
	}
	return null;
};
var haxe_Serializer = function() { };
$hxClasses["haxe.Serializer"] = haxe_Serializer;
haxe_Serializer.__name__ = ["haxe","Serializer"];
haxe_Serializer.prototype = {
	serializeString: function(s) {
		var _this = this.shash;
		var x = __map_reserved[s] != null ? _this.getReserved(s) : _this.h[s];
		if(x != null) {
			this.buf.b += "R";
			this.buf.b += x == null ? "null" : "" + x;
			return;
		}
		var _this1 = this.shash;
		var value = this.scount++;
		if(__map_reserved[s] != null) {
			_this1.setReserved(s,value);
		} else {
			_this1.h[s] = value;
		}
		this.buf.b += "y";
		s = encodeURIComponent(s);
		this.buf.b += Std.string(s.length);
		this.buf.b += ":";
		this.buf.b += s == null ? "null" : "" + s;
	}
	,serializeRef: function(v) {
		var vt = typeof(v);
		var _g1 = 0;
		var _g = this.cache.length;
		while(_g1 < _g) {
			var i = _g1++;
			var ci = this.cache[i];
			if(typeof(ci) == vt && ci == v) {
				this.buf.b += "r";
				this.buf.b += i == null ? "null" : "" + i;
				return true;
			}
		}
		this.cache.push(v);
		return false;
	}
	,serializeFields: function(v) {
		var _g = 0;
		var _g1 = Reflect.fields(v);
		while(_g < _g1.length) {
			var f = _g1[_g];
			++_g;
			this.serializeString(f);
			this.serialize(Reflect.field(v,f));
		}
		this.buf.b += "g";
	}
	,serialize: function(v) {
		var _g = Type["typeof"](v);
		switch(_g[1]) {
		case 0:
			this.buf.b += "n";
			break;
		case 1:
			var v1 = v;
			if(v1 == 0) {
				this.buf.b += "z";
				return;
			}
			this.buf.b += "i";
			this.buf.b += v1 == null ? "null" : "" + v1;
			break;
		case 2:
			var v2 = v;
			if(isNaN(v2)) {
				this.buf.b += "k";
			} else if(!isFinite(v2)) {
				this.buf.b += v2 < 0 ? "m" : "p";
			} else {
				this.buf.b += "d";
				this.buf.b += v2 == null ? "null" : "" + v2;
			}
			break;
		case 3:
			this.buf.b += v ? "t" : "f";
			break;
		case 4:
			if(js_Boot.__instanceof(v,Class)) {
				var className = Type.getClassName(v);
				this.buf.b += "A";
				this.serializeString(className);
			} else if(js_Boot.__instanceof(v,Enum)) {
				this.buf.b += "B";
				this.serializeString(Type.getEnumName(v));
			} else {
				if(this.useCache && this.serializeRef(v)) {
					return;
				}
				this.buf.b += "o";
				this.serializeFields(v);
			}
			break;
		case 5:
			throw new js__$Boot_HaxeError("Cannot serialize function");
			break;
		case 6:
			var c = _g[2];
			if(c == String) {
				this.serializeString(v);
				return;
			}
			if(this.useCache && this.serializeRef(v)) {
				return;
			}
			switch(c) {
			case Array:
				var ucount = 0;
				this.buf.b += "a";
				var l = v["length"];
				var _g1 = 0;
				var _g2 = l;
				while(_g1 < _g2) {
					var i = _g1++;
					if(v[i] == null) {
						++ucount;
					} else {
						if(ucount > 0) {
							if(ucount == 1) {
								this.buf.b += "n";
							} else {
								this.buf.b += "u";
								this.buf.b += ucount == null ? "null" : "" + ucount;
							}
							ucount = 0;
						}
						this.serialize(v[i]);
					}
				}
				if(ucount > 0) {
					if(ucount == 1) {
						this.buf.b += "n";
					} else {
						this.buf.b += "u";
						this.buf.b += ucount == null ? "null" : "" + ucount;
					}
				}
				this.buf.b += "h";
				break;
			case Date:
				var d = v;
				this.buf.b += "v";
				this.buf.b += Std.string(d.getTime());
				break;
			case List:
				this.buf.b += "l";
				var v3 = v;
				var _g_head = v3.h;
				while(_g_head != null) {
					var val = _g_head.item;
					_g_head = _g_head.next;
					var i1 = val;
					this.serialize(i1);
				}
				this.buf.b += "h";
				break;
			case haxe_ds_IntMap:
				this.buf.b += "q";
				var v4 = v;
				var k = v4.keys();
				while(k.hasNext()) {
					var k1 = k.next();
					this.buf.b += ":";
					this.buf.b += k1 == null ? "null" : "" + k1;
					this.serialize(v4.h[k1]);
				}
				this.buf.b += "h";
				break;
			case haxe_ds_ObjectMap:
				this.buf.b += "M";
				var v5 = v;
				var k2 = v5.keys();
				while(k2.hasNext()) {
					var k3 = k2.next();
					var id = Reflect.field(k3,"__id__");
					Reflect.deleteField(k3,"__id__");
					this.serialize(k3);
					k3["__id__"] = id;
					this.serialize(v5.h[k3.__id__]);
				}
				this.buf.b += "h";
				break;
			case haxe_ds_StringMap:
				this.buf.b += "b";
				var v6 = v;
				var k4 = v6.keys();
				while(k4.hasNext()) {
					var k5 = k4.next();
					this.serializeString(k5);
					this.serialize(__map_reserved[k5] != null ? v6.getReserved(k5) : v6.h[k5]);
				}
				this.buf.b += "h";
				break;
			case haxe_io_Bytes:
				var v7 = v;
				this.buf.b += "s";
				this.buf.b += Std.string(Math.ceil(v7.length * 8 / 6));
				this.buf.b += ":";
				var i2 = 0;
				var max = v7.length - 2;
				var b64 = haxe_Serializer.BASE64_CODES;
				if(b64 == null) {
					var length = haxe_Serializer.BASE64.length;
					var this1 = new Array(length);
					b64 = this1;
					var _g11 = 0;
					var _g3 = haxe_Serializer.BASE64.length;
					while(_g11 < _g3) {
						var i3 = _g11++;
						b64[i3] = HxOverrides.cca(haxe_Serializer.BASE64,i3);
					}
					haxe_Serializer.BASE64_CODES = b64;
				}
				while(i2 < max) {
					var b1 = v7.b[i2++];
					var b2 = v7.b[i2++];
					var b3 = v7.b[i2++];
					this.buf.b += String.fromCharCode(b64[b1 >> 2]);
					this.buf.b += String.fromCharCode(b64[(b1 << 4 | b2 >> 4) & 63]);
					this.buf.b += String.fromCharCode(b64[(b2 << 2 | b3 >> 6) & 63]);
					this.buf.b += String.fromCharCode(b64[b3 & 63]);
				}
				if(i2 == max) {
					var b11 = v7.b[i2++];
					var b21 = v7.b[i2++];
					this.buf.b += String.fromCharCode(b64[b11 >> 2]);
					this.buf.b += String.fromCharCode(b64[(b11 << 4 | b21 >> 4) & 63]);
					this.buf.b += String.fromCharCode(b64[b21 << 2 & 63]);
				} else if(i2 == max + 1) {
					var b12 = v7.b[i2++];
					this.buf.b += String.fromCharCode(b64[b12 >> 2]);
					this.buf.b += String.fromCharCode(b64[b12 << 4 & 63]);
				}
				break;
			default:
				if(this.useCache) {
					this.cache.pop();
				}
				if(v.hxSerialize != null) {
					this.buf.b += "C";
					this.serializeString(Type.getClassName(c));
					if(this.useCache) {
						this.cache.push(v);
					}
					v.hxSerialize(this);
					this.buf.b += "g";
				} else {
					this.buf.b += "c";
					this.serializeString(Type.getClassName(c));
					if(this.useCache) {
						this.cache.push(v);
					}
					this.serializeFields(v);
				}
			}
			break;
		case 7:
			var e = _g[2];
			if(this.useCache) {
				if(this.serializeRef(v)) {
					return;
				}
				this.cache.pop();
			}
			this.buf.b += Std.string(this.useEnumIndex ? "j" : "w");
			this.serializeString(Type.getEnumName(e));
			if(this.useEnumIndex) {
				this.buf.b += ":";
				this.buf.b += Std.string(v[1]);
			} else {
				this.serializeString(v[0]);
			}
			this.buf.b += ":";
			var l1 = v["length"];
			this.buf.b += Std.string(l1 - 2);
			var _g12 = 2;
			var _g4 = l1;
			while(_g12 < _g4) {
				var i4 = _g12++;
				this.serialize(v[i4]);
			}
			if(this.useCache) {
				this.cache.push(v);
			}
			break;
		default:
			throw new js__$Boot_HaxeError("Cannot serialize " + Std.string(v));
		}
	}
	,__class__: haxe_Serializer
};
var haxe_Timer = function(time_ms) {
	var me = this;
	this.id = setInterval(function() {
		me.run();
	},time_ms);
};
$hxClasses["haxe.Timer"] = haxe_Timer;
haxe_Timer.__name__ = ["haxe","Timer"];
haxe_Timer.delay = function(f,time_ms) {
	var t = new haxe_Timer(time_ms);
	t.run = function() {
		t.stop();
		f();
	};
	return t;
};
haxe_Timer.prototype = {
	stop: function() {
		if(this.id == null) {
			return;
		}
		clearInterval(this.id);
		this.id = null;
	}
	,run: function() {
	}
	,__class__: haxe_Timer
};
var haxe__$Unserializer_DefaultResolver = function() {
};
$hxClasses["haxe._Unserializer.DefaultResolver"] = haxe__$Unserializer_DefaultResolver;
haxe__$Unserializer_DefaultResolver.__name__ = ["haxe","_Unserializer","DefaultResolver"];
haxe__$Unserializer_DefaultResolver.prototype = {
	resolveClass: function(name) {
		return Type.resolveClass(name);
	}
	,resolveEnum: function(name) {
		return Type.resolveEnum(name);
	}
	,__class__: haxe__$Unserializer_DefaultResolver
};
var haxe_Unserializer = function(buf) {
	this.buf = buf;
	this.length = buf.length;
	this.pos = 0;
	this.scache = [];
	this.cache = [];
	var r = haxe_Unserializer.DEFAULT_RESOLVER;
	if(r == null) {
		r = new haxe__$Unserializer_DefaultResolver();
		haxe_Unserializer.DEFAULT_RESOLVER = r;
	}
	this.resolver = r;
};
$hxClasses["haxe.Unserializer"] = haxe_Unserializer;
haxe_Unserializer.__name__ = ["haxe","Unserializer"];
haxe_Unserializer.initCodes = function() {
	var codes = [];
	var _g1 = 0;
	var _g = haxe_Unserializer.BASE64.length;
	while(_g1 < _g) {
		var i = _g1++;
		codes[haxe_Unserializer.BASE64.charCodeAt(i)] = i;
	}
	return codes;
};
haxe_Unserializer.run = function(v) {
	return new haxe_Unserializer(v).unserialize();
};
haxe_Unserializer.prototype = {
	readDigits: function() {
		var k = 0;
		var s = false;
		var fpos = this.pos;
		while(true) {
			var c = this.buf.charCodeAt(this.pos);
			if(c != c) {
				break;
			}
			if(c == 45) {
				if(this.pos != fpos) {
					break;
				}
				s = true;
				this.pos++;
				continue;
			}
			if(c < 48 || c > 57) {
				break;
			}
			k = k * 10 + (c - 48);
			this.pos++;
		}
		if(s) {
			k *= -1;
		}
		return k;
	}
	,readFloat: function() {
		var p1 = this.pos;
		while(true) {
			var c = this.buf.charCodeAt(this.pos);
			if(c != c) {
				break;
			}
			if(c >= 43 && c < 58 || c == 101 || c == 69) {
				this.pos++;
			} else {
				break;
			}
		}
		return parseFloat(HxOverrides.substr(this.buf,p1,this.pos - p1));
	}
	,unserializeObject: function(o) {
		while(true) {
			if(this.pos >= this.length) {
				throw new js__$Boot_HaxeError("Invalid object");
			}
			if(this.buf.charCodeAt(this.pos) == 103) {
				break;
			}
			var k = this.unserialize();
			if(typeof(k) != "string") {
				throw new js__$Boot_HaxeError("Invalid object key");
			}
			var v = this.unserialize();
			o[k] = v;
		}
		this.pos++;
	}
	,unserializeEnum: function(edecl,tag) {
		if(this.buf.charCodeAt(this.pos++) != 58) {
			throw new js__$Boot_HaxeError("Invalid enum format");
		}
		var nargs = this.readDigits();
		if(nargs == 0) {
			return Type.createEnum(edecl,tag);
		}
		var args = [];
		while(nargs-- > 0) args.push(this.unserialize());
		return Type.createEnum(edecl,tag,args);
	}
	,unserialize: function() {
		var _g = this.buf.charCodeAt(this.pos++);
		switch(_g) {
		case 65:
			var name = this.unserialize();
			var cl = this.resolver.resolveClass(name);
			if(cl == null) {
				throw new js__$Boot_HaxeError("Class not found " + name);
			}
			return cl;
		case 66:
			var name1 = this.unserialize();
			var e = this.resolver.resolveEnum(name1);
			if(e == null) {
				throw new js__$Boot_HaxeError("Enum not found " + name1);
			}
			return e;
		case 67:
			var name2 = this.unserialize();
			var cl1 = this.resolver.resolveClass(name2);
			if(cl1 == null) {
				throw new js__$Boot_HaxeError("Class not found " + name2);
			}
			var o = Type.createEmptyInstance(cl1);
			this.cache.push(o);
			o.hxUnserialize(this);
			if(this.buf.charCodeAt(this.pos++) != 103) {
				throw new js__$Boot_HaxeError("Invalid custom data");
			}
			return o;
		case 77:
			var h = new haxe_ds_ObjectMap();
			this.cache.push(h);
			var buf = this.buf;
			while(this.buf.charCodeAt(this.pos) != 104) {
				var s = this.unserialize();
				h.set(s,this.unserialize());
			}
			this.pos++;
			return h;
		case 82:
			var n = this.readDigits();
			if(n < 0 || n >= this.scache.length) {
				throw new js__$Boot_HaxeError("Invalid string reference");
			}
			return this.scache[n];
		case 97:
			var buf1 = this.buf;
			var a = [];
			this.cache.push(a);
			while(true) {
				var c = this.buf.charCodeAt(this.pos);
				if(c == 104) {
					this.pos++;
					break;
				}
				if(c == 117) {
					this.pos++;
					var n1 = this.readDigits();
					a[a.length + n1 - 1] = null;
				} else {
					a.push(this.unserialize());
				}
			}
			return a;
		case 98:
			var h1 = new haxe_ds_StringMap();
			this.cache.push(h1);
			var buf2 = this.buf;
			while(this.buf.charCodeAt(this.pos) != 104) {
				var s1 = this.unserialize();
				var value = this.unserialize();
				if(__map_reserved[s1] != null) {
					h1.setReserved(s1,value);
				} else {
					h1.h[s1] = value;
				}
			}
			this.pos++;
			return h1;
		case 99:
			var name3 = this.unserialize();
			var cl2 = this.resolver.resolveClass(name3);
			if(cl2 == null) {
				throw new js__$Boot_HaxeError("Class not found " + name3);
			}
			var o1 = Type.createEmptyInstance(cl2);
			this.cache.push(o1);
			this.unserializeObject(o1);
			return o1;
		case 100:
			return this.readFloat();
		case 102:
			return false;
		case 105:
			return this.readDigits();
		case 106:
			var name4 = this.unserialize();
			var edecl = this.resolver.resolveEnum(name4);
			if(edecl == null) {
				throw new js__$Boot_HaxeError("Enum not found " + name4);
			}
			this.pos++;
			var index = this.readDigits();
			var tag = edecl.__constructs__.slice()[index];
			if(tag == null) {
				throw new js__$Boot_HaxeError("Unknown enum index " + name4 + "@" + index);
			}
			var e1 = this.unserializeEnum(edecl,tag);
			this.cache.push(e1);
			return e1;
		case 107:
			return NaN;
		case 108:
			var l = new List();
			this.cache.push(l);
			var buf3 = this.buf;
			while(this.buf.charCodeAt(this.pos) != 104) l.add(this.unserialize());
			this.pos++;
			return l;
		case 109:
			return -Infinity;
		case 110:
			return null;
		case 111:
			var o2 = { };
			this.cache.push(o2);
			this.unserializeObject(o2);
			return o2;
		case 112:
			return Infinity;
		case 113:
			var h2 = new haxe_ds_IntMap();
			this.cache.push(h2);
			var buf4 = this.buf;
			var c1 = this.buf.charCodeAt(this.pos++);
			while(c1 == 58) {
				var i = this.readDigits();
				var value1 = this.unserialize();
				h2.h[i] = value1;
				c1 = this.buf.charCodeAt(this.pos++);
			}
			if(c1 != 104) {
				throw new js__$Boot_HaxeError("Invalid IntMap format");
			}
			return h2;
		case 114:
			var n2 = this.readDigits();
			if(n2 < 0 || n2 >= this.cache.length) {
				throw new js__$Boot_HaxeError("Invalid reference");
			}
			return this.cache[n2];
		case 115:
			var len = this.readDigits();
			var buf5 = this.buf;
			if(this.buf.charCodeAt(this.pos++) != 58 || this.length - this.pos < len) {
				throw new js__$Boot_HaxeError("Invalid bytes length");
			}
			var codes = haxe_Unserializer.CODES;
			if(codes == null) {
				codes = haxe_Unserializer.initCodes();
				haxe_Unserializer.CODES = codes;
			}
			var i1 = this.pos;
			var rest = len & 3;
			var size = (len >> 2) * 3 + (rest >= 2 ? rest - 1 : 0);
			var max = i1 + (len - rest);
			var bytes = new haxe_io_Bytes(new ArrayBuffer(size));
			var bpos = 0;
			while(i1 < max) {
				var c11 = codes[buf5.charCodeAt(i1++)];
				var c2 = codes[buf5.charCodeAt(i1++)];
				bytes.b[bpos++] = (c11 << 2 | c2 >> 4) & 255;
				var c3 = codes[buf5.charCodeAt(i1++)];
				bytes.b[bpos++] = (c2 << 4 | c3 >> 2) & 255;
				var c4 = codes[buf5.charCodeAt(i1++)];
				bytes.b[bpos++] = (c3 << 6 | c4) & 255;
			}
			if(rest >= 2) {
				var c12 = codes[buf5.charCodeAt(i1++)];
				var c21 = codes[buf5.charCodeAt(i1++)];
				bytes.b[bpos++] = (c12 << 2 | c21 >> 4) & 255;
				if(rest == 3) {
					var c31 = codes[buf5.charCodeAt(i1++)];
					bytes.b[bpos++] = (c21 << 4 | c31 >> 2) & 255;
				}
			}
			this.pos += len;
			this.cache.push(bytes);
			return bytes;
		case 116:
			return true;
		case 118:
			var d;
			if(this.buf.charCodeAt(this.pos) >= 48 && this.buf.charCodeAt(this.pos) <= 57 && this.buf.charCodeAt(this.pos + 1) >= 48 && this.buf.charCodeAt(this.pos + 1) <= 57 && this.buf.charCodeAt(this.pos + 2) >= 48 && this.buf.charCodeAt(this.pos + 2) <= 57 && this.buf.charCodeAt(this.pos + 3) >= 48 && this.buf.charCodeAt(this.pos + 3) <= 57 && this.buf.charCodeAt(this.pos + 4) == 45) {
				d = HxOverrides.strDate(HxOverrides.substr(this.buf,this.pos,19));
				this.pos += 19;
			} else {
				var t = this.readFloat();
				d = new Date(t);
			}
			this.cache.push(d);
			return d;
		case 119:
			var name5 = this.unserialize();
			var edecl1 = this.resolver.resolveEnum(name5);
			if(edecl1 == null) {
				throw new js__$Boot_HaxeError("Enum not found " + name5);
			}
			var e2 = this.unserializeEnum(edecl1,this.unserialize());
			this.cache.push(e2);
			return e2;
		case 120:
			throw js__$Boot_HaxeError.wrap(this.unserialize());
			break;
		case 121:
			var len1 = this.readDigits();
			if(this.buf.charCodeAt(this.pos++) != 58 || this.length - this.pos < len1) {
				throw new js__$Boot_HaxeError("Invalid string length");
			}
			var s2 = HxOverrides.substr(this.buf,this.pos,len1);
			this.pos += len1;
			s2 = decodeURIComponent(s2.split("+").join(" "));
			this.scache.push(s2);
			return s2;
		case 122:
			return 0;
		default:
		}
		this.pos--;
		throw new js__$Boot_HaxeError("Invalid char " + this.buf.charAt(this.pos) + " at position " + this.pos);
	}
	,__class__: haxe_Unserializer
};
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
$hxClasses["haxe.io.Bytes"] = haxe_io_Bytes;
haxe_io_Bytes.__name__ = ["haxe","io","Bytes"];
haxe_io_Bytes.alloc = function(length) {
	return new haxe_io_Bytes(new ArrayBuffer(length));
};
haxe_io_Bytes.ofString = function(s) {
	var a = [];
	var i = 0;
	while(i < s.length) {
		var c = s.charCodeAt(i++);
		if(55296 <= c && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(i++) & 1023;
		}
		if(c <= 127) {
			a.push(c);
		} else if(c <= 2047) {
			a.push(192 | c >> 6);
			a.push(128 | c & 63);
		} else if(c <= 65535) {
			a.push(224 | c >> 12);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		} else {
			a.push(240 | c >> 18);
			a.push(128 | c >> 12 & 63);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		}
	}
	return new haxe_io_Bytes(new Uint8Array(a).buffer);
};
haxe_io_Bytes.ofData = function(b) {
	var hb = b.hxBytes;
	if(hb != null) {
		return hb;
	}
	return new haxe_io_Bytes(b);
};
haxe_io_Bytes.fastGet = function(b,pos) {
	return b.bytes[pos];
};
haxe_io_Bytes.prototype = {
	getString: function(pos,len) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		var s = "";
		var b = this.b;
		var fcc = String.fromCharCode;
		var i = pos;
		var max = pos + len;
		while(i < max) {
			var c = b[i++];
			if(c < 128) {
				if(c == 0) {
					break;
				}
				s += fcc(c);
			} else if(c < 224) {
				s += fcc((c & 63) << 6 | b[i++] & 127);
			} else if(c < 240) {
				var c2 = b[i++];
				s += fcc((c & 31) << 12 | (c2 & 127) << 6 | b[i++] & 127);
			} else {
				var c21 = b[i++];
				var c3 = b[i++];
				var u = (c & 15) << 18 | (c21 & 127) << 12 | (c3 & 127) << 6 | b[i++] & 127;
				s += fcc((u >> 10) + 55232);
				s += fcc(u & 1023 | 56320);
			}
		}
		return s;
	}
	,toString: function() {
		return this.getString(0,this.length);
	}
	,__class__: haxe_io_Bytes
};
var haxe_crypto_Base64 = function() { };
$hxClasses["haxe.crypto.Base64"] = haxe_crypto_Base64;
haxe_crypto_Base64.__name__ = ["haxe","crypto","Base64"];
haxe_crypto_Base64.decode = function(str,complement) {
	if(complement == null) {
		complement = true;
	}
	if(complement) {
		while(HxOverrides.cca(str,str.length - 1) == 61) str = HxOverrides.substr(str,0,-1);
	}
	return new haxe_crypto_BaseCode(haxe_crypto_Base64.BYTES).decodeBytes(haxe_io_Bytes.ofString(str));
};
var haxe_crypto_BaseCode = function(base) {
	var len = base.length;
	var nbits = 1;
	while(len > 1 << nbits) ++nbits;
	if(nbits > 8 || len != 1 << nbits) {
		throw new js__$Boot_HaxeError("BaseCode : base length must be a power of two.");
	}
	this.base = base;
	this.nbits = nbits;
};
$hxClasses["haxe.crypto.BaseCode"] = haxe_crypto_BaseCode;
haxe_crypto_BaseCode.__name__ = ["haxe","crypto","BaseCode"];
haxe_crypto_BaseCode.prototype = {
	initTable: function() {
		var tbl = [];
		var _g = 0;
		while(_g < 256) {
			var i = _g++;
			tbl[i] = -1;
		}
		var _g1 = 0;
		var _g2 = this.base.length;
		while(_g1 < _g2) {
			var i1 = _g1++;
			tbl[this.base.b[i1]] = i1;
		}
		this.tbl = tbl;
	}
	,decodeBytes: function(b) {
		var nbits = this.nbits;
		var base = this.base;
		if(this.tbl == null) {
			this.initTable();
		}
		var tbl = this.tbl;
		var size = b.length * nbits >> 3;
		var out = new haxe_io_Bytes(new ArrayBuffer(size));
		var buf = 0;
		var curbits = 0;
		var pin = 0;
		var pout = 0;
		while(pout < size) {
			while(curbits < 8) {
				curbits += nbits;
				buf <<= nbits;
				var i = tbl[b.b[pin++]];
				if(i == -1) {
					throw new js__$Boot_HaxeError("BaseCode : invalid encoded char");
				}
				buf |= i;
			}
			curbits -= 8;
			out.b[pout++] = buf >> curbits & 255 & 255;
		}
		return out;
	}
	,__class__: haxe_crypto_BaseCode
};
var haxe_ds_IntMap = function() {
	this.h = { };
};
$hxClasses["haxe.ds.IntMap"] = haxe_ds_IntMap;
haxe_ds_IntMap.__name__ = ["haxe","ds","IntMap"];
haxe_ds_IntMap.__interfaces__ = [haxe_IMap];
haxe_ds_IntMap.prototype = {
	keys: function() {
		var a = [];
		for( var key in this.h ) if(this.h.hasOwnProperty(key)) {
			a.push(key | 0);
		}
		return HxOverrides.iter(a);
	}
	,iterator: function() {
		return { ref : this.h, it : this.keys(), hasNext : function() {
			return this.it.hasNext();
		}, next : function() {
			var i = this.it.next();
			return this.ref[i];
		}};
	}
	,__class__: haxe_ds_IntMap
};
var haxe_ds_ObjectMap = function() {
	this.h = { __keys__ : { }};
};
$hxClasses["haxe.ds.ObjectMap"] = haxe_ds_ObjectMap;
haxe_ds_ObjectMap.__name__ = ["haxe","ds","ObjectMap"];
haxe_ds_ObjectMap.__interfaces__ = [haxe_IMap];
haxe_ds_ObjectMap.assignId = function(obj) {
	return obj.__id__ = ++haxe_ds_ObjectMap.count;
};
haxe_ds_ObjectMap.getId = function(obj) {
	return obj.__id__;
};
haxe_ds_ObjectMap.prototype = {
	set: function(key,value) {
		var id = key.__id__ || (key.__id__ = ++haxe_ds_ObjectMap.count);
		this.h[id] = value;
		this.h.__keys__[id] = key;
	}
	,keys: function() {
		var a = [];
		for( var key in this.h.__keys__ ) {
		if(this.h.hasOwnProperty(key)) {
			a.push(this.h.__keys__[key]);
		}
		}
		return HxOverrides.iter(a);
	}
	,__class__: haxe_ds_ObjectMap
};
var haxe_ds_StringMap = function() {
	this.h = { };
};
$hxClasses["haxe.ds.StringMap"] = haxe_ds_StringMap;
haxe_ds_StringMap.__name__ = ["haxe","ds","StringMap"];
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.prototype = {
	setReserved: function(key,value) {
		if(this.rh == null) {
			this.rh = { };
		}
		this.rh["$" + key] = value;
	}
	,getReserved: function(key) {
		if(this.rh == null) {
			return null;
		} else {
			return this.rh["$" + key];
		}
	}
	,existsReserved: function(key) {
		if(this.rh == null) {
			return false;
		}
		return this.rh.hasOwnProperty("$" + key);
	}
	,keys: function() {
		return HxOverrides.iter(this.arrayKeys());
	}
	,arrayKeys: function() {
		var out = [];
		for( var key in this.h ) {
		if(this.h.hasOwnProperty(key)) {
			out.push(key);
		}
		}
		if(this.rh != null) {
			for( var key in this.rh ) {
			if(key.charCodeAt(0) == 36) {
				out.push(key.substr(1));
			}
			}
		}
		return out;
	}
	,__class__: haxe_ds_StringMap
};
var haxe_io_Error = $hxClasses["haxe.io.Error"] = { __ename__ : ["haxe","io","Error"], __constructs__ : ["Blocked","Overflow","OutsideBounds","Custom"] };
haxe_io_Error.Blocked = ["Blocked",0];
haxe_io_Error.Blocked.toString = $estr;
haxe_io_Error.Blocked.__enum__ = haxe_io_Error;
haxe_io_Error.Overflow = ["Overflow",1];
haxe_io_Error.Overflow.toString = $estr;
haxe_io_Error.Overflow.__enum__ = haxe_io_Error;
haxe_io_Error.OutsideBounds = ["OutsideBounds",2];
haxe_io_Error.OutsideBounds.toString = $estr;
haxe_io_Error.OutsideBounds.__enum__ = haxe_io_Error;
haxe_io_Error.Custom = function(e) { var $x = ["Custom",3,e]; $x.__enum__ = haxe_io_Error; $x.toString = $estr; return $x; };
var haxe_rtti_Meta = function() { };
$hxClasses["haxe.rtti.Meta"] = haxe_rtti_Meta;
haxe_rtti_Meta.__name__ = ["haxe","rtti","Meta"];
haxe_rtti_Meta.getMeta = function(t) {
	return t.__meta__;
};
haxe_rtti_Meta.getFields = function(t) {
	var meta = haxe_rtti_Meta.getMeta(t);
	if(meta == null || meta.fields == null) {
		return { };
	} else {
		return meta.fields;
	}
};
var iodev_geom2_Vec = $hx_exports["iodev"]["geom2"]["Vec"] = function(x,y) {
	if(y == null) {
		y = 0.0;
	}
	if(x == null) {
		x = 0.0;
	}
	mcover_coverage_MCoverage.getLogger().logStatement(32);
	this.x = x;
	this.y = y;
};
$hxClasses["iodev.geom2.Vec"] = iodev_geom2_Vec;
iodev_geom2_Vec.__name__ = ["iodev","geom2","Vec"];
iodev_geom2_Vec.fromXY = function(x,y) {
	mcover_coverage_MCoverage.getLogger().logStatement(18);
	return new iodev_geom2_Vec(x,y);
};
iodev_geom2_Vec.fromPolar = function(radians,len) {
	if(len == null) {
		len = 1.0;
	}
	mcover_coverage_MCoverage.getLogger().logStatement(19);
	var x;
	var y;
	x = len * Math.cos(radians);
	y = len * Math.sin(radians);
	return new iodev_geom2_Vec(x,y);
};
iodev_geom2_Vec.fromAdd = function(a,b) {
	mcover_coverage_MCoverage.getLogger().logStatement(20);
	var x;
	var y;
	x = a.x + b.x;
	y = a.y + b.y;
	return new iodev_geom2_Vec(x,y);
};
iodev_geom2_Vec.fromSub = function(a,b) {
	mcover_coverage_MCoverage.getLogger().logStatement(21);
	var x;
	var y;
	x = a.x - b.x;
	y = a.y - b.y;
	return new iodev_geom2_Vec(x,y);
};
iodev_geom2_Vec.fromMul = function(a,b) {
	mcover_coverage_MCoverage.getLogger().logStatement(22);
	var x;
	var y;
	x = a.x * b.x;
	y = a.y * b.y;
	return new iodev_geom2_Vec(x,y);
};
iodev_geom2_Vec.fromDiv = function(a,b) {
	mcover_coverage_MCoverage.getLogger().logStatement(23);
	var x;
	var y;
	x = a.x / b.x;
	y = a.y / b.y;
	return new iodev_geom2_Vec(x,y);
};
iodev_geom2_Vec.normalBisectorFrom = function(a,b) {
	mcover_coverage_MCoverage.getLogger().logStatement(24);
	var x;
	var y;
	var normAX;
	var normAY;
	var normBX;
	var normBY;
	var sumX;
	var sumY;
	var m = 1.0 / Math.sqrt(a.x * a.x + a.y * a.y);
	normAX = m * a.x;
	normAY = m * a.y;
	var m1 = 1.0 / Math.sqrt(b.x * b.x + b.y * b.y);
	normBX = m1 * b.x;
	normBY = m1 * b.y;
	sumX = normAX + normBX;
	sumY = normAY + normBY;
	var m2 = 1.0 / Math.sqrt(sumX * sumX + sumY * sumY);
	x = m2 * sumX;
	y = m2 * sumY;
	return new iodev_geom2_Vec(x,y);
};
iodev_geom2_Vec.equals = function(a,b) {
	mcover_coverage_MCoverage.getLogger().logStatement(25);
	if(a.x == b.x) {
		return a.y == b.y;
	} else {
		return false;
	}
};
iodev_geom2_Vec.dotProd = function(a,b) {
	mcover_coverage_MCoverage.getLogger().logStatement(26);
	return a.x * b.x + a.y * b.y;
};
iodev_geom2_Vec.skewProd = function(a,b) {
	mcover_coverage_MCoverage.getLogger().logStatement(27);
	return a.x * b.y - a.y * b.x;
};
iodev_geom2_Vec.lengthBetween = function(a,b) {
	mcover_coverage_MCoverage.getLogger().logStatement(28);
	var vX = b.x - a.x;
	var vY = b.y - a.y;
	return Math.sqrt(vX * vX + vY * vY);
};
iodev_geom2_Vec.magnitudeBetween = function(a,b) {
	mcover_coverage_MCoverage.getLogger().logStatement(29);
	var vX = b.x - a.x;
	var vY = b.y - a.y;
	return vX * vX + vY * vY;
};
iodev_geom2_Vec.radiansBetween = function(a,b) {
	mcover_coverage_MCoverage.getLogger().logStatement(30);
	var normAX;
	var normAY;
	var normBX;
	var normBY;
	var m = 1.0 / Math.sqrt(a.x * a.x + a.y * a.y);
	normAX = m * a.x;
	normAY = m * a.y;
	var m1 = 1.0 / Math.sqrt(b.x * b.x + b.y * b.y);
	normBX = m1 * b.x;
	normBY = m1 * b.y;
	return Math.acos(normAX * normBX + normAY * normBY);
};
iodev_geom2_Vec.radiansBetweenNormals = function(a,b) {
	mcover_coverage_MCoverage.getLogger().logStatement(31);
	return Math.acos(a.x * b.x + a.y * b.y);
};
iodev_geom2_Vec.prototype = {
	clone: function() {
		mcover_coverage_MCoverage.getLogger().logStatement(33);
		return new iodev_geom2_Vec(this.x,this.y);
	}
	,length: function() {
		mcover_coverage_MCoverage.getLogger().logStatement(34);
		return Math.sqrt(this.x * this.x + this.y * this.y);
	}
	,magnitude: function() {
		mcover_coverage_MCoverage.getLogger().logStatement(35);
		return this.x * this.x + this.y * this.y;
	}
	,normalize: function(len) {
		if(len == null) {
			len = 1.0;
		}
		mcover_coverage_MCoverage.getLogger().logStatement(36);
		var m = len / Math.sqrt(this.x * this.x + this.y * this.y);
		this.x = m * this.x;
		this.y = m * this.y;
	}
	,toRadians: function() {
		mcover_coverage_MCoverage.getLogger().logStatement(37);
		return Math.atan2(this.y,this.x);
	}
	,toString: function() {
		mcover_coverage_MCoverage.getLogger().logStatement(38);
		return "[object Vec2(" + this.x + "; " + this.y + ")]";
	}
	,__class__: iodev_geom2_Vec
};
var iodev_geom2_VecBuilder = $hx_exports["iodev"]["geom2"]["VecBuilder"] = function(x,y) {
	if(y == null) {
		y = 0.0;
	}
	if(x == null) {
		x = 0.0;
	}
	this._y = 0.0;
	this._x = 0.0;
	mcover_coverage_MCoverage.getLogger().logStatement(87);
	this._x = x;
	this._y = y;
};
$hxClasses["iodev.geom2.VecBuilder"] = iodev_geom2_VecBuilder;
iodev_geom2_VecBuilder.__name__ = ["iodev","geom2","VecBuilder"];
iodev_geom2_VecBuilder.create = function() {
	mcover_coverage_MCoverage.getLogger().logStatement(83);
	return new iodev_geom2_VecBuilder();
};
iodev_geom2_VecBuilder.fromXY = function(x,y) {
	if(y == null) {
		y = 0.0;
	}
	if(x == null) {
		x = 0.0;
	}
	mcover_coverage_MCoverage.getLogger().logStatement(84);
	return new iodev_geom2_VecBuilder(x,y);
};
iodev_geom2_VecBuilder.fromVec = function(v) {
	mcover_coverage_MCoverage.getLogger().logStatement(85);
	return new iodev_geom2_VecBuilder(v.x,v.y);
};
iodev_geom2_VecBuilder.fromPolar = function(radians,len) {
	if(len == null) {
		len = 1.0;
	}
	mcover_coverage_MCoverage.getLogger().logStatement(86);
	var x;
	var y;
	x = len * Math.cos(radians);
	y = len * Math.sin(radians);
	return new iodev_geom2_VecBuilder(x,y);
};
iodev_geom2_VecBuilder.prototype = {
	setX: function(x) {
		mcover_coverage_MCoverage.getLogger().logStatement(88);
		this._x = x;
		return this;
	}
	,setY: function(y) {
		mcover_coverage_MCoverage.getLogger().logStatement(89);
		this._y = y;
		return this;
	}
	,setXY: function(x,y) {
		mcover_coverage_MCoverage.getLogger().logStatement(90);
		this._x = x;
		this._y = y;
		return this;
	}
	,setPolar: function(radians,len) {
		if(len == null) {
			len = 1.0;
		}
		mcover_coverage_MCoverage.getLogger().logStatement(91);
		this._x = len * Math.cos(radians);
		this._y = len * Math.sin(radians);
		return this;
	}
	,negate: function() {
		mcover_coverage_MCoverage.getLogger().logStatement(92);
		this._x = -this._x;
		this._y = -this._y;
		return this;
	}
	,swapXY: function() {
		mcover_coverage_MCoverage.getLogger().logStatement(93);
		var t = this._x;
		this._x = this._y;
		this._y = t;
		return this;
	}
	,normalize: function(len) {
		if(len == null) {
			len = 1.0;
		}
		mcover_coverage_MCoverage.getLogger().logStatement(94);
		var m = len / Math.sqrt(this._x * this._x + this._y * this._y);
		this._x = m * this._x;
		this._y = m * this._y;
		return this;
	}
	,add: function(v) {
		mcover_coverage_MCoverage.getLogger().logStatement(95);
		this._x += v.x;
		this._y += v.y;
		return this;
	}
	,addXY: function(x,y) {
		mcover_coverage_MCoverage.getLogger().logStatement(96);
		this._x += x;
		this._y += y;
		return this;
	}
	,subtract: function(v) {
		mcover_coverage_MCoverage.getLogger().logStatement(97);
		this._x -= v.x;
		this._y -= v.y;
		return this;
	}
	,subtractXY: function(x,y) {
		mcover_coverage_MCoverage.getLogger().logStatement(98);
		this._x -= x;
		this._y -= y;
		return this;
	}
	,multiply: function(v) {
		mcover_coverage_MCoverage.getLogger().logStatement(99);
		this._x *= v.x;
		this._y *= v.y;
		return this;
	}
	,multiplyXY: function(x,y) {
		mcover_coverage_MCoverage.getLogger().logStatement(100);
		this._x *= x;
		this._y *= y;
		return this;
	}
	,divide: function(v) {
		mcover_coverage_MCoverage.getLogger().logStatement(101);
		this._x /= v.x;
		this._y /= v.y;
		return this;
	}
	,divideXY: function(x,y) {
		mcover_coverage_MCoverage.getLogger().logStatement(102);
		this._x /= x;
		this._y /= y;
		return this;
	}
	,rotate: function(radians) {
		mcover_coverage_MCoverage.getLogger().logStatement(103);
		var sn = Math.sin(radians);
		var cs = Math.cos(radians);
		var sx = this._x;
		this._x = sx * cs - this._y * sn;
		this._y = sx * sn + this._y * cs;
		return this;
	}
	,rotateQuart: function(times) {
		mcover_coverage_MCoverage.getLogger().logStatement(104);
		var n = (4 + times % 4) % 4;
		var sn = (2 - n) % 2;
		var cs = (1 - n) % 2;
		var sx = this._x;
		this._x = sx * cs - this._y * sn;
		this._y = sx * sn + this._y * cs;
		return this;
	}
	,mirrorBy: function(v) {
		mcover_coverage_MCoverage.getLogger().logStatement(105);
		var nx;
		var ny;
		var m = 1.0 / Math.sqrt(v.x * v.x + v.y * v.y);
		nx = m * v.x;
		ny = m * v.y;
		var rx = ny;
		var ry = -nx;
		var m1 = -2.0 * (this._x * rx + this._y * ry);
		this._x += m1 * rx;
		this._y += m1 * ry;
		return this;
	}
	,mirrorByXY: function(x,y) {
		mcover_coverage_MCoverage.getLogger().logStatement(106);
		var nx;
		var ny;
		var m = 1.0 / Math.sqrt(x * x + y * y);
		nx = m * x;
		ny = m * y;
		var rx = ny;
		var ry = -nx;
		var m1 = -2.0 * (this._x * rx + this._y * ry);
		this._x += m1 * rx;
		this._y += m1 * ry;
		return this;
	}
	,mirrorByNormal: function(v) {
		mcover_coverage_MCoverage.getLogger().logStatement(107);
		var rx = v.y;
		var ry = -v.x;
		var m = -2.0 * (this._x * rx + this._y * ry);
		this._x += m * rx;
		this._y += m * ry;
		return this;
	}
	,mirrorByNormalXY: function(x,y) {
		mcover_coverage_MCoverage.getLogger().logStatement(108);
		var rx = y;
		var ry = -x;
		var m = -2.0 * (this._x * rx + this._y * ry);
		this._x += m * rx;
		this._y += m * ry;
		return this;
	}
	,toVec: function() {
		mcover_coverage_MCoverage.getLogger().logStatement(109);
		return new iodev_geom2_Vec(this._x,this._y);
	}
	,toVecSpecified: function(dst) {
		mcover_coverage_MCoverage.getLogger().logStatement(110);
		dst.x = this._x;
		dst.y = this._y;
		return dst;
	}
	,toX: function() {
		mcover_coverage_MCoverage.getLogger().logStatement(111);
		return this._x;
	}
	,toY: function() {
		mcover_coverage_MCoverage.getLogger().logStatement(112);
		return this._y;
	}
	,toLength: function() {
		mcover_coverage_MCoverage.getLogger().logStatement(113);
		return Math.sqrt(this._x * this._x + this._y * this._y);
	}
	,toMagnitude: function() {
		mcover_coverage_MCoverage.getLogger().logStatement(114);
		return this._x * this._x + this._y * this._y;
	}
	,toRadians: function() {
		mcover_coverage_MCoverage.getLogger().logStatement(115);
		return Math.atan2(this._y,this._x);
	}
	,__class__: iodev_geom2_VecBuilder
};
var iodev_geom2_VecBuilderTest = function() { };
$hxClasses["iodev.geom2.VecBuilderTest"] = iodev_geom2_VecBuilderTest;
iodev_geom2_VecBuilderTest.__name__ = ["iodev","geom2","VecBuilderTest"];
iodev_geom2_VecBuilderTest.prototype = {
	testCreate: function() {
		var b = iodev_geom2_VecBuilder.create();
		massive_munit_Assert.isType(b,iodev_geom2_VecBuilder,{ fileName : "VecBuilderTest.hx", lineNumber : 14, className : "iodev.geom2.VecBuilderTest", methodName : "testCreate"});
	}
	,testFromXY: function() {
		var x = Math.random();
		var y = Math.random();
		var b = iodev_geom2_VecBuilder.fromXY(x,y);
		massive_munit_Assert.isType(b,iodev_geom2_VecBuilder,{ fileName : "VecBuilderTest.hx", lineNumber : 24, className : "iodev.geom2.VecBuilderTest", methodName : "testFromXY"});
		MathAssert.floatEqual(x,b.toX(),{ fileName : "VecBuilderTest.hx", lineNumber : 25, className : "iodev.geom2.VecBuilderTest", methodName : "testFromXY"});
		MathAssert.floatEqual(y,b.toY(),{ fileName : "VecBuilderTest.hx", lineNumber : 26, className : "iodev.geom2.VecBuilderTest", methodName : "testFromXY"});
	}
	,testFromVec: function() {
		var x = Math.random();
		var y = Math.random();
		var b = iodev_geom2_VecBuilder.fromVec(new iodev_geom2_Vec(x,y));
		massive_munit_Assert.isType(b,iodev_geom2_VecBuilder,{ fileName : "VecBuilderTest.hx", lineNumber : 36, className : "iodev.geom2.VecBuilderTest", methodName : "testFromVec"});
		MathAssert.floatEqual(x,b.toX(),{ fileName : "VecBuilderTest.hx", lineNumber : 37, className : "iodev.geom2.VecBuilderTest", methodName : "testFromVec"});
		MathAssert.floatEqual(y,b.toY(),{ fileName : "VecBuilderTest.hx", lineNumber : 38, className : "iodev.geom2.VecBuilderTest", methodName : "testFromVec"});
	}
	,testFromPolar: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forPolar();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecBuilderTest.hx", lineNumber : 45, className : "iodev.geom2.VecBuilderTest", methodName : "testFromPolar"});
			var b = iodev_geom2_VecBuilder.fromPolar(data1.radians,data1.len);
			massive_munit_Assert.isType(b,iodev_geom2_VecBuilder,{ fileName : "VecBuilderTest.hx", lineNumber : 49, className : "iodev.geom2.VecBuilderTest", methodName : "testFromPolar"});
			MathAssert.floatEqual(data1.dstx,b.toX(),{ fileName : "VecBuilderTest.hx", lineNumber : 50, className : "iodev.geom2.VecBuilderTest", methodName : "testFromPolar"});
			MathAssert.floatEqual(data1.dsty,b.toY(),{ fileName : "VecBuilderTest.hx", lineNumber : 51, className : "iodev.geom2.VecBuilderTest", methodName : "testFromPolar"});
		}
	}
	,testConstructorDefaults: function() {
		var b = new iodev_geom2_VecBuilder();
		MathAssert.floatEqual(0.0,b.toX(),{ fileName : "VecBuilderTest.hx", lineNumber : 64, className : "iodev.geom2.VecBuilderTest", methodName : "testConstructorDefaults"});
		MathAssert.floatEqual(0.0,b.toY(),{ fileName : "VecBuilderTest.hx", lineNumber : 65, className : "iodev.geom2.VecBuilderTest", methodName : "testConstructorDefaults"});
	}
	,testConstructorParams: function() {
		var x = 1000000 * (0.5 - Math.random());
		var y = 1000000 * (0.5 - Math.random());
		var b = new iodev_geom2_VecBuilder(x,y);
		MathAssert.floatEqual(x,b.toX(),{ fileName : "VecBuilderTest.hx", lineNumber : 75, className : "iodev.geom2.VecBuilderTest", methodName : "testConstructorParams"});
		MathAssert.floatEqual(y,b.toY(),{ fileName : "VecBuilderTest.hx", lineNumber : 76, className : "iodev.geom2.VecBuilderTest", methodName : "testConstructorParams"});
	}
	,testSetX: function() {
		var x = Math.random();
		var b = iodev_geom2_VecBuilder.create();
		var res = b.setX(x);
		massive_munit_Assert.areEqual(b,res,{ fileName : "VecBuilderTest.hx", lineNumber : 86, className : "iodev.geom2.VecBuilderTest", methodName : "testSetX"});
		MathAssert.floatEqual(x,b.toX(),{ fileName : "VecBuilderTest.hx", lineNumber : 87, className : "iodev.geom2.VecBuilderTest", methodName : "testSetX"});
	}
	,testSetY: function() {
		var y = Math.random();
		var b = iodev_geom2_VecBuilder.create();
		var res = b.setY(y);
		massive_munit_Assert.areEqual(b,res,{ fileName : "VecBuilderTest.hx", lineNumber : 97, className : "iodev.geom2.VecBuilderTest", methodName : "testSetY"});
		MathAssert.floatEqual(y,b.toY(),{ fileName : "VecBuilderTest.hx", lineNumber : 98, className : "iodev.geom2.VecBuilderTest", methodName : "testSetY"});
	}
	,testSetXY: function() {
		var x = Math.random();
		var y = Math.random();
		var b = iodev_geom2_VecBuilder.create();
		var res = b.setXY(x,y);
		massive_munit_Assert.areEqual(b,res,{ fileName : "VecBuilderTest.hx", lineNumber : 109, className : "iodev.geom2.VecBuilderTest", methodName : "testSetXY"});
		MathAssert.floatEqual(x,b.toX(),{ fileName : "VecBuilderTest.hx", lineNumber : 110, className : "iodev.geom2.VecBuilderTest", methodName : "testSetXY"});
		MathAssert.floatEqual(y,b.toY(),{ fileName : "VecBuilderTest.hx", lineNumber : 111, className : "iodev.geom2.VecBuilderTest", methodName : "testSetXY"});
	}
	,testSetPolar: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forPolar();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecBuilderTest.hx", lineNumber : 118, className : "iodev.geom2.VecBuilderTest", methodName : "testSetPolar"});
			var b = iodev_geom2_VecBuilder.create();
			var res = b.setPolar(data1.radians,data1.len);
			massive_munit_Assert.areEqual(b,res,{ fileName : "VecBuilderTest.hx", lineNumber : 123, className : "iodev.geom2.VecBuilderTest", methodName : "testSetPolar"});
			MathAssert.floatEqual(data1.dstx,b.toX(),{ fileName : "VecBuilderTest.hx", lineNumber : 124, className : "iodev.geom2.VecBuilderTest", methodName : "testSetPolar"});
			MathAssert.floatEqual(data1.dsty,b.toY(),{ fileName : "VecBuilderTest.hx", lineNumber : 125, className : "iodev.geom2.VecBuilderTest", methodName : "testSetPolar"});
		}
	}
	,testNegate: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forNegate();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecBuilderTest.hx", lineNumber : 133, className : "iodev.geom2.VecBuilderTest", methodName : "testNegate"});
			var b = iodev_geom2_VecBuilder.fromXY(data1.ax,data1.ay);
			var res = b.negate();
			massive_munit_Assert.areEqual(b,res,{ fileName : "VecBuilderTest.hx", lineNumber : 138, className : "iodev.geom2.VecBuilderTest", methodName : "testNegate"});
			MathAssert.floatEqual(data1.dstx,b.toX(),{ fileName : "VecBuilderTest.hx", lineNumber : 139, className : "iodev.geom2.VecBuilderTest", methodName : "testNegate"});
			MathAssert.floatEqual(data1.dsty,b.toY(),{ fileName : "VecBuilderTest.hx", lineNumber : 140, className : "iodev.geom2.VecBuilderTest", methodName : "testNegate"});
		}
	}
	,testSwapXY: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forSwapXY();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecBuilderTest.hx", lineNumber : 148, className : "iodev.geom2.VecBuilderTest", methodName : "testSwapXY"});
			var b = iodev_geom2_VecBuilder.fromXY(data1.ax,data1.ay);
			var res = b.swapXY();
			massive_munit_Assert.areEqual(b,res,{ fileName : "VecBuilderTest.hx", lineNumber : 153, className : "iodev.geom2.VecBuilderTest", methodName : "testSwapXY"});
			MathAssert.floatEqual(data1.dstx,b.toX(),{ fileName : "VecBuilderTest.hx", lineNumber : 154, className : "iodev.geom2.VecBuilderTest", methodName : "testSwapXY"});
			MathAssert.floatEqual(data1.dsty,b.toY(),{ fileName : "VecBuilderTest.hx", lineNumber : 155, className : "iodev.geom2.VecBuilderTest", methodName : "testSwapXY"});
		}
	}
	,testNormalize: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forNormalize();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecBuilderTest.hx", lineNumber : 163, className : "iodev.geom2.VecBuilderTest", methodName : "testNormalize"});
			var b = iodev_geom2_VecBuilder.fromXY(data1.x,data1.y);
			var res = b.normalize(data1.nlen);
			massive_munit_Assert.areEqual(b,res,{ fileName : "VecBuilderTest.hx", lineNumber : 168, className : "iodev.geom2.VecBuilderTest", methodName : "testNormalize"});
			MathAssert.floatEqual(data1.nx,b.toX(),{ fileName : "VecBuilderTest.hx", lineNumber : 169, className : "iodev.geom2.VecBuilderTest", methodName : "testNormalize"});
			MathAssert.floatEqual(data1.ny,b.toY(),{ fileName : "VecBuilderTest.hx", lineNumber : 170, className : "iodev.geom2.VecBuilderTest", methodName : "testNormalize"});
		}
	}
	,testAdd: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forAdd();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecBuilderTest.hx", lineNumber : 178, className : "iodev.geom2.VecBuilderTest", methodName : "testAdd"});
			var b = iodev_geom2_VecBuilder.fromXY(data1.ax,data1.ay);
			var res = b.add(iodev_geom2_Vec.fromXY(data1.bx,data1.by));
			massive_munit_Assert.areEqual(b,res,{ fileName : "VecBuilderTest.hx", lineNumber : 183, className : "iodev.geom2.VecBuilderTest", methodName : "testAdd"});
			MathAssert.floatEqual(data1.dstx,b.toX(),{ fileName : "VecBuilderTest.hx", lineNumber : 184, className : "iodev.geom2.VecBuilderTest", methodName : "testAdd"});
			MathAssert.floatEqual(data1.dsty,b.toY(),{ fileName : "VecBuilderTest.hx", lineNumber : 185, className : "iodev.geom2.VecBuilderTest", methodName : "testAdd"});
		}
	}
	,testAddXY: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forAdd();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecBuilderTest.hx", lineNumber : 193, className : "iodev.geom2.VecBuilderTest", methodName : "testAddXY"});
			var b = iodev_geom2_VecBuilder.fromXY(data1.ax,data1.ay);
			var res = b.addXY(data1.bx,data1.by);
			massive_munit_Assert.areEqual(b,res,{ fileName : "VecBuilderTest.hx", lineNumber : 198, className : "iodev.geom2.VecBuilderTest", methodName : "testAddXY"});
			MathAssert.floatEqual(data1.dstx,b.toX(),{ fileName : "VecBuilderTest.hx", lineNumber : 199, className : "iodev.geom2.VecBuilderTest", methodName : "testAddXY"});
			MathAssert.floatEqual(data1.dsty,b.toY(),{ fileName : "VecBuilderTest.hx", lineNumber : 200, className : "iodev.geom2.VecBuilderTest", methodName : "testAddXY"});
		}
	}
	,testSubtract: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forSub();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecBuilderTest.hx", lineNumber : 208, className : "iodev.geom2.VecBuilderTest", methodName : "testSubtract"});
			var b = iodev_geom2_VecBuilder.fromXY(data1.ax,data1.ay);
			var res = b.subtract(iodev_geom2_Vec.fromXY(data1.bx,data1.by));
			massive_munit_Assert.areEqual(b,res,{ fileName : "VecBuilderTest.hx", lineNumber : 213, className : "iodev.geom2.VecBuilderTest", methodName : "testSubtract"});
			MathAssert.floatEqual(data1.dstx,b.toX(),{ fileName : "VecBuilderTest.hx", lineNumber : 214, className : "iodev.geom2.VecBuilderTest", methodName : "testSubtract"});
			MathAssert.floatEqual(data1.dsty,b.toY(),{ fileName : "VecBuilderTest.hx", lineNumber : 215, className : "iodev.geom2.VecBuilderTest", methodName : "testSubtract"});
		}
	}
	,testSubtractXY: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forSub();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecBuilderTest.hx", lineNumber : 223, className : "iodev.geom2.VecBuilderTest", methodName : "testSubtractXY"});
			var b = iodev_geom2_VecBuilder.fromXY(data1.ax,data1.ay);
			var res = b.subtractXY(data1.bx,data1.by);
			massive_munit_Assert.areEqual(b,res,{ fileName : "VecBuilderTest.hx", lineNumber : 228, className : "iodev.geom2.VecBuilderTest", methodName : "testSubtractXY"});
			MathAssert.floatEqual(data1.dstx,b.toX(),{ fileName : "VecBuilderTest.hx", lineNumber : 229, className : "iodev.geom2.VecBuilderTest", methodName : "testSubtractXY"});
			MathAssert.floatEqual(data1.dsty,b.toY(),{ fileName : "VecBuilderTest.hx", lineNumber : 230, className : "iodev.geom2.VecBuilderTest", methodName : "testSubtractXY"});
		}
	}
	,testMultiply: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forMul();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecBuilderTest.hx", lineNumber : 238, className : "iodev.geom2.VecBuilderTest", methodName : "testMultiply"});
			var b = iodev_geom2_VecBuilder.fromXY(data1.ax,data1.ay);
			var res = b.multiply(iodev_geom2_Vec.fromXY(data1.bx,data1.by));
			massive_munit_Assert.areEqual(b,res,{ fileName : "VecBuilderTest.hx", lineNumber : 243, className : "iodev.geom2.VecBuilderTest", methodName : "testMultiply"});
			MathAssert.floatEqual(data1.dstx,b.toX(),{ fileName : "VecBuilderTest.hx", lineNumber : 244, className : "iodev.geom2.VecBuilderTest", methodName : "testMultiply"});
			MathAssert.floatEqual(data1.dsty,b.toY(),{ fileName : "VecBuilderTest.hx", lineNumber : 245, className : "iodev.geom2.VecBuilderTest", methodName : "testMultiply"});
		}
	}
	,testMultiplyXY: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forMul();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecBuilderTest.hx", lineNumber : 253, className : "iodev.geom2.VecBuilderTest", methodName : "testMultiplyXY"});
			var b = iodev_geom2_VecBuilder.fromXY(data1.ax,data1.ay);
			var res = b.multiplyXY(data1.bx,data1.by);
			massive_munit_Assert.areEqual(b,res,{ fileName : "VecBuilderTest.hx", lineNumber : 258, className : "iodev.geom2.VecBuilderTest", methodName : "testMultiplyXY"});
			MathAssert.floatEqual(data1.dstx,b.toX(),{ fileName : "VecBuilderTest.hx", lineNumber : 259, className : "iodev.geom2.VecBuilderTest", methodName : "testMultiplyXY"});
			MathAssert.floatEqual(data1.dsty,b.toY(),{ fileName : "VecBuilderTest.hx", lineNumber : 260, className : "iodev.geom2.VecBuilderTest", methodName : "testMultiplyXY"});
		}
	}
	,testDivide: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forDiv();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecBuilderTest.hx", lineNumber : 268, className : "iodev.geom2.VecBuilderTest", methodName : "testDivide"});
			var b = iodev_geom2_VecBuilder.fromXY(data1.ax,data1.ay);
			var res = b.divide(iodev_geom2_Vec.fromXY(data1.bx,data1.by));
			massive_munit_Assert.areEqual(b,res,{ fileName : "VecBuilderTest.hx", lineNumber : 273, className : "iodev.geom2.VecBuilderTest", methodName : "testDivide"});
			MathAssert.floatEqual(data1.dstx,b.toX(),{ fileName : "VecBuilderTest.hx", lineNumber : 274, className : "iodev.geom2.VecBuilderTest", methodName : "testDivide"});
			MathAssert.floatEqual(data1.dsty,b.toY(),{ fileName : "VecBuilderTest.hx", lineNumber : 275, className : "iodev.geom2.VecBuilderTest", methodName : "testDivide"});
		}
	}
	,testDivideXY: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forDiv();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecBuilderTest.hx", lineNumber : 283, className : "iodev.geom2.VecBuilderTest", methodName : "testDivideXY"});
			var b = iodev_geom2_VecBuilder.fromXY(data1.ax,data1.ay);
			var res = b.divideXY(data1.bx,data1.by);
			massive_munit_Assert.areEqual(b,res,{ fileName : "VecBuilderTest.hx", lineNumber : 288, className : "iodev.geom2.VecBuilderTest", methodName : "testDivideXY"});
			MathAssert.floatEqual(data1.dstx,b.toX(),{ fileName : "VecBuilderTest.hx", lineNumber : 289, className : "iodev.geom2.VecBuilderTest", methodName : "testDivideXY"});
			MathAssert.floatEqual(data1.dsty,b.toY(),{ fileName : "VecBuilderTest.hx", lineNumber : 290, className : "iodev.geom2.VecBuilderTest", methodName : "testDivideXY"});
		}
	}
	,testRotate: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forRotate();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecBuilderTest.hx", lineNumber : 298, className : "iodev.geom2.VecBuilderTest", methodName : "testRotate"});
			var b = iodev_geom2_VecBuilder.fromXY(data1.x,data1.y);
			var res = b.rotate(data1.rad);
			massive_munit_Assert.areEqual(b,res,{ fileName : "VecBuilderTest.hx", lineNumber : 303, className : "iodev.geom2.VecBuilderTest", methodName : "testRotate"});
			MathAssert.floatEqual(data1.dstx,b.toX(),{ fileName : "VecBuilderTest.hx", lineNumber : 304, className : "iodev.geom2.VecBuilderTest", methodName : "testRotate"});
			MathAssert.floatEqual(data1.dsty,b.toY(),{ fileName : "VecBuilderTest.hx", lineNumber : 305, className : "iodev.geom2.VecBuilderTest", methodName : "testRotate"});
		}
	}
	,testRotateQuart: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forRotateQuart();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecBuilderTest.hx", lineNumber : 313, className : "iodev.geom2.VecBuilderTest", methodName : "testRotateQuart"});
			var b = iodev_geom2_VecBuilder.fromXY(data1.x,data1.y);
			var res = b.rotateQuart(data1.times);
			massive_munit_Assert.areEqual(b,res,{ fileName : "VecBuilderTest.hx", lineNumber : 318, className : "iodev.geom2.VecBuilderTest", methodName : "testRotateQuart"});
			MathAssert.floatEqual(data1.dstx,b.toX(),{ fileName : "VecBuilderTest.hx", lineNumber : 319, className : "iodev.geom2.VecBuilderTest", methodName : "testRotateQuart"});
			MathAssert.floatEqual(data1.dsty,b.toY(),{ fileName : "VecBuilderTest.hx", lineNumber : 320, className : "iodev.geom2.VecBuilderTest", methodName : "testRotateQuart"});
		}
	}
	,testMirrorBy: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forMirrorBy();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecBuilderTest.hx", lineNumber : 328, className : "iodev.geom2.VecBuilderTest", methodName : "testMirrorBy"});
			var b = iodev_geom2_VecBuilder.fromXY(data1.vx,data1.vy);
			var res = b.mirrorBy(iodev_geom2_Vec.fromXY(data1.dirx,data1.diry));
			massive_munit_Assert.areEqual(b,res,{ fileName : "VecBuilderTest.hx", lineNumber : 333, className : "iodev.geom2.VecBuilderTest", methodName : "testMirrorBy"});
			MathAssert.floatEqual(data1.dstx,b.toX(),{ fileName : "VecBuilderTest.hx", lineNumber : 334, className : "iodev.geom2.VecBuilderTest", methodName : "testMirrorBy"});
			MathAssert.floatEqual(data1.dsty,b.toY(),{ fileName : "VecBuilderTest.hx", lineNumber : 335, className : "iodev.geom2.VecBuilderTest", methodName : "testMirrorBy"});
		}
	}
	,testMirrorByXY: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forMirrorBy();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecBuilderTest.hx", lineNumber : 343, className : "iodev.geom2.VecBuilderTest", methodName : "testMirrorByXY"});
			var b = iodev_geom2_VecBuilder.fromXY(data1.vx,data1.vy);
			var res = b.mirrorByXY(data1.dirx,data1.diry);
			massive_munit_Assert.areEqual(b,res,{ fileName : "VecBuilderTest.hx", lineNumber : 348, className : "iodev.geom2.VecBuilderTest", methodName : "testMirrorByXY"});
			MathAssert.floatEqual(data1.dstx,b.toX(),{ fileName : "VecBuilderTest.hx", lineNumber : 349, className : "iodev.geom2.VecBuilderTest", methodName : "testMirrorByXY"});
			MathAssert.floatEqual(data1.dsty,b.toY(),{ fileName : "VecBuilderTest.hx", lineNumber : 350, className : "iodev.geom2.VecBuilderTest", methodName : "testMirrorByXY"});
		}
	}
	,testMirrorByNormal: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forMirrorByNormal();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecBuilderTest.hx", lineNumber : 358, className : "iodev.geom2.VecBuilderTest", methodName : "testMirrorByNormal"});
			var b = iodev_geom2_VecBuilder.fromXY(data1.vx,data1.vy);
			var res = b.mirrorByNormal(iodev_geom2_Vec.fromXY(data1.dirx,data1.diry));
			massive_munit_Assert.areEqual(b,res,{ fileName : "VecBuilderTest.hx", lineNumber : 363, className : "iodev.geom2.VecBuilderTest", methodName : "testMirrorByNormal"});
			MathAssert.floatEqual(data1.dstx,b.toX(),{ fileName : "VecBuilderTest.hx", lineNumber : 364, className : "iodev.geom2.VecBuilderTest", methodName : "testMirrorByNormal"});
			MathAssert.floatEqual(data1.dsty,b.toY(),{ fileName : "VecBuilderTest.hx", lineNumber : 365, className : "iodev.geom2.VecBuilderTest", methodName : "testMirrorByNormal"});
		}
	}
	,testMirrorByNormalXY: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forMirrorByNormal();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecBuilderTest.hx", lineNumber : 373, className : "iodev.geom2.VecBuilderTest", methodName : "testMirrorByNormalXY"});
			var b = iodev_geom2_VecBuilder.fromXY(data1.vx,data1.vy);
			var res = b.mirrorByNormalXY(data1.dirx,data1.diry);
			massive_munit_Assert.areEqual(b,res,{ fileName : "VecBuilderTest.hx", lineNumber : 378, className : "iodev.geom2.VecBuilderTest", methodName : "testMirrorByNormalXY"});
			MathAssert.floatEqual(data1.dstx,b.toX(),{ fileName : "VecBuilderTest.hx", lineNumber : 379, className : "iodev.geom2.VecBuilderTest", methodName : "testMirrorByNormalXY"});
			MathAssert.floatEqual(data1.dsty,b.toY(),{ fileName : "VecBuilderTest.hx", lineNumber : 380, className : "iodev.geom2.VecBuilderTest", methodName : "testMirrorByNormalXY"});
		}
	}
	,testToVec: function() {
		var x = Math.random();
		var y = Math.random();
		var b = iodev_geom2_VecBuilder.fromXY(x,y);
		var v = b.toVec();
		massive_munit_Assert.isType(v,iodev_geom2_Vec,{ fileName : "VecBuilderTest.hx", lineNumber : 392, className : "iodev.geom2.VecBuilderTest", methodName : "testToVec"});
		MathAssert.floatEqual(x,v.x,{ fileName : "VecBuilderTest.hx", lineNumber : 393, className : "iodev.geom2.VecBuilderTest", methodName : "testToVec"});
		MathAssert.floatEqual(y,v.y,{ fileName : "VecBuilderTest.hx", lineNumber : 394, className : "iodev.geom2.VecBuilderTest", methodName : "testToVec"});
	}
	,testToVecSpecified: function() {
		var x = Math.random();
		var y = Math.random();
		var dst = new iodev_geom2_Vec();
		var b = iodev_geom2_VecBuilder.fromXY(x,y);
		var v = b.toVecSpecified(dst);
		massive_munit_Assert.areEqual(dst,v,{ fileName : "VecBuilderTest.hx", lineNumber : 406, className : "iodev.geom2.VecBuilderTest", methodName : "testToVecSpecified"});
		MathAssert.floatEqual(x,v.x,{ fileName : "VecBuilderTest.hx", lineNumber : 407, className : "iodev.geom2.VecBuilderTest", methodName : "testToVecSpecified"});
		MathAssert.floatEqual(y,v.y,{ fileName : "VecBuilderTest.hx", lineNumber : 408, className : "iodev.geom2.VecBuilderTest", methodName : "testToVecSpecified"});
	}
	,testToX: function() {
		var x = Math.random();
		var b = iodev_geom2_VecBuilder.fromXY(x,0);
		MathAssert.floatEqual(x,b.toX(),{ fileName : "VecBuilderTest.hx", lineNumber : 417, className : "iodev.geom2.VecBuilderTest", methodName : "testToX"});
	}
	,testToY: function() {
		var y = Math.random();
		var b = iodev_geom2_VecBuilder.fromXY(0,y);
		MathAssert.floatEqual(y,b.toY(),{ fileName : "VecBuilderTest.hx", lineNumber : 426, className : "iodev.geom2.VecBuilderTest", methodName : "testToY"});
	}
	,testToLength: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forLength();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecBuilderTest.hx", lineNumber : 433, className : "iodev.geom2.VecBuilderTest", methodName : "testToLength"});
			var b = iodev_geom2_VecBuilder.fromXY(data1.x,data1.y);
			MathAssert.floatEqual(data1.len,b.toLength(),{ fileName : "VecBuilderTest.hx", lineNumber : 437, className : "iodev.geom2.VecBuilderTest", methodName : "testToLength"});
		}
	}
	,testToMagnitude: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forMagnitude();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecBuilderTest.hx", lineNumber : 445, className : "iodev.geom2.VecBuilderTest", methodName : "testToMagnitude"});
			var b = iodev_geom2_VecBuilder.fromXY(data1.x,data1.y);
			MathAssert.floatEqual(data1.mag,b.toMagnitude(),{ fileName : "VecBuilderTest.hx", lineNumber : 449, className : "iodev.geom2.VecBuilderTest", methodName : "testToMagnitude"});
		}
	}
	,testToRadians: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forRadiansOf();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecBuilderTest.hx", lineNumber : 457, className : "iodev.geom2.VecBuilderTest", methodName : "testToRadians"});
			var b = iodev_geom2_VecBuilder.fromXY(data1.x,data1.y);
			MathAssert.floatEqual(data1.res,b.toRadians(),{ fileName : "VecBuilderTest.hx", lineNumber : 461, className : "iodev.geom2.VecBuilderTest", methodName : "testToRadians"});
		}
	}
	,__class__: iodev_geom2_VecBuilderTest
};
var iodev_geom2_VecTest = function() { };
$hxClasses["iodev.geom2.VecTest"] = iodev_geom2_VecTest;
iodev_geom2_VecTest.__name__ = ["iodev","geom2","VecTest"];
iodev_geom2_VecTest.prototype = {
	testFromXY: function() {
		var x = Math.random();
		var y = Math.random();
		var v = iodev_geom2_Vec.fromXY(x,y);
		MathAssert.floatEqual(x,v.x,{ fileName : "VecTest.hx", lineNumber : 18, className : "iodev.geom2.VecTest", methodName : "testFromXY"});
		MathAssert.floatEqual(y,v.y,{ fileName : "VecTest.hx", lineNumber : 19, className : "iodev.geom2.VecTest", methodName : "testFromXY"});
	}
	,testFromPolar: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forPolar();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecTest.hx", lineNumber : 26, className : "iodev.geom2.VecTest", methodName : "testFromPolar"});
			var v = iodev_geom2_Vec.fromPolar(data1.radians,data1.len);
			MathAssert.floatEqual(data1.dstx,v.x,{ fileName : "VecTest.hx", lineNumber : 29, className : "iodev.geom2.VecTest", methodName : "testFromPolar"});
			MathAssert.floatEqual(data1.dsty,v.y,{ fileName : "VecTest.hx", lineNumber : 30, className : "iodev.geom2.VecTest", methodName : "testFromPolar"});
		}
	}
	,testFromAdd: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forAdd();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecTest.hx", lineNumber : 38, className : "iodev.geom2.VecTest", methodName : "testFromAdd"});
			var a = new iodev_geom2_Vec(data1.ax,data1.ay);
			var b = new iodev_geom2_Vec(data1.bx,data1.by);
			var dst = iodev_geom2_Vec.fromAdd(a,b);
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "VecTest.hx", lineNumber : 44, className : "iodev.geom2.VecTest", methodName : "testFromAdd"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "VecTest.hx", lineNumber : 45, className : "iodev.geom2.VecTest", methodName : "testFromAdd"});
		}
	}
	,testFromSub: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forSub();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecTest.hx", lineNumber : 53, className : "iodev.geom2.VecTest", methodName : "testFromSub"});
			var a = new iodev_geom2_Vec(data1.ax,data1.ay);
			var b = new iodev_geom2_Vec(data1.bx,data1.by);
			var dst = iodev_geom2_Vec.fromSub(a,b);
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "VecTest.hx", lineNumber : 59, className : "iodev.geom2.VecTest", methodName : "testFromSub"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "VecTest.hx", lineNumber : 60, className : "iodev.geom2.VecTest", methodName : "testFromSub"});
		}
	}
	,testFromMul: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forMul();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecTest.hx", lineNumber : 68, className : "iodev.geom2.VecTest", methodName : "testFromMul"});
			var a = new iodev_geom2_Vec(data1.ax,data1.ay);
			var b = new iodev_geom2_Vec(data1.bx,data1.by);
			var dst = iodev_geom2_Vec.fromMul(a,b);
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "VecTest.hx", lineNumber : 74, className : "iodev.geom2.VecTest", methodName : "testFromMul"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "VecTest.hx", lineNumber : 75, className : "iodev.geom2.VecTest", methodName : "testFromMul"});
		}
	}
	,testFromDiv: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forDiv();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecTest.hx", lineNumber : 83, className : "iodev.geom2.VecTest", methodName : "testFromDiv"});
			var a = new iodev_geom2_Vec(data1.ax,data1.ay);
			var b = new iodev_geom2_Vec(data1.bx,data1.by);
			var dst = iodev_geom2_Vec.fromDiv(a,b);
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "VecTest.hx", lineNumber : 89, className : "iodev.geom2.VecTest", methodName : "testFromDiv"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "VecTest.hx", lineNumber : 90, className : "iodev.geom2.VecTest", methodName : "testFromDiv"});
		}
	}
	,testNormalBisectorFrom: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forNormalBisector();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecTest.hx", lineNumber : 98, className : "iodev.geom2.VecTest", methodName : "testNormalBisectorFrom"});
			var a = new iodev_geom2_Vec(data1.ax,data1.ay);
			var b = new iodev_geom2_Vec(data1.bx,data1.by);
			var dst = iodev_geom2_Vec.normalBisectorFrom(a,b);
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "VecTest.hx", lineNumber : 104, className : "iodev.geom2.VecTest", methodName : "testNormalBisectorFrom"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "VecTest.hx", lineNumber : 105, className : "iodev.geom2.VecTest", methodName : "testNormalBisectorFrom"});
		}
	}
	,testEquals: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forEquals();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecTest.hx", lineNumber : 113, className : "iodev.geom2.VecTest", methodName : "testEquals"});
			var a = new iodev_geom2_Vec(data1.ax,data1.ay);
			var b = new iodev_geom2_Vec(data1.bx,data1.by);
			var res = iodev_geom2_Vec.equals(a,b);
			massive_munit_Assert.areEqual(data1.res,res,{ fileName : "VecTest.hx", lineNumber : 119, className : "iodev.geom2.VecTest", methodName : "testEquals"});
		}
	}
	,testDotProd: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forDotProd();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecTest.hx", lineNumber : 127, className : "iodev.geom2.VecTest", methodName : "testDotProd"});
			var a = new iodev_geom2_Vec(data1.ax,data1.ay);
			var b = new iodev_geom2_Vec(data1.bx,data1.by);
			var res = iodev_geom2_Vec.dotProd(a,b);
			MathAssert.floatEqual(data1.res,res,{ fileName : "VecTest.hx", lineNumber : 133, className : "iodev.geom2.VecTest", methodName : "testDotProd"});
		}
	}
	,testSkewProd: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forSkewProd();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecTest.hx", lineNumber : 141, className : "iodev.geom2.VecTest", methodName : "testSkewProd"});
			var a = new iodev_geom2_Vec(data1.ax,data1.ay);
			var b = new iodev_geom2_Vec(data1.bx,data1.by);
			var res = iodev_geom2_Vec.skewProd(a,b);
			MathAssert.floatEqual(data1.res,res,{ fileName : "VecTest.hx", lineNumber : 147, className : "iodev.geom2.VecTest", methodName : "testSkewProd"});
		}
	}
	,testLengthBentween: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forLengthBetween();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecTest.hx", lineNumber : 155, className : "iodev.geom2.VecTest", methodName : "testLengthBentween"});
			var a = new iodev_geom2_Vec(data1.ax,data1.ay);
			var b = new iodev_geom2_Vec(data1.bx,data1.by);
			var res = iodev_geom2_Vec.lengthBetween(a,b);
			MathAssert.floatEqual(data1.res,res,{ fileName : "VecTest.hx", lineNumber : 161, className : "iodev.geom2.VecTest", methodName : "testLengthBentween"});
		}
	}
	,testMagnitudeBetween: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forMagnitudeBetween();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecTest.hx", lineNumber : 169, className : "iodev.geom2.VecTest", methodName : "testMagnitudeBetween"});
			var a = new iodev_geom2_Vec(data1.ax,data1.ay);
			var b = new iodev_geom2_Vec(data1.bx,data1.by);
			var res = iodev_geom2_Vec.magnitudeBetween(a,b);
			MathAssert.floatEqual(data1.res,res,{ fileName : "VecTest.hx", lineNumber : 175, className : "iodev.geom2.VecTest", methodName : "testMagnitudeBetween"});
		}
	}
	,testRadiansBetween: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forRadiansBetween();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecTest.hx", lineNumber : 183, className : "iodev.geom2.VecTest", methodName : "testRadiansBetween"});
			var a = new iodev_geom2_Vec(data1.ax,data1.ay);
			var b = new iodev_geom2_Vec(data1.bx,data1.by);
			var res = iodev_geom2_Vec.radiansBetween(a,b);
			MathAssert.floatEqual(data1.res,res,{ fileName : "VecTest.hx", lineNumber : 189, className : "iodev.geom2.VecTest", methodName : "testRadiansBetween"});
		}
	}
	,testRadiansBetweenNormals: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forRadiansBetweenNormals();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecTest.hx", lineNumber : 197, className : "iodev.geom2.VecTest", methodName : "testRadiansBetweenNormals"});
			var a = new iodev_geom2_Vec(data1.ax,data1.ay);
			var b = new iodev_geom2_Vec(data1.bx,data1.by);
			var res = iodev_geom2_Vec.radiansBetweenNormals(a,b);
			MathAssert.floatEqual(data1.res,res,{ fileName : "VecTest.hx", lineNumber : 203, className : "iodev.geom2.VecTest", methodName : "testRadiansBetweenNormals"});
		}
	}
	,testRadiansBetweenNormals_notnormal: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forRadiansBetween_notnormal();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecTest.hx", lineNumber : 211, className : "iodev.geom2.VecTest", methodName : "testRadiansBetweenNormals_notnormal"});
			var a = new iodev_geom2_Vec(data1.ax,data1.ay);
			var b = new iodev_geom2_Vec(data1.bx,data1.by);
			var res = iodev_geom2_Vec.radiansBetweenNormals(a,b);
			MathAssert.floatNotEqual(data1.res,res,{ fileName : "VecTest.hx", lineNumber : 217, className : "iodev.geom2.VecTest", methodName : "testRadiansBetweenNormals_notnormal"});
		}
	}
	,testConstructorDefaults: function() {
		var v = new iodev_geom2_Vec();
		MathAssert.floatEqual(0.0,v.x,{ fileName : "VecTest.hx", lineNumber : 230, className : "iodev.geom2.VecTest", methodName : "testConstructorDefaults"});
		MathAssert.floatEqual(0.0,v.y,{ fileName : "VecTest.hx", lineNumber : 231, className : "iodev.geom2.VecTest", methodName : "testConstructorDefaults"});
	}
	,testConstructorParams: function() {
		var x = 1000000 * (0.5 - Math.random());
		var y = 1000000 * (0.5 - Math.random());
		var v = new iodev_geom2_Vec(x,y);
		MathAssert.floatEqual(x,v.x,{ fileName : "VecTest.hx", lineNumber : 242, className : "iodev.geom2.VecTest", methodName : "testConstructorParams"});
		MathAssert.floatEqual(y,v.y,{ fileName : "VecTest.hx", lineNumber : 243, className : "iodev.geom2.VecTest", methodName : "testConstructorParams"});
	}
	,testFieldsAssign: function() {
		var x = 1000000 * (0.5 - Math.random());
		var y = 1000000 * (0.5 - Math.random());
		var v = new iodev_geom2_Vec();
		v.x = x;
		v.y = y;
		MathAssert.floatEqual(x,v.x,{ fileName : "VecTest.hx", lineNumber : 256, className : "iodev.geom2.VecTest", methodName : "testFieldsAssign"});
		MathAssert.floatEqual(y,v.y,{ fileName : "VecTest.hx", lineNumber : 257, className : "iodev.geom2.VecTest", methodName : "testFieldsAssign"});
	}
	,testFieldsModifying: function() {
		var x = Math.random();
		var y = Math.random();
		var v = new iodev_geom2_Vec(x,y);
		x *= 1.57;
		v.x *= 1.57;
		y /= 0.779;
		v.y /= 0.779;
		MathAssert.floatEqual(x,v.x,{ fileName : "VecTest.hx", lineNumber : 274, className : "iodev.geom2.VecTest", methodName : "testFieldsModifying"});
		MathAssert.floatEqual(y,v.y,{ fileName : "VecTest.hx", lineNumber : 275, className : "iodev.geom2.VecTest", methodName : "testFieldsModifying"});
	}
	,testClone: function() {
		var x = Math.random();
		var y = Math.random();
		var a = new iodev_geom2_Vec(x,y);
		mcover_coverage_MCoverage.getLogger().logStatement(33);
		var b = new iodev_geom2_Vec(a.x,a.y);
		massive_munit_Assert.areNotSame(a,b,{ fileName : "VecTest.hx", lineNumber : 287, className : "iodev.geom2.VecTest", methodName : "testClone"});
		MathAssert.floatEqual(a.x,b.x,{ fileName : "VecTest.hx", lineNumber : 288, className : "iodev.geom2.VecTest", methodName : "testClone"});
		MathAssert.floatEqual(a.y,b.y,{ fileName : "VecTest.hx", lineNumber : 289, className : "iodev.geom2.VecTest", methodName : "testClone"});
	}
	,testLength: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forLength();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecTest.hx", lineNumber : 296, className : "iodev.geom2.VecTest", methodName : "testLength"});
			var v = new iodev_geom2_Vec(data1.x,data1.y);
			var data2 = data1.len;
			mcover_coverage_MCoverage.getLogger().logStatement(34);
			MathAssert.floatEqual(data2,Math.sqrt(v.x * v.x + v.y * v.y),{ fileName : "VecTest.hx", lineNumber : 299, className : "iodev.geom2.VecTest", methodName : "testLength"});
		}
	}
	,testMagnitude: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forMagnitude();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecTest.hx", lineNumber : 307, className : "iodev.geom2.VecTest", methodName : "testMagnitude"});
			var v = new iodev_geom2_Vec(data1.x,data1.y);
			var data2 = data1.mag;
			mcover_coverage_MCoverage.getLogger().logStatement(35);
			MathAssert.floatEqual(data2,v.x * v.x + v.y * v.y,{ fileName : "VecTest.hx", lineNumber : 310, className : "iodev.geom2.VecTest", methodName : "testMagnitude"});
		}
	}
	,testNormalize: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forNormalize();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecTest.hx", lineNumber : 318, className : "iodev.geom2.VecTest", methodName : "testNormalize"});
			var v = new iodev_geom2_Vec(data1.x,data1.y);
			var len = data1.nlen;
			mcover_coverage_MCoverage.getLogger().logStatement(36);
			var m = len / Math.sqrt(v.x * v.x + v.y * v.y);
			v.x = m * v.x;
			v.y = m * v.y;
			MathAssert.floatEqual(data1.nx,v.x,{ fileName : "VecTest.hx", lineNumber : 323, className : "iodev.geom2.VecTest", methodName : "testNormalize"});
			MathAssert.floatEqual(data1.ny,v.y,{ fileName : "VecTest.hx", lineNumber : 324, className : "iodev.geom2.VecTest", methodName : "testNormalize"});
		}
	}
	,testToRadians: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forRadiansOf();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecTest.hx", lineNumber : 332, className : "iodev.geom2.VecTest", methodName : "testToRadians"});
			var v = new iodev_geom2_Vec(data1.x,data1.y);
			var data2 = data1.res;
			mcover_coverage_MCoverage.getLogger().logStatement(37);
			MathAssert.floatEqual(data2,Math.atan2(v.y,v.x),{ fileName : "VecTest.hx", lineNumber : 335, className : "iodev.geom2.VecTest", methodName : "testToRadians"});
		}
	}
	,testToString: function() {
		var v = new iodev_geom2_Vec();
		massive_munit_Assert.isType(v.toString(),String,{ fileName : "VecTest.hx", lineNumber : 343, className : "iodev.geom2.VecTest", methodName : "testToString"});
	}
	,__class__: iodev_geom2_VecTest
};
var iodev_geom2_intersec_CircleIntersec = $hx_exports["iodev"]["geom2"]["intersec"]["CircleIntersec"] = function() { };
$hxClasses["iodev.geom2.intersec.CircleIntersec"] = iodev_geom2_intersec_CircleIntersec;
iodev_geom2_intersec_CircleIntersec.__name__ = ["iodev","geom2","intersec","CircleIntersec"];
iodev_geom2_intersec_CircleIntersec.circleLine = function(cpos,cradius,lpos,lvec) {
	mcover_coverage_MCoverage.getLogger().logStatement(0);
	var ax;
	var ay;
	var bx;
	var by;
	var cnt;
	var dstarr;
	var lvx = lvec.x;
	var lvy = lvec.y;
	var lvmag = lvx * lvx + lvy * lvy;
	var cvx = cpos.x - lpos.x;
	var cvy = cpos.y - lpos.y;
	var m = (lvx * cvx + lvy * cvy) / lvmag;
	var pvx = m * lvx;
	var pvy = m * lvy;
	var dmag = cradius * cradius - ((pvx - cvx) * (pvx - cvx) + (pvy - cvy) * (pvy - cvy));
	if(dmag > 0) {
		var sm = Math.sqrt(dmag / lvmag);
		ax = lpos.x + pvx - sm * lvx;
		ay = lpos.y + pvy - sm * lvy;
		bx = lpos.x + pvx + sm * lvx;
		by = lpos.y + pvy + sm * lvy;
		cnt = 2;
	} else if(dmag == 0) {
		bx = lpos.x + pvx;
		ax = bx;
		by = lpos.y + pvy;
		ay = by;
		cnt = 1;
	} else {
		bx = NaN;
		ax = bx;
		by = NaN;
		ay = by;
		cnt = 0;
	}
	if(cnt == 2) {
		dstarr = [new iodev_geom2_Vec(ax,ay),new iodev_geom2_Vec(bx,by)];
	} else if(cnt == 1) {
		dstarr = [new iodev_geom2_Vec(ax,ay)];
	} else {
		dstarr = [];
	}
	return dstarr;
};
iodev_geom2_intersec_CircleIntersec.circleLineTo = function(dsta,dstb,cpos,cradius,lpos,lvec) {
	mcover_coverage_MCoverage.getLogger().logStatement(1);
	var cnt;
	var lvx = lvec.x;
	var lvy = lvec.y;
	var lvmag = lvx * lvx + lvy * lvy;
	var cvx = cpos.x - lpos.x;
	var cvy = cpos.y - lpos.y;
	var m = (lvx * cvx + lvy * cvy) / lvmag;
	var pvx = m * lvx;
	var pvy = m * lvy;
	var dmag = cradius * cradius - ((pvx - cvx) * (pvx - cvx) + (pvy - cvy) * (pvy - cvy));
	if(dmag > 0) {
		var sm = Math.sqrt(dmag / lvmag);
		dsta.x = lpos.x + pvx - sm * lvx;
		dsta.y = lpos.y + pvy - sm * lvy;
		dstb.x = lpos.x + pvx + sm * lvx;
		dstb.y = lpos.y + pvy + sm * lvy;
		cnt = 2;
	} else if(dmag == 0) {
		dsta.x = dstb.x = lpos.x + pvx;
		dsta.y = dstb.y = lpos.y + pvy;
		cnt = 1;
	} else {
		dsta.x = dstb.x = NaN;
		dsta.y = dstb.y = NaN;
		cnt = 0;
	}
	return cnt;
};
iodev_geom2_intersec_CircleIntersec.circleRay = function(cpos,cradius,rpos,rvec) {
	mcover_coverage_MCoverage.getLogger().logStatement(2);
	var ax;
	var ay;
	var bx;
	var by;
	var cnt;
	var dstarr;
	var lvx = rvec.x;
	var lvy = rvec.y;
	var lvmag = lvx * lvx + lvy * lvy;
	var cvx = cpos.x - rpos.x;
	var cvy = cpos.y - rpos.y;
	var m = (lvx * cvx + lvy * cvy) / lvmag;
	var pvx = m * lvx;
	var pvy = m * lvy;
	var dmag = cradius * cradius - ((pvx - cvx) * (pvx - cvx) + (pvy - cvy) * (pvy - cvy));
	if(dmag > 0) {
		var sm = Math.sqrt(dmag / lvmag);
		ax = rpos.x + pvx - sm * lvx;
		ay = rpos.y + pvy - sm * lvy;
		bx = rpos.x + pvx + sm * lvx;
		by = rpos.y + pvy + sm * lvy;
		cnt = 2;
	} else if(dmag == 0) {
		bx = rpos.x + pvx;
		ax = bx;
		by = rpos.y + pvy;
		ay = by;
		cnt = 1;
	} else {
		bx = NaN;
		ax = bx;
		by = NaN;
		ay = by;
		cnt = 0;
	}
	if(cnt > 0 && !(rvec.x * (bx - rpos.x) + rvec.y * (by - rpos.y) >= 0)) {
		--cnt;
		bx = ax;
		by = ay;
	}
	if(cnt > 0 && !(rvec.x * (ax - rpos.x) + rvec.y * (ay - rpos.y) >= 0)) {
		--cnt;
		ax = bx;
		ay = by;
	}
	if(cnt == 2) {
		dstarr = [new iodev_geom2_Vec(ax,ay),new iodev_geom2_Vec(bx,by)];
	} else if(cnt == 1) {
		dstarr = [new iodev_geom2_Vec(ax,ay)];
	} else {
		dstarr = [];
	}
	return dstarr;
};
iodev_geom2_intersec_CircleIntersec.circleRayTo = function(dsta,dstb,cpos,cradius,rpos,rvec) {
	mcover_coverage_MCoverage.getLogger().logStatement(3);
	var cnt;
	var lvx = rvec.x;
	var lvy = rvec.y;
	var lvmag = lvx * lvx + lvy * lvy;
	var cvx = cpos.x - rpos.x;
	var cvy = cpos.y - rpos.y;
	var m = (lvx * cvx + lvy * cvy) / lvmag;
	var pvx = m * lvx;
	var pvy = m * lvy;
	var dmag = cradius * cradius - ((pvx - cvx) * (pvx - cvx) + (pvy - cvy) * (pvy - cvy));
	if(dmag > 0) {
		var sm = Math.sqrt(dmag / lvmag);
		dsta.x = rpos.x + pvx - sm * lvx;
		dsta.y = rpos.y + pvy - sm * lvy;
		dstb.x = rpos.x + pvx + sm * lvx;
		dstb.y = rpos.y + pvy + sm * lvy;
		cnt = 2;
	} else if(dmag == 0) {
		dsta.x = dstb.x = rpos.x + pvx;
		dsta.y = dstb.y = rpos.y + pvy;
		cnt = 1;
	} else {
		dsta.x = dstb.x = NaN;
		dsta.y = dstb.y = NaN;
		cnt = 0;
	}
	if(cnt > 0 && !(rvec.x * (dstb.x - rpos.x) + rvec.y * (dstb.y - rpos.y) >= 0)) {
		--cnt;
		dstb.x = dsta.x;
		dstb.y = dsta.y;
	}
	if(cnt > 0 && !(rvec.x * (dsta.x - rpos.x) + rvec.y * (dsta.y - rpos.y) >= 0)) {
		--cnt;
		dsta.x = dstb.x;
		dsta.y = dstb.y;
	}
	return cnt;
};
iodev_geom2_intersec_CircleIntersec.circleSegm = function(cpos,cradius,spos,svec) {
	mcover_coverage_MCoverage.getLogger().logStatement(4);
	var ax;
	var ay;
	var bx;
	var by;
	var cnt;
	var dstarr;
	var lvx = svec.x;
	var lvy = svec.y;
	var lvmag = lvx * lvx + lvy * lvy;
	var cvx = cpos.x - spos.x;
	var cvy = cpos.y - spos.y;
	var m = (lvx * cvx + lvy * cvy) / lvmag;
	var pvx = m * lvx;
	var pvy = m * lvy;
	var dmag = cradius * cradius - ((pvx - cvx) * (pvx - cvx) + (pvy - cvy) * (pvy - cvy));
	if(dmag > 0) {
		var sm = Math.sqrt(dmag / lvmag);
		ax = spos.x + pvx - sm * lvx;
		ay = spos.y + pvy - sm * lvy;
		bx = spos.x + pvx + sm * lvx;
		by = spos.y + pvy + sm * lvy;
		cnt = 2;
	} else if(dmag == 0) {
		bx = spos.x + pvx;
		ax = bx;
		by = spos.y + pvy;
		ay = by;
		cnt = 1;
	} else {
		bx = NaN;
		ax = bx;
		by = NaN;
		ay = by;
		cnt = 0;
	}
	if(cnt > 0 && !((svec.x * (bx - spos.x) + svec.y * (by - spos.y)) * (svec.x * (bx - (spos.x + svec.x)) + svec.y * (by - (spos.y + svec.y))) <= 0)) {
		--cnt;
		bx = ax;
		by = ay;
	}
	if(cnt > 0 && !((svec.x * (ax - spos.x) + svec.y * (ay - spos.y)) * (svec.x * (ax - (spos.x + svec.x)) + svec.y * (ay - (spos.y + svec.y))) <= 0)) {
		--cnt;
		ax = bx;
		ay = by;
	}
	if(cnt == 2) {
		dstarr = [new iodev_geom2_Vec(ax,ay),new iodev_geom2_Vec(bx,by)];
	} else if(cnt == 1) {
		dstarr = [new iodev_geom2_Vec(ax,ay)];
	} else {
		dstarr = [];
	}
	return dstarr;
};
iodev_geom2_intersec_CircleIntersec.circleSegmTo = function(dsta,dstb,cpos,cradius,spos,svec) {
	mcover_coverage_MCoverage.getLogger().logStatement(5);
	var cnt;
	var lvx = svec.x;
	var lvy = svec.y;
	var lvmag = lvx * lvx + lvy * lvy;
	var cvx = cpos.x - spos.x;
	var cvy = cpos.y - spos.y;
	var m = (lvx * cvx + lvy * cvy) / lvmag;
	var pvx = m * lvx;
	var pvy = m * lvy;
	var dmag = cradius * cradius - ((pvx - cvx) * (pvx - cvx) + (pvy - cvy) * (pvy - cvy));
	if(dmag > 0) {
		var sm = Math.sqrt(dmag / lvmag);
		dsta.x = spos.x + pvx - sm * lvx;
		dsta.y = spos.y + pvy - sm * lvy;
		dstb.x = spos.x + pvx + sm * lvx;
		dstb.y = spos.y + pvy + sm * lvy;
		cnt = 2;
	} else if(dmag == 0) {
		dsta.x = dstb.x = spos.x + pvx;
		dsta.y = dstb.y = spos.y + pvy;
		cnt = 1;
	} else {
		dsta.x = dstb.x = NaN;
		dsta.y = dstb.y = NaN;
		cnt = 0;
	}
	if(cnt > 0 && !((svec.x * (dstb.x - spos.x) + svec.y * (dstb.y - spos.y)) * (svec.x * (dstb.x - (spos.x + svec.x)) + svec.y * (dstb.y - (spos.y + svec.y))) <= 0)) {
		--cnt;
		dstb.x = dsta.x;
		dstb.y = dsta.y;
	}
	if(cnt > 0 && !((svec.x * (dsta.x - spos.x) + svec.y * (dsta.y - spos.y)) * (svec.x * (dsta.x - (spos.x + svec.x)) + svec.y * (dsta.y - (spos.y + svec.y))) <= 0)) {
		--cnt;
		dsta.x = dstb.x;
		dsta.y = dstb.y;
	}
	return cnt;
};
var iodev_geom2_intersec_LineIntersec = $hx_exports["iodev"]["geom2"]["intersec"]["LineIntersec"] = function() { };
$hxClasses["iodev.geom2.intersec.LineIntersec"] = iodev_geom2_intersec_LineIntersec;
iodev_geom2_intersec_LineIntersec.__name__ = ["iodev","geom2","intersec","LineIntersec"];
iodev_geom2_intersec_LineIntersec.lineLine = function(apos,avec,bpos,bvec) {
	mcover_coverage_MCoverage.getLogger().logStatement(64);
	var dstx;
	var dsty;
	var dx1dy2 = avec.x * bvec.y;
	var dx2dy1 = bvec.x * avec.y;
	var isp = 1.0 / (dx1dy2 - dx2dy1);
	dstx = (bpos.x * dx1dy2 - apos.x * dx2dy1 - (bpos.y - apos.y) * avec.x * bvec.x) * isp;
	dsty = (apos.y * dx1dy2 - bpos.y * dx2dy1 + (bpos.x - apos.x) * avec.y * bvec.y) * isp;
	return new iodev_geom2_Vec(dstx,dsty);
};
iodev_geom2_intersec_LineIntersec.lineLineTo = function(dst,apos,avec,bpos,bvec) {
	mcover_coverage_MCoverage.getLogger().logStatement(65);
	var dx1dy2 = avec.x * bvec.y;
	var dx2dy1 = bvec.x * avec.y;
	var isp = 1.0 / (dx1dy2 - dx2dy1);
	dst.x = (bpos.x * dx1dy2 - apos.x * dx2dy1 - (bpos.y - apos.y) * avec.x * bvec.x) * isp;
	dst.y = (apos.y * dx1dy2 - bpos.y * dx2dy1 + (bpos.x - apos.x) * avec.y * bvec.y) * isp;
};
iodev_geom2_intersec_LineIntersec.lineRay = function(lpos,lvec,rpos,rvec) {
	mcover_coverage_MCoverage.getLogger().logStatement(67);
	var dstres;
	var dstx;
	var dsty;
	var dx1dy2 = lvec.x * rvec.y;
	var dx2dy1 = rvec.x * lvec.y;
	var isp = 1.0 / (dx1dy2 - dx2dy1);
	dstx = (rpos.x * dx1dy2 - lpos.x * dx2dy1 - (rpos.y - lpos.y) * lvec.x * rvec.x) * isp;
	dsty = (lpos.y * dx1dy2 - rpos.y * dx2dy1 + (rpos.x - lpos.x) * lvec.y * rvec.y) * isp;
	dstres = rvec.x * (dstx - rpos.x) + rvec.y * (dsty - rpos.y) >= 0;
	if(mcover_coverage_MCoverage.getLogger().logBranch(0,dstres)) {
		mcover_coverage_MCoverage.getLogger().logStatement(66);
		return new iodev_geom2_Vec(dstx,dsty);
	}
	return null;
};
iodev_geom2_intersec_LineIntersec.lineRayTo = function(dst,lpos,lvec,rpos,rvec) {
	mcover_coverage_MCoverage.getLogger().logStatement(68);
	var dstres;
	var dx1dy2 = lvec.x * rvec.y;
	var dx2dy1 = rvec.x * lvec.y;
	var isp = 1.0 / (dx1dy2 - dx2dy1);
	dst.x = (rpos.x * dx1dy2 - lpos.x * dx2dy1 - (rpos.y - lpos.y) * lvec.x * rvec.x) * isp;
	dst.y = (lpos.y * dx1dy2 - rpos.y * dx2dy1 + (rpos.x - lpos.x) * lvec.y * rvec.y) * isp;
	dstres = rvec.x * (dst.x - rpos.x) + rvec.y * (dst.y - rpos.y) >= 0;
	return dstres;
};
iodev_geom2_intersec_LineIntersec.lineSegm = function(lpos,lvec,spos,svec) {
	mcover_coverage_MCoverage.getLogger().logStatement(70);
	var dstres;
	var dstx;
	var dsty;
	var dx1dy2 = lvec.x * svec.y;
	var dx2dy1 = svec.x * lvec.y;
	var isp = 1.0 / (dx1dy2 - dx2dy1);
	dstx = (spos.x * dx1dy2 - lpos.x * dx2dy1 - (spos.y - lpos.y) * lvec.x * svec.x) * isp;
	dsty = (lpos.y * dx1dy2 - spos.y * dx2dy1 + (spos.x - lpos.x) * lvec.y * svec.y) * isp;
	dstres = (svec.x * (dstx - spos.x) + svec.y * (dsty - spos.y)) * (svec.x * (dstx - (spos.x + svec.x)) + svec.y * (dsty - (spos.y + svec.y))) <= 0;
	if(mcover_coverage_MCoverage.getLogger().logBranch(1,dstres)) {
		mcover_coverage_MCoverage.getLogger().logStatement(69);
		return new iodev_geom2_Vec(dstx,dsty);
	}
	return null;
};
iodev_geom2_intersec_LineIntersec.lineSegmTo = function(dst,lpos,lvec,spos,svec) {
	mcover_coverage_MCoverage.getLogger().logStatement(71);
	var dstres;
	var dx1dy2 = lvec.x * svec.y;
	var dx2dy1 = svec.x * lvec.y;
	var isp = 1.0 / (dx1dy2 - dx2dy1);
	dst.x = (spos.x * dx1dy2 - lpos.x * dx2dy1 - (spos.y - lpos.y) * lvec.x * svec.x) * isp;
	dst.y = (lpos.y * dx1dy2 - spos.y * dx2dy1 + (spos.x - lpos.x) * lvec.y * svec.y) * isp;
	dstres = (svec.x * (dst.x - spos.x) + svec.y * (dst.y - spos.y)) * (svec.x * (dst.x - (spos.x + svec.x)) + svec.y * (dst.y - (spos.y + svec.y))) <= 0;
	return dstres;
};
iodev_geom2_intersec_LineIntersec.rayRay = function(apos,avec,bpos,bvec) {
	mcover_coverage_MCoverage.getLogger().logStatement(73);
	var dstres;
	var dstx;
	var dsty;
	var dx1dy2 = avec.x * bvec.y;
	var dx2dy1 = bvec.x * avec.y;
	var isp = 1.0 / (dx1dy2 - dx2dy1);
	dstx = (bpos.x * dx1dy2 - apos.x * dx2dy1 - (bpos.y - apos.y) * avec.x * bvec.x) * isp;
	dsty = (apos.y * dx1dy2 - bpos.y * dx2dy1 + (bpos.x - apos.x) * avec.y * bvec.y) * isp;
	if(avec.x * (dstx - apos.x) + avec.y * (dsty - apos.y) >= 0) {
		dstres = bvec.x * (dstx - bpos.x) + bvec.y * (dsty - bpos.y) >= 0;
	} else {
		dstres = false;
	}
	if(mcover_coverage_MCoverage.getLogger().logBranch(2,dstres)) {
		mcover_coverage_MCoverage.getLogger().logStatement(72);
		return new iodev_geom2_Vec(dstx,dsty);
	}
	return null;
};
iodev_geom2_intersec_LineIntersec.rayRayTo = function(dst,apos,avec,bpos,bvec) {
	mcover_coverage_MCoverage.getLogger().logStatement(74);
	var dstres;
	var dx1dy2 = avec.x * bvec.y;
	var dx2dy1 = bvec.x * avec.y;
	var isp = 1.0 / (dx1dy2 - dx2dy1);
	dst.x = (bpos.x * dx1dy2 - apos.x * dx2dy1 - (bpos.y - apos.y) * avec.x * bvec.x) * isp;
	dst.y = (apos.y * dx1dy2 - bpos.y * dx2dy1 + (bpos.x - apos.x) * avec.y * bvec.y) * isp;
	if(avec.x * (dst.x - apos.x) + avec.y * (dst.y - apos.y) >= 0) {
		dstres = bvec.x * (dst.x - bpos.x) + bvec.y * (dst.y - bpos.y) >= 0;
	} else {
		dstres = false;
	}
	return dstres;
};
iodev_geom2_intersec_LineIntersec.raySegm = function(rpos,rvec,spos,svec) {
	mcover_coverage_MCoverage.getLogger().logStatement(76);
	var dstres;
	var dstx;
	var dsty;
	var dx1dy2 = rvec.x * svec.y;
	var dx2dy1 = svec.x * rvec.y;
	var isp = 1.0 / (dx1dy2 - dx2dy1);
	dstx = (spos.x * dx1dy2 - rpos.x * dx2dy1 - (spos.y - rpos.y) * rvec.x * svec.x) * isp;
	dsty = (rpos.y * dx1dy2 - spos.y * dx2dy1 + (spos.x - rpos.x) * rvec.y * svec.y) * isp;
	if(rvec.x * (dstx - rpos.x) + rvec.y * (dsty - rpos.y) >= 0) {
		dstres = (svec.x * (dstx - spos.x) + svec.y * (dsty - spos.y)) * (svec.x * (dstx - (spos.x + svec.x)) + svec.y * (dsty - (spos.y + svec.y))) <= 0;
	} else {
		dstres = false;
	}
	if(mcover_coverage_MCoverage.getLogger().logBranch(3,dstres)) {
		mcover_coverage_MCoverage.getLogger().logStatement(75);
		return new iodev_geom2_Vec(dstx,dsty);
	}
	return null;
};
iodev_geom2_intersec_LineIntersec.raySegmTo = function(dst,rpos,rvec,spos,svec) {
	mcover_coverage_MCoverage.getLogger().logStatement(77);
	var dstres;
	var dx1dy2 = rvec.x * svec.y;
	var dx2dy1 = svec.x * rvec.y;
	var isp = 1.0 / (dx1dy2 - dx2dy1);
	dst.x = (spos.x * dx1dy2 - rpos.x * dx2dy1 - (spos.y - rpos.y) * rvec.x * svec.x) * isp;
	dst.y = (rpos.y * dx1dy2 - spos.y * dx2dy1 + (spos.x - rpos.x) * rvec.y * svec.y) * isp;
	if(rvec.x * (dst.x - rpos.x) + rvec.y * (dst.y - rpos.y) >= 0) {
		dstres = (svec.x * (dst.x - spos.x) + svec.y * (dst.y - spos.y)) * (svec.x * (dst.x - (spos.x + svec.x)) + svec.y * (dst.y - (spos.y + svec.y))) <= 0;
	} else {
		dstres = false;
	}
	return dstres;
};
iodev_geom2_intersec_LineIntersec.segmSegm = function(apos,avec,bpos,bvec) {
	mcover_coverage_MCoverage.getLogger().logStatement(79);
	var dstres;
	var dstx;
	var dsty;
	var dx1dy2 = avec.x * bvec.y;
	var dx2dy1 = bvec.x * avec.y;
	var isp = 1.0 / (dx1dy2 - dx2dy1);
	dstx = (bpos.x * dx1dy2 - apos.x * dx2dy1 - (bpos.y - apos.y) * avec.x * bvec.x) * isp;
	dsty = (apos.y * dx1dy2 - bpos.y * dx2dy1 + (bpos.x - apos.x) * avec.y * bvec.y) * isp;
	if((avec.x * (dstx - apos.x) + avec.y * (dsty - apos.y)) * (avec.x * (dstx - (apos.x + avec.x)) + avec.y * (dsty - (apos.y + avec.y))) <= 0) {
		dstres = (bvec.x * (dstx - bpos.x) + bvec.y * (dsty - bpos.y)) * (bvec.x * (dstx - (bpos.x + bvec.x)) + bvec.y * (dsty - (bpos.y + bvec.y))) <= 0;
	} else {
		dstres = false;
	}
	if(mcover_coverage_MCoverage.getLogger().logBranch(4,dstres)) {
		mcover_coverage_MCoverage.getLogger().logStatement(78);
		return new iodev_geom2_Vec(dstx,dsty);
	}
	return null;
};
iodev_geom2_intersec_LineIntersec.segmSegmTo = function(dst,apos,avec,bpos,bvec) {
	mcover_coverage_MCoverage.getLogger().logStatement(80);
	var dstres;
	var dx1dy2 = avec.x * bvec.y;
	var dx2dy1 = bvec.x * avec.y;
	var isp = 1.0 / (dx1dy2 - dx2dy1);
	dst.x = (bpos.x * dx1dy2 - apos.x * dx2dy1 - (bpos.y - apos.y) * avec.x * bvec.x) * isp;
	dst.y = (apos.y * dx1dy2 - bpos.y * dx2dy1 + (bpos.x - apos.x) * avec.y * bvec.y) * isp;
	if((avec.x * (dst.x - apos.x) + avec.y * (dst.y - apos.y)) * (avec.x * (dst.x - (apos.x + avec.x)) + avec.y * (dst.y - (apos.y + avec.y))) <= 0) {
		dstres = (bvec.x * (dst.x - bpos.x) + bvec.y * (dst.y - bpos.y)) * (bvec.x * (dst.x - (bpos.x + bvec.x)) + bvec.y * (dst.y - (bpos.y + bvec.y))) <= 0;
	} else {
		dstres = false;
	}
	return dstres;
};
var iodev_geom2_intersec_LineIntersecTest = function() { };
$hxClasses["iodev.geom2.intersec.LineIntersecTest"] = iodev_geom2_intersec_LineIntersecTest;
iodev_geom2_intersec_LineIntersecTest.__name__ = ["iodev","geom2","intersec","LineIntersecTest"];
iodev_geom2_intersec_LineIntersecTest.prototype = {
	testLineLine_cross: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCross();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 16, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLine_cross"});
			var dst = iodev_geom2_intersec_LineIntersec.lineLine(new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 25, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLine_cross"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 26, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLine_cross"});
		}
	}
	,testLineLine_touch: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forTouch();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 34, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLine_touch"});
			var dst = iodev_geom2_intersec_LineIntersec.lineLine(new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 43, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLine_touch"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 44, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLine_touch"});
		}
	}
	,testLineLine_projectIn: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forProjectIn();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 52, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLine_projectIn"});
			var dst = iodev_geom2_intersec_LineIntersec.lineLine(new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 61, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLine_projectIn"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 62, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLine_projectIn"});
		}
	}
	,testLineLine_projectOut: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forProjectOut();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 70, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLine_projectOut"});
			var dst = iodev_geom2_intersec_LineIntersec.lineLine(new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 79, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLine_projectOut"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 80, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLine_projectOut"});
		}
	}
	,testLineLine_castIn: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastIn();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 88, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLine_castIn"});
			var dst = iodev_geom2_intersec_LineIntersec.lineLine(new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 97, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLine_castIn"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 98, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLine_castIn"});
		}
	}
	,testLineLine_castOut: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastOut();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 106, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLine_castOut"});
			var dst = iodev_geom2_intersec_LineIntersec.lineLine(new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 115, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLine_castOut"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 116, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLine_castOut"});
		}
	}
	,testLineLine_castAway: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastAway();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 124, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLine_castAway"});
			var dst = iodev_geom2_intersec_LineIntersec.lineLine(new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 133, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLine_castAway"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 134, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLine_castAway"});
		}
	}
	,testLineLine_parallel: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forParallel();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 142, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLine_parallel"});
			var dst = iodev_geom2_intersec_LineIntersec.lineLine(new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 151, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLine_parallel"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 152, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLine_parallel"});
		}
	}
	,testLineLineTo_cross: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCross();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 164, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLineTo_cross"});
			var dst = new iodev_geom2_Vec();
			iodev_geom2_intersec_LineIntersec.lineLineTo(dst,new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 175, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLineTo_cross"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 176, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLineTo_cross"});
		}
	}
	,testLineLineTo_touch: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forTouch();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 184, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLineTo_touch"});
			var dst = new iodev_geom2_Vec();
			iodev_geom2_intersec_LineIntersec.lineLineTo(dst,new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 195, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLineTo_touch"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 196, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLineTo_touch"});
		}
	}
	,testLineLineTo_projectIn: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forProjectIn();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 204, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLineTo_projectIn"});
			var dst = new iodev_geom2_Vec();
			iodev_geom2_intersec_LineIntersec.lineLineTo(dst,new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 215, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLineTo_projectIn"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 216, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLineTo_projectIn"});
		}
	}
	,testLineLineTo_projectOut: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forProjectOut();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 224, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLineTo_projectOut"});
			var dst = new iodev_geom2_Vec();
			iodev_geom2_intersec_LineIntersec.lineLineTo(dst,new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 235, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLineTo_projectOut"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 236, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLineTo_projectOut"});
		}
	}
	,testLineLineTo_castIn: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastIn();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 244, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLineTo_castIn"});
			var dst = new iodev_geom2_Vec();
			iodev_geom2_intersec_LineIntersec.lineLineTo(dst,new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 255, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLineTo_castIn"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 256, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLineTo_castIn"});
		}
	}
	,testLineLineTo_castOut: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastOut();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 264, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLineTo_castOut"});
			var dst = new iodev_geom2_Vec();
			iodev_geom2_intersec_LineIntersec.lineLineTo(dst,new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 275, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLineTo_castOut"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 276, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLineTo_castOut"});
		}
	}
	,testLineLineTo_castAway: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastAway();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 284, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLineTo_castAway"});
			var dst = new iodev_geom2_Vec();
			iodev_geom2_intersec_LineIntersec.lineLineTo(dst,new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 295, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLineTo_castAway"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 296, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLineTo_castAway"});
		}
	}
	,testLineLineTo_parallel: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forParallel();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 304, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLineTo_parallel"});
			var dst = new iodev_geom2_Vec();
			iodev_geom2_intersec_LineIntersec.lineLineTo(dst,new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 315, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLineTo_parallel"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 316, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineLineTo_parallel"});
		}
	}
	,testLineRay_cross: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCross();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 329, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRay_cross"});
			var dst = iodev_geom2_intersec_LineIntersec.lineRay(new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isNotNull(dst,{ fileName : "LineIntersecTest.hx", lineNumber : 338, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRay_cross"});
			if(dst != null) {
				MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 340, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRay_cross"});
				MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 341, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRay_cross"});
			}
		}
	}
	,testLineRay_touch: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forTouch();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 350, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRay_touch"});
			var dst = iodev_geom2_intersec_LineIntersec.lineRay(new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isNotNull(dst,{ fileName : "LineIntersecTest.hx", lineNumber : 359, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRay_touch"});
			if(dst != null) {
				MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 361, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRay_touch"});
				MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 362, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRay_touch"});
			}
		}
	}
	,testLineRay_projectIn_ba: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forProjectIn();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 371, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRay_projectIn_ba"});
			var dst = iodev_geom2_intersec_LineIntersec.lineRay(new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0),new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0));
			massive_munit_Assert.isNotNull(dst,{ fileName : "LineIntersecTest.hx", lineNumber : 380, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRay_projectIn_ba"});
			if(dst != null) {
				MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 382, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRay_projectIn_ba"});
				MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 383, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRay_projectIn_ba"});
			}
		}
	}
	,testLineRay_projectOut_ba: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forProjectOut();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 392, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRay_projectOut_ba"});
			var dst = iodev_geom2_intersec_LineIntersec.lineRay(new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0),new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0));
			massive_munit_Assert.isNull(dst,{ fileName : "LineIntersecTest.hx", lineNumber : 401, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRay_projectOut_ba"});
			if(dst != null) {
				MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 403, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRay_projectOut_ba"});
				MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 404, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRay_projectOut_ba"});
			}
		}
	}
	,testLineRay_castIn: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastIn();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 413, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRay_castIn"});
			var dst = iodev_geom2_intersec_LineIntersec.lineRay(new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isNotNull(dst,{ fileName : "LineIntersecTest.hx", lineNumber : 422, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRay_castIn"});
			if(dst != null) {
				MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 424, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRay_castIn"});
				MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 425, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRay_castIn"});
			}
		}
	}
	,testLineRay_castOut_ba: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastOut();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 434, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRay_castOut_ba"});
			var dst = iodev_geom2_intersec_LineIntersec.lineRay(new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0),new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0));
			massive_munit_Assert.isNull(dst,{ fileName : "LineIntersecTest.hx", lineNumber : 443, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRay_castOut_ba"});
			if(dst != null) {
				MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 445, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRay_castOut_ba"});
				MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 446, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRay_castOut_ba"});
			}
		}
	}
	,testLineRay_castAway: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastAway();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 455, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRay_castAway"});
			var dst = iodev_geom2_intersec_LineIntersec.lineRay(new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isNull(dst,{ fileName : "LineIntersecTest.hx", lineNumber : 464, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRay_castAway"});
			if(dst != null) {
				MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 466, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRay_castAway"});
				MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 467, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRay_castAway"});
			}
		}
	}
	,testLineRay_parallel_lite: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forParallel();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 476, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRay_parallel_lite"});
			var dst = iodev_geom2_intersec_LineIntersec.lineRay(new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			if(dst != null) {
				MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 486, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRay_parallel_lite"});
				MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 487, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRay_parallel_lite"});
			}
		}
	}
	,testLineRayTo_cross: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCross();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 500, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRayTo_cross"});
			var dst = new iodev_geom2_Vec();
			var res = iodev_geom2_intersec_LineIntersec.lineRayTo(dst,new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isTrue(res,{ fileName : "LineIntersecTest.hx", lineNumber : 511, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRayTo_cross"});
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 512, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRayTo_cross"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 513, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRayTo_cross"});
		}
	}
	,testLineRayTo_touch: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forTouch();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 521, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRayTo_touch"});
			var dst = new iodev_geom2_Vec();
			var res = iodev_geom2_intersec_LineIntersec.lineRayTo(dst,new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isTrue(res,{ fileName : "LineIntersecTest.hx", lineNumber : 532, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRayTo_touch"});
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 533, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRayTo_touch"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 534, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRayTo_touch"});
		}
	}
	,testLineRayTo_projectIn_ba: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forProjectIn();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 542, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRayTo_projectIn_ba"});
			var dst = new iodev_geom2_Vec();
			var res = iodev_geom2_intersec_LineIntersec.lineRayTo(dst,new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0),new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0));
			massive_munit_Assert.isTrue(res,{ fileName : "LineIntersecTest.hx", lineNumber : 553, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRayTo_projectIn_ba"});
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 554, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRayTo_projectIn_ba"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 555, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRayTo_projectIn_ba"});
		}
	}
	,testLineRayTo_projectOut_ba: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forProjectOut();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 563, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRayTo_projectOut_ba"});
			var dst = new iodev_geom2_Vec();
			var res = iodev_geom2_intersec_LineIntersec.lineRayTo(dst,new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0),new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0));
			massive_munit_Assert.isFalse(res,{ fileName : "LineIntersecTest.hx", lineNumber : 574, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRayTo_projectOut_ba"});
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 575, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRayTo_projectOut_ba"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 576, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRayTo_projectOut_ba"});
		}
	}
	,testLineRayTo_castIn: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastIn();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 584, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRayTo_castIn"});
			var dst = new iodev_geom2_Vec();
			var res = iodev_geom2_intersec_LineIntersec.lineRayTo(dst,new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isTrue(res,{ fileName : "LineIntersecTest.hx", lineNumber : 595, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRayTo_castIn"});
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 596, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRayTo_castIn"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 597, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRayTo_castIn"});
		}
	}
	,testLineRayTo_castOut_ba: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastOut();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 605, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRayTo_castOut_ba"});
			var dst = new iodev_geom2_Vec();
			var res = iodev_geom2_intersec_LineIntersec.lineRayTo(dst,new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0),new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0));
			massive_munit_Assert.isFalse(res,{ fileName : "LineIntersecTest.hx", lineNumber : 616, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRayTo_castOut_ba"});
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 617, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRayTo_castOut_ba"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 618, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRayTo_castOut_ba"});
		}
	}
	,testLineRayTo_castAway: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastAway();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 626, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRayTo_castAway"});
			var dst = new iodev_geom2_Vec();
			var res = iodev_geom2_intersec_LineIntersec.lineRayTo(dst,new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isFalse(res,{ fileName : "LineIntersecTest.hx", lineNumber : 637, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRayTo_castAway"});
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 638, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRayTo_castAway"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 639, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRayTo_castAway"});
		}
	}
	,testLineRayTo_parallel_lite: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forParallel();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 647, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRayTo_parallel_lite"});
			var dst = new iodev_geom2_Vec();
			var res = iodev_geom2_intersec_LineIntersec.lineRayTo(dst,new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			if(res) {
				MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 659, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRayTo_parallel_lite"});
				MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 660, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineRayTo_parallel_lite"});
			}
		}
	}
	,testLineSegm_cross: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCross();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 674, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegm_cross"});
			var dst = iodev_geom2_intersec_LineIntersec.lineSegm(new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isNotNull(dst,{ fileName : "LineIntersecTest.hx", lineNumber : 683, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegm_cross"});
			if(dst != null) {
				MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 685, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegm_cross"});
				MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 686, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegm_cross"});
			}
		}
	}
	,testLineSegm_touch: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forTouch();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 695, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegm_touch"});
			var dst = iodev_geom2_intersec_LineIntersec.lineSegm(new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isNotNull(dst,{ fileName : "LineIntersecTest.hx", lineNumber : 704, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegm_touch"});
			if(dst != null) {
				MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 706, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegm_touch"});
				MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 707, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegm_touch"});
			}
		}
	}
	,testLineSegm_projectIn_ba: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forProjectIn();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 716, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegm_projectIn_ba"});
			var dst = iodev_geom2_intersec_LineIntersec.lineSegm(new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0),new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0));
			massive_munit_Assert.isNull(dst,{ fileName : "LineIntersecTest.hx", lineNumber : 725, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegm_projectIn_ba"});
			if(dst != null) {
				MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 727, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegm_projectIn_ba"});
				MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 728, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegm_projectIn_ba"});
			}
		}
	}
	,testLineSegm_projectOut_ba: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forProjectOut();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 737, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegm_projectOut_ba"});
			var dst = iodev_geom2_intersec_LineIntersec.lineSegm(new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0),new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0));
			massive_munit_Assert.isNull(dst,{ fileName : "LineIntersecTest.hx", lineNumber : 746, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegm_projectOut_ba"});
			if(dst != null) {
				MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 748, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegm_projectOut_ba"});
				MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 749, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegm_projectOut_ba"});
			}
		}
	}
	,testLineSegm_castIn: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastIn();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 758, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegm_castIn"});
			var dst = iodev_geom2_intersec_LineIntersec.lineSegm(new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isNull(dst,{ fileName : "LineIntersecTest.hx", lineNumber : 767, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegm_castIn"});
			if(dst != null) {
				MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 769, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegm_castIn"});
				MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 770, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegm_castIn"});
			}
		}
	}
	,testLineSegm_castOut_ba: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastOut();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 779, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegm_castOut_ba"});
			var dst = iodev_geom2_intersec_LineIntersec.lineSegm(new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0),new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0));
			massive_munit_Assert.isNull(dst,{ fileName : "LineIntersecTest.hx", lineNumber : 788, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegm_castOut_ba"});
			if(dst != null) {
				MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 790, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegm_castOut_ba"});
				MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 791, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegm_castOut_ba"});
			}
		}
	}
	,testLineSegm_castAway: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastAway();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 800, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegm_castAway"});
			var dst = iodev_geom2_intersec_LineIntersec.lineSegm(new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isNull(dst,{ fileName : "LineIntersecTest.hx", lineNumber : 809, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegm_castAway"});
			if(dst != null) {
				MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 811, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegm_castAway"});
				MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 812, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegm_castAway"});
			}
		}
	}
	,testLineSegm_parallel: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forParallel();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 821, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegm_parallel"});
			var dst = iodev_geom2_intersec_LineIntersec.lineSegm(new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isNull(dst,{ fileName : "LineIntersecTest.hx", lineNumber : 830, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegm_parallel"});
			if(dst != null) {
				MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 832, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegm_parallel"});
				MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 833, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegm_parallel"});
			}
		}
	}
	,testLineSegmTo_cross: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCross();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 846, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegmTo_cross"});
			var dst = new iodev_geom2_Vec();
			var res = iodev_geom2_intersec_LineIntersec.lineSegmTo(dst,new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isTrue(res,{ fileName : "LineIntersecTest.hx", lineNumber : 857, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegmTo_cross"});
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 858, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegmTo_cross"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 859, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegmTo_cross"});
		}
	}
	,testLineSegmTo_touch: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forTouch();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 867, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegmTo_touch"});
			var dst = new iodev_geom2_Vec();
			var res = iodev_geom2_intersec_LineIntersec.lineSegmTo(dst,new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isTrue(res,{ fileName : "LineIntersecTest.hx", lineNumber : 878, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegmTo_touch"});
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 879, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegmTo_touch"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 880, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegmTo_touch"});
		}
	}
	,testLineSegmTo_projectIn_ba: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forProjectIn();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 888, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegmTo_projectIn_ba"});
			var dst = new iodev_geom2_Vec();
			var res = iodev_geom2_intersec_LineIntersec.lineSegmTo(dst,new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0),new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0));
			massive_munit_Assert.isFalse(res,{ fileName : "LineIntersecTest.hx", lineNumber : 899, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegmTo_projectIn_ba"});
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 900, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegmTo_projectIn_ba"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 901, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegmTo_projectIn_ba"});
		}
	}
	,testLineSegmTo_projectOut_ba: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forProjectOut();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 909, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegmTo_projectOut_ba"});
			var dst = new iodev_geom2_Vec();
			var res = iodev_geom2_intersec_LineIntersec.lineSegmTo(dst,new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0),new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0));
			massive_munit_Assert.isFalse(res,{ fileName : "LineIntersecTest.hx", lineNumber : 920, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegmTo_projectOut_ba"});
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 921, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegmTo_projectOut_ba"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 922, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegmTo_projectOut_ba"});
		}
	}
	,testLineSegmTo_castIn: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastIn();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 930, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegmTo_castIn"});
			var dst = new iodev_geom2_Vec();
			var res = iodev_geom2_intersec_LineIntersec.lineSegmTo(dst,new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isFalse(res,{ fileName : "LineIntersecTest.hx", lineNumber : 941, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegmTo_castIn"});
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 942, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegmTo_castIn"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 943, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegmTo_castIn"});
		}
	}
	,testLineSegmTo_castOut_ba: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastOut();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 951, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegmTo_castOut_ba"});
			var dst = new iodev_geom2_Vec();
			var res = iodev_geom2_intersec_LineIntersec.lineSegmTo(dst,new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0),new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0));
			massive_munit_Assert.isFalse(res,{ fileName : "LineIntersecTest.hx", lineNumber : 962, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegmTo_castOut_ba"});
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 963, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegmTo_castOut_ba"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 964, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegmTo_castOut_ba"});
		}
	}
	,testLineSegmTo_castAway: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastAway();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 972, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegmTo_castAway"});
			var dst = new iodev_geom2_Vec();
			var res = iodev_geom2_intersec_LineIntersec.lineSegmTo(dst,new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isFalse(res,{ fileName : "LineIntersecTest.hx", lineNumber : 983, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegmTo_castAway"});
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 984, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegmTo_castAway"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 985, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegmTo_castAway"});
		}
	}
	,testLineSegmTo_parallel: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forParallel();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 993, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegmTo_parallel"});
			var dst = new iodev_geom2_Vec();
			var res = iodev_geom2_intersec_LineIntersec.lineSegmTo(dst,new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isFalse(res,{ fileName : "LineIntersecTest.hx", lineNumber : 1004, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegmTo_parallel"});
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1005, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegmTo_parallel"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1006, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testLineSegmTo_parallel"});
		}
	}
	,testRayRay_cross: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCross();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1019, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRay_cross"});
			var dst = iodev_geom2_intersec_LineIntersec.rayRay(new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isNotNull(dst,{ fileName : "LineIntersecTest.hx", lineNumber : 1028, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRay_cross"});
			if(dst != null) {
				MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1030, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRay_cross"});
				MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1031, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRay_cross"});
			}
		}
	}
	,testRayRay_touch: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forTouch();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1040, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRay_touch"});
			var dst = iodev_geom2_intersec_LineIntersec.rayRay(new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isNotNull(dst,{ fileName : "LineIntersecTest.hx", lineNumber : 1049, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRay_touch"});
			if(dst != null) {
				MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1051, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRay_touch"});
				MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1052, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRay_touch"});
			}
		}
	}
	,testRayRay_projectIn: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forProjectIn();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1061, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRay_projectIn"});
			var dst = iodev_geom2_intersec_LineIntersec.rayRay(new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isNotNull(dst,{ fileName : "LineIntersecTest.hx", lineNumber : 1070, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRay_projectIn"});
			if(dst != null) {
				MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1072, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRay_projectIn"});
				MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1073, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRay_projectIn"});
			}
		}
	}
	,testRayRay_projectOut: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forProjectOut();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1082, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRay_projectOut"});
			var dst = iodev_geom2_intersec_LineIntersec.rayRay(new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isNull(dst,{ fileName : "LineIntersecTest.hx", lineNumber : 1091, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRay_projectOut"});
			if(dst != null) {
				MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1093, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRay_projectOut"});
				MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1094, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRay_projectOut"});
			}
		}
	}
	,testRayRay_castIn: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastIn();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1103, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRay_castIn"});
			var dst = iodev_geom2_intersec_LineIntersec.rayRay(new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isNotNull(dst,{ fileName : "LineIntersecTest.hx", lineNumber : 1112, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRay_castIn"});
			if(dst != null) {
				MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1114, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRay_castIn"});
				MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1115, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRay_castIn"});
			}
		}
	}
	,testRayRay_castOut: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastOut();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1124, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRay_castOut"});
			var dst = iodev_geom2_intersec_LineIntersec.rayRay(new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isNull(dst,{ fileName : "LineIntersecTest.hx", lineNumber : 1133, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRay_castOut"});
			if(dst != null) {
				MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1135, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRay_castOut"});
				MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1136, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRay_castOut"});
			}
		}
	}
	,testRayRay_castAway: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastAway();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1145, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRay_castAway"});
			var dst = iodev_geom2_intersec_LineIntersec.rayRay(new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isNull(dst,{ fileName : "LineIntersecTest.hx", lineNumber : 1154, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRay_castAway"});
			if(dst != null) {
				MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1156, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRay_castAway"});
				MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1157, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRay_castAway"});
			}
		}
	}
	,testRayRay_parallel_lite: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forParallel();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1166, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRay_parallel_lite"});
			var dst = iodev_geom2_intersec_LineIntersec.rayRay(new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			if(dst != null) {
				MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1176, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRay_parallel_lite"});
				MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1177, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRay_parallel_lite"});
			}
		}
	}
	,testRayRayTo_cross: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCross();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1190, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRayTo_cross"});
			var dst = new iodev_geom2_Vec();
			var res = iodev_geom2_intersec_LineIntersec.rayRayTo(dst,new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isTrue(res,{ fileName : "LineIntersecTest.hx", lineNumber : 1201, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRayTo_cross"});
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1202, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRayTo_cross"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1203, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRayTo_cross"});
		}
	}
	,testRayRayTo_touch: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forTouch();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1211, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRayTo_touch"});
			var dst = new iodev_geom2_Vec();
			var res = iodev_geom2_intersec_LineIntersec.rayRayTo(dst,new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isTrue(res,{ fileName : "LineIntersecTest.hx", lineNumber : 1222, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRayTo_touch"});
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1223, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRayTo_touch"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1224, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRayTo_touch"});
		}
	}
	,testRayRayTo_projectIn: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forProjectIn();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1232, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRayTo_projectIn"});
			var dst = new iodev_geom2_Vec();
			var res = iodev_geom2_intersec_LineIntersec.rayRayTo(dst,new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isTrue(res,{ fileName : "LineIntersecTest.hx", lineNumber : 1243, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRayTo_projectIn"});
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1244, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRayTo_projectIn"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1245, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRayTo_projectIn"});
		}
	}
	,testRayRayTo_projectOut: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forProjectOut();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1253, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRayTo_projectOut"});
			var dst = new iodev_geom2_Vec();
			var res = iodev_geom2_intersec_LineIntersec.rayRayTo(dst,new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isFalse(res,{ fileName : "LineIntersecTest.hx", lineNumber : 1264, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRayTo_projectOut"});
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1265, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRayTo_projectOut"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1266, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRayTo_projectOut"});
		}
	}
	,testRayRayTo_castIn: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastIn();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1274, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRayTo_castIn"});
			var dst = new iodev_geom2_Vec();
			var res = iodev_geom2_intersec_LineIntersec.rayRayTo(dst,new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isTrue(res,{ fileName : "LineIntersecTest.hx", lineNumber : 1285, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRayTo_castIn"});
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1286, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRayTo_castIn"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1287, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRayTo_castIn"});
		}
	}
	,testRayRayTo_castOut: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastOut();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1295, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRayTo_castOut"});
			var dst = new iodev_geom2_Vec();
			var res = iodev_geom2_intersec_LineIntersec.rayRayTo(dst,new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isFalse(res,{ fileName : "LineIntersecTest.hx", lineNumber : 1306, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRayTo_castOut"});
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1307, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRayTo_castOut"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1308, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRayTo_castOut"});
		}
	}
	,testRayRayTo_castAway: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastAway();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1316, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRayTo_castAway"});
			var dst = new iodev_geom2_Vec();
			var res = iodev_geom2_intersec_LineIntersec.rayRayTo(dst,new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isFalse(res,{ fileName : "LineIntersecTest.hx", lineNumber : 1327, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRayTo_castAway"});
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1328, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRayTo_castAway"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1329, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRayTo_castAway"});
		}
	}
	,testRayRayTo_parallel_lite: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forParallel();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1337, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRayTo_parallel_lite"});
			var dst = new iodev_geom2_Vec();
			var res = iodev_geom2_intersec_LineIntersec.rayRayTo(dst,new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			if(res) {
				MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1349, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRayTo_parallel_lite"});
				MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1350, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRayRayTo_parallel_lite"});
			}
		}
	}
	,testRaySegm_cross: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCross();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1364, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegm_cross"});
			var dst = iodev_geom2_intersec_LineIntersec.raySegm(new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isNotNull(dst,{ fileName : "LineIntersecTest.hx", lineNumber : 1373, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegm_cross"});
			if(dst != null) {
				MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1375, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegm_cross"});
				MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1376, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegm_cross"});
			}
		}
	}
	,testRaySegm_touch: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forTouch();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1385, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegm_touch"});
			var dst = iodev_geom2_intersec_LineIntersec.raySegm(new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isNotNull(dst,{ fileName : "LineIntersecTest.hx", lineNumber : 1394, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegm_touch"});
			if(dst != null) {
				MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1396, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegm_touch"});
				MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1397, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegm_touch"});
			}
		}
	}
	,testRaySegm_projectIn: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forProjectIn();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1406, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegm_projectIn"});
			var dst = iodev_geom2_intersec_LineIntersec.raySegm(new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isNotNull(dst,{ fileName : "LineIntersecTest.hx", lineNumber : 1415, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegm_projectIn"});
			if(dst != null) {
				MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1417, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegm_projectIn"});
				MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1418, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegm_projectIn"});
			}
		}
	}
	,testRaySegm_projectOut: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forProjectOut();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1427, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegm_projectOut"});
			var dst = iodev_geom2_intersec_LineIntersec.raySegm(new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isNull(dst,{ fileName : "LineIntersecTest.hx", lineNumber : 1436, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegm_projectOut"});
			if(dst != null) {
				MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1438, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegm_projectOut"});
				MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1439, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegm_projectOut"});
			}
		}
	}
	,testRaySegm_castIn: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastIn();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1448, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegm_castIn"});
			var dst = iodev_geom2_intersec_LineIntersec.raySegm(new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isNull(dst,{ fileName : "LineIntersecTest.hx", lineNumber : 1457, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegm_castIn"});
			if(dst != null) {
				MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1459, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegm_castIn"});
				MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1460, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegm_castIn"});
			}
		}
	}
	,testRaySegm_castOut: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastOut();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1469, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegm_castOut"});
			var dst = iodev_geom2_intersec_LineIntersec.raySegm(new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isNull(dst,{ fileName : "LineIntersecTest.hx", lineNumber : 1478, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegm_castOut"});
			if(dst != null) {
				MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1480, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegm_castOut"});
				MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1481, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegm_castOut"});
			}
		}
	}
	,testRaySegm_castAway: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastAway();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1490, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegm_castAway"});
			var dst = iodev_geom2_intersec_LineIntersec.raySegm(new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isNull(dst,{ fileName : "LineIntersecTest.hx", lineNumber : 1499, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegm_castAway"});
			if(dst != null) {
				MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1501, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegm_castAway"});
				MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1502, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegm_castAway"});
			}
		}
	}
	,testRaySegm_parallel: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forParallel();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1511, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegm_parallel"});
			var dst = iodev_geom2_intersec_LineIntersec.raySegm(new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isNull(dst,{ fileName : "LineIntersecTest.hx", lineNumber : 1520, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegm_parallel"});
			if(dst != null) {
				MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1522, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegm_parallel"});
				MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1523, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegm_parallel"});
			}
		}
	}
	,testRaySegmTo_cross: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCross();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1536, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegmTo_cross"});
			var dst = new iodev_geom2_Vec();
			var res = iodev_geom2_intersec_LineIntersec.raySegmTo(dst,new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isTrue(res,{ fileName : "LineIntersecTest.hx", lineNumber : 1547, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegmTo_cross"});
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1548, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegmTo_cross"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1549, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegmTo_cross"});
		}
	}
	,testRaySegmTo_touch: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forTouch();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1557, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegmTo_touch"});
			var dst = new iodev_geom2_Vec();
			var res = iodev_geom2_intersec_LineIntersec.raySegmTo(dst,new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isTrue(res,{ fileName : "LineIntersecTest.hx", lineNumber : 1568, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegmTo_touch"});
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1569, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegmTo_touch"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1570, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegmTo_touch"});
		}
	}
	,testRaySegmTo_projectIn: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forProjectIn();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1578, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegmTo_projectIn"});
			var dst = new iodev_geom2_Vec();
			var res = iodev_geom2_intersec_LineIntersec.raySegmTo(dst,new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isTrue(res,{ fileName : "LineIntersecTest.hx", lineNumber : 1589, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegmTo_projectIn"});
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1590, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegmTo_projectIn"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1591, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegmTo_projectIn"});
		}
	}
	,testRaySegmTo_projectOut: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forProjectOut();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1599, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegmTo_projectOut"});
			var dst = new iodev_geom2_Vec();
			var res = iodev_geom2_intersec_LineIntersec.raySegmTo(dst,new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isFalse(res,{ fileName : "LineIntersecTest.hx", lineNumber : 1610, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegmTo_projectOut"});
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1611, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegmTo_projectOut"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1612, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegmTo_projectOut"});
		}
	}
	,testRaySegmTo_castIn: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastIn();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1620, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegmTo_castIn"});
			var dst = new iodev_geom2_Vec();
			var res = iodev_geom2_intersec_LineIntersec.raySegmTo(dst,new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isFalse(res,{ fileName : "LineIntersecTest.hx", lineNumber : 1631, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegmTo_castIn"});
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1632, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegmTo_castIn"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1633, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegmTo_castIn"});
		}
	}
	,testRaySegmTo_castOut: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastOut();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1641, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegmTo_castOut"});
			var dst = new iodev_geom2_Vec();
			var res = iodev_geom2_intersec_LineIntersec.raySegmTo(dst,new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isFalse(res,{ fileName : "LineIntersecTest.hx", lineNumber : 1652, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegmTo_castOut"});
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1653, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegmTo_castOut"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1654, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegmTo_castOut"});
		}
	}
	,testRaySegmTo_castAway: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastAway();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1662, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegmTo_castAway"});
			var dst = new iodev_geom2_Vec();
			var res = iodev_geom2_intersec_LineIntersec.raySegmTo(dst,new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isFalse(res,{ fileName : "LineIntersecTest.hx", lineNumber : 1673, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegmTo_castAway"});
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1674, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegmTo_castAway"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1675, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegmTo_castAway"});
		}
	}
	,testRaySegmTo_parallel: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forParallel();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1683, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegmTo_parallel"});
			var dst = new iodev_geom2_Vec();
			var res = iodev_geom2_intersec_LineIntersec.raySegmTo(dst,new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isFalse(res,{ fileName : "LineIntersecTest.hx", lineNumber : 1694, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegmTo_parallel"});
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1695, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegmTo_parallel"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1696, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testRaySegmTo_parallel"});
		}
	}
	,testSegmSegm_cross: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCross();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1709, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegm_cross"});
			var dst = iodev_geom2_intersec_LineIntersec.segmSegm(new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isNotNull(dst,{ fileName : "LineIntersecTest.hx", lineNumber : 1718, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegm_cross"});
			if(dst != null) {
				MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1720, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegm_cross"});
				MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1721, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegm_cross"});
			}
		}
	}
	,testSegmSegm_touch: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forTouch();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1730, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegm_touch"});
			var dst = iodev_geom2_intersec_LineIntersec.segmSegm(new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isNotNull(dst,{ fileName : "LineIntersecTest.hx", lineNumber : 1739, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegm_touch"});
			if(dst != null) {
				MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1741, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegm_touch"});
				MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1742, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegm_touch"});
			}
		}
	}
	,testSegmSegm_projectIn: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forProjectIn();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1751, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegm_projectIn"});
			var dst = iodev_geom2_intersec_LineIntersec.segmSegm(new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isNull(dst,{ fileName : "LineIntersecTest.hx", lineNumber : 1760, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegm_projectIn"});
			if(dst != null) {
				MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1762, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegm_projectIn"});
				MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1763, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegm_projectIn"});
			}
		}
	}
	,testSegmSegm_projectOut: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forProjectOut();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1772, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegm_projectOut"});
			var dst = iodev_geom2_intersec_LineIntersec.segmSegm(new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isNull(dst,{ fileName : "LineIntersecTest.hx", lineNumber : 1781, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegm_projectOut"});
			if(dst != null) {
				MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1783, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegm_projectOut"});
				MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1784, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegm_projectOut"});
			}
		}
	}
	,testSegmSegm_castIn: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastIn();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1793, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegm_castIn"});
			var dst = iodev_geom2_intersec_LineIntersec.segmSegm(new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isNull(dst,{ fileName : "LineIntersecTest.hx", lineNumber : 1802, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegm_castIn"});
			if(dst != null) {
				MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1804, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegm_castIn"});
				MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1805, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegm_castIn"});
			}
		}
	}
	,testSegmSegm_castOut: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastOut();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1814, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegm_castOut"});
			var dst = iodev_geom2_intersec_LineIntersec.segmSegm(new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isNull(dst,{ fileName : "LineIntersecTest.hx", lineNumber : 1823, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegm_castOut"});
			if(dst != null) {
				MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1825, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegm_castOut"});
				MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1826, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegm_castOut"});
			}
		}
	}
	,testSegmSegm_castAway: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastAway();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1835, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegm_castAway"});
			var dst = iodev_geom2_intersec_LineIntersec.segmSegm(new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isNull(dst,{ fileName : "LineIntersecTest.hx", lineNumber : 1844, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegm_castAway"});
			if(dst != null) {
				MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1846, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegm_castAway"});
				MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1847, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegm_castAway"});
			}
		}
	}
	,testSegmSegm_parallel: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forParallel();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1856, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegm_parallel"});
			var dst = iodev_geom2_intersec_LineIntersec.segmSegm(new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isNull(dst,{ fileName : "LineIntersecTest.hx", lineNumber : 1865, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegm_parallel"});
			if(dst != null) {
				MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1867, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegm_parallel"});
				MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1868, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegm_parallel"});
			}
		}
	}
	,testSegmSegmTo_cross: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCross();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1881, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegmTo_cross"});
			var dst = new iodev_geom2_Vec();
			var res = iodev_geom2_intersec_LineIntersec.segmSegmTo(dst,new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isTrue(res,{ fileName : "LineIntersecTest.hx", lineNumber : 1892, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegmTo_cross"});
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1893, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegmTo_cross"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1894, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegmTo_cross"});
		}
	}
	,testSegmSegmTo_touch: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forTouch();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1902, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegmTo_touch"});
			var dst = new iodev_geom2_Vec();
			var res = iodev_geom2_intersec_LineIntersec.segmSegmTo(dst,new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isTrue(res,{ fileName : "LineIntersecTest.hx", lineNumber : 1913, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegmTo_touch"});
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1914, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegmTo_touch"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1915, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegmTo_touch"});
		}
	}
	,testSegmSegmTo_projectIn: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forProjectIn();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1923, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegmTo_projectIn"});
			var dst = new iodev_geom2_Vec();
			var res = iodev_geom2_intersec_LineIntersec.segmSegmTo(dst,new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isFalse(res,{ fileName : "LineIntersecTest.hx", lineNumber : 1934, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegmTo_projectIn"});
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1935, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegmTo_projectIn"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1936, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegmTo_projectIn"});
		}
	}
	,testSegmSegmTo_projectOut: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forProjectOut();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1944, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegmTo_projectOut"});
			var dst = new iodev_geom2_Vec();
			var res = iodev_geom2_intersec_LineIntersec.segmSegmTo(dst,new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isFalse(res,{ fileName : "LineIntersecTest.hx", lineNumber : 1955, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegmTo_projectOut"});
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1956, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegmTo_projectOut"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1957, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegmTo_projectOut"});
		}
	}
	,testSegmSegmTo_castIn: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastIn();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1965, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegmTo_castIn"});
			var dst = new iodev_geom2_Vec();
			var res = iodev_geom2_intersec_LineIntersec.segmSegmTo(dst,new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isFalse(res,{ fileName : "LineIntersecTest.hx", lineNumber : 1976, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegmTo_castIn"});
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1977, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegmTo_castIn"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1978, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegmTo_castIn"});
		}
	}
	,testSegmSegmTo_castOut: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastOut();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 1986, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegmTo_castOut"});
			var dst = new iodev_geom2_Vec();
			var res = iodev_geom2_intersec_LineIntersec.segmSegmTo(dst,new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isFalse(res,{ fileName : "LineIntersecTest.hx", lineNumber : 1997, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegmTo_castOut"});
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 1998, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegmTo_castOut"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 1999, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegmTo_castOut"});
		}
	}
	,testSegmSegmTo_castAway: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastAway();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 2007, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegmTo_castAway"});
			var dst = new iodev_geom2_Vec();
			var res = iodev_geom2_intersec_LineIntersec.segmSegmTo(dst,new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isFalse(res,{ fileName : "LineIntersecTest.hx", lineNumber : 2018, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegmTo_castAway"});
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 2019, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegmTo_castAway"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 2020, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegmTo_castAway"});
		}
	}
	,testSegmSegmTo_parallel: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forParallel();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecTest.hx", lineNumber : 2028, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegmTo_parallel"});
			var dst = new iodev_geom2_Vec();
			var res = iodev_geom2_intersec_LineIntersec.segmSegmTo(dst,new iodev_geom2_Vec(data1.ax0,data1.ay0),new iodev_geom2_Vec(data1.ax1 - data1.ax0,data1.ay1 - data1.ay0),new iodev_geom2_Vec(data1.bx0,data1.by0),new iodev_geom2_Vec(data1.bx1 - data1.bx0,data1.by1 - data1.by0));
			massive_munit_Assert.isFalse(res,{ fileName : "LineIntersecTest.hx", lineNumber : 2039, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegmTo_parallel"});
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "LineIntersecTest.hx", lineNumber : 2040, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegmTo_parallel"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "LineIntersecTest.hx", lineNumber : 2041, className : "iodev.geom2.intersec.LineIntersecTest", methodName : "testSegmSegmTo_parallel"});
		}
	}
	,__class__: iodev_geom2_intersec_LineIntersecTest
};
var iodev_geom2_macros_CircleIntersecMacros = function() { };
$hxClasses["iodev.geom2.macros.CircleIntersecMacros"] = iodev_geom2_macros_CircleIntersecMacros;
iodev_geom2_macros_CircleIntersecMacros.__name__ = ["iodev","geom2","macros","CircleIntersecMacros"];
var iodev_geom2_macros_CircleIntersecMacrosTest = function() { };
$hxClasses["iodev.geom2.macros.CircleIntersecMacrosTest"] = iodev_geom2_macros_CircleIntersecMacrosTest;
iodev_geom2_macros_CircleIntersecMacrosTest.__name__ = ["iodev","geom2","macros","CircleIntersecMacrosTest"];
iodev_geom2_macros_CircleIntersecMacrosTest.prototype = {
	testCircleLine_crossFull: function() {
		var _g = 0;
		var _g1 = data_CircleIntersecTestData.forCrossFull();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 14, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_crossFull"});
			var dstax;
			var dstay;
			var dstbx;
			var dstby;
			var dstcount;
			var lvx = data1.lx1 - data1.lx0;
			var lvy = data1.ly1 - data1.ly0;
			var lvmag = lvx * lvx + lvy * lvy;
			var cvx = data1.cx - data1.lx0;
			var cvy = data1.cy - data1.ly0;
			var m = (lvx * cvx + lvy * cvy) / lvmag;
			var pvx = m * lvx;
			var pvy = m * lvy;
			var dmag = data1.crad * data1.crad - ((pvx - cvx) * (pvx - cvx) + (pvy - cvy) * (pvy - cvy));
			if(dmag > 0) {
				var sm = Math.sqrt(dmag / lvmag);
				dstax = data1.lx0 + pvx - sm * lvx;
				dstay = data1.ly0 + pvy - sm * lvy;
				dstbx = data1.lx0 + pvx + sm * lvx;
				dstby = data1.ly0 + pvy + sm * lvy;
				dstcount = 2;
			} else if(dmag == 0) {
				dstbx = data1.lx0 + pvx;
				dstax = dstbx;
				dstby = data1.ly0 + pvy;
				dstay = dstby;
				dstcount = 1;
			} else {
				dstbx = NaN;
				dstax = dstbx;
				dstby = NaN;
				dstay = dstby;
				dstcount = 0;
			}
			massive_munit_Assert.areEqual(2,dstcount,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 23, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_crossFull"});
			MathAssert.floatEqual(data1.dstax,dstax,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 24, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_crossFull"});
			MathAssert.floatEqual(data1.dstay,dstay,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 25, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_crossFull"});
			MathAssert.floatEqual(data1.dstbx,dstbx,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 26, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_crossFull"});
			MathAssert.floatEqual(data1.dstby,dstby,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 27, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_crossFull"});
		}
	}
	,testCircleLine_crossIn: function() {
		var _g = 0;
		var _g1 = data_CircleIntersecTestData.forCrossIn();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 35, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_crossIn"});
			var dstax;
			var dstay;
			var dstbx;
			var dstby;
			var dstcount;
			var lvx = data1.lx1 - data1.lx0;
			var lvy = data1.ly1 - data1.ly0;
			var lvmag = lvx * lvx + lvy * lvy;
			var cvx = data1.cx - data1.lx0;
			var cvy = data1.cy - data1.ly0;
			var m = (lvx * cvx + lvy * cvy) / lvmag;
			var pvx = m * lvx;
			var pvy = m * lvy;
			var dmag = data1.crad * data1.crad - ((pvx - cvx) * (pvx - cvx) + (pvy - cvy) * (pvy - cvy));
			if(dmag > 0) {
				var sm = Math.sqrt(dmag / lvmag);
				dstax = data1.lx0 + pvx - sm * lvx;
				dstay = data1.ly0 + pvy - sm * lvy;
				dstbx = data1.lx0 + pvx + sm * lvx;
				dstby = data1.ly0 + pvy + sm * lvy;
				dstcount = 2;
			} else if(dmag == 0) {
				dstbx = data1.lx0 + pvx;
				dstax = dstbx;
				dstby = data1.ly0 + pvy;
				dstay = dstby;
				dstcount = 1;
			} else {
				dstbx = NaN;
				dstax = dstbx;
				dstby = NaN;
				dstay = dstby;
				dstcount = 0;
			}
			massive_munit_Assert.areEqual(2,dstcount,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 44, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_crossIn"});
			MathAssert.floatEqual(data1.dstax,dstax,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 45, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_crossIn"});
			MathAssert.floatEqual(data1.dstay,dstay,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 46, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_crossIn"});
			MathAssert.floatEqual(data1.dstbx,dstbx,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 47, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_crossIn"});
			MathAssert.floatEqual(data1.dstby,dstby,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 48, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_crossIn"});
		}
	}
	,testCircleLine_crossOut: function() {
		var _g = 0;
		var _g1 = data_CircleIntersecTestData.forCrossOut();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 56, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_crossOut"});
			var dstax;
			var dstay;
			var dstbx;
			var dstby;
			var dstcount;
			var lvx = data1.lx1 - data1.lx0;
			var lvy = data1.ly1 - data1.ly0;
			var lvmag = lvx * lvx + lvy * lvy;
			var cvx = data1.cx - data1.lx0;
			var cvy = data1.cy - data1.ly0;
			var m = (lvx * cvx + lvy * cvy) / lvmag;
			var pvx = m * lvx;
			var pvy = m * lvy;
			var dmag = data1.crad * data1.crad - ((pvx - cvx) * (pvx - cvx) + (pvy - cvy) * (pvy - cvy));
			if(dmag > 0) {
				var sm = Math.sqrt(dmag / lvmag);
				dstax = data1.lx0 + pvx - sm * lvx;
				dstay = data1.ly0 + pvy - sm * lvy;
				dstbx = data1.lx0 + pvx + sm * lvx;
				dstby = data1.ly0 + pvy + sm * lvy;
				dstcount = 2;
			} else if(dmag == 0) {
				dstbx = data1.lx0 + pvx;
				dstax = dstbx;
				dstby = data1.ly0 + pvy;
				dstay = dstby;
				dstcount = 1;
			} else {
				dstbx = NaN;
				dstax = dstbx;
				dstby = NaN;
				dstay = dstby;
				dstcount = 0;
			}
			massive_munit_Assert.areEqual(2,dstcount,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 65, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_crossOut"});
			MathAssert.floatEqual(data1.dstax,dstax,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 66, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_crossOut"});
			MathAssert.floatEqual(data1.dstay,dstay,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 67, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_crossOut"});
			MathAssert.floatEqual(data1.dstbx,dstbx,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 68, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_crossOut"});
			MathAssert.floatEqual(data1.dstby,dstby,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 69, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_crossOut"});
		}
	}
	,testCircleLine_inside: function() {
		var _g = 0;
		var _g1 = data_CircleIntersecTestData.forInside();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 77, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_inside"});
			var dstax;
			var dstay;
			var dstbx;
			var dstby;
			var dstcount;
			var lvx = data1.lx1 - data1.lx0;
			var lvy = data1.ly1 - data1.ly0;
			var lvmag = lvx * lvx + lvy * lvy;
			var cvx = data1.cx - data1.lx0;
			var cvy = data1.cy - data1.ly0;
			var m = (lvx * cvx + lvy * cvy) / lvmag;
			var pvx = m * lvx;
			var pvy = m * lvy;
			var dmag = data1.crad * data1.crad - ((pvx - cvx) * (pvx - cvx) + (pvy - cvy) * (pvy - cvy));
			if(dmag > 0) {
				var sm = Math.sqrt(dmag / lvmag);
				dstax = data1.lx0 + pvx - sm * lvx;
				dstay = data1.ly0 + pvy - sm * lvy;
				dstbx = data1.lx0 + pvx + sm * lvx;
				dstby = data1.ly0 + pvy + sm * lvy;
				dstcount = 2;
			} else if(dmag == 0) {
				dstbx = data1.lx0 + pvx;
				dstax = dstbx;
				dstby = data1.ly0 + pvy;
				dstay = dstby;
				dstcount = 1;
			} else {
				dstbx = NaN;
				dstax = dstbx;
				dstby = NaN;
				dstay = dstby;
				dstcount = 0;
			}
			massive_munit_Assert.areEqual(2,dstcount,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 86, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_inside"});
			MathAssert.floatEqual(data1.dstax,dstax,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 87, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_inside"});
			MathAssert.floatEqual(data1.dstay,dstay,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 88, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_inside"});
			MathAssert.floatEqual(data1.dstbx,dstbx,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 89, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_inside"});
			MathAssert.floatEqual(data1.dstby,dstby,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 90, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_inside"});
		}
	}
	,testCircleLine_touch: function() {
		var _g = 0;
		var _g1 = data_CircleIntersecTestData.forTouch();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 98, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_touch"});
			var dstax;
			var dstay;
			var dstbx;
			var dstby;
			var dstcount;
			var lvx = data1.lx1 - data1.lx0;
			var lvy = data1.ly1 - data1.ly0;
			var lvmag = lvx * lvx + lvy * lvy;
			var cvx = data1.cx - data1.lx0;
			var cvy = data1.cy - data1.ly0;
			var m = (lvx * cvx + lvy * cvy) / lvmag;
			var pvx = m * lvx;
			var pvy = m * lvy;
			var dmag = data1.crad * data1.crad - ((pvx - cvx) * (pvx - cvx) + (pvy - cvy) * (pvy - cvy));
			if(dmag > 0) {
				var sm = Math.sqrt(dmag / lvmag);
				dstax = data1.lx0 + pvx - sm * lvx;
				dstay = data1.ly0 + pvy - sm * lvy;
				dstbx = data1.lx0 + pvx + sm * lvx;
				dstby = data1.ly0 + pvy + sm * lvy;
				dstcount = 2;
			} else if(dmag == 0) {
				dstbx = data1.lx0 + pvx;
				dstax = dstbx;
				dstby = data1.ly0 + pvy;
				dstay = dstby;
				dstcount = 1;
			} else {
				dstbx = NaN;
				dstax = dstbx;
				dstby = NaN;
				dstay = dstby;
				dstcount = 0;
			}
			massive_munit_Assert.areEqual(2,dstcount,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 107, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_touch"});
			MathAssert.floatEqual(data1.dstax,dstax,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 108, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_touch"});
			MathAssert.floatEqual(data1.dstay,dstay,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 109, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_touch"});
			MathAssert.floatEqual(data1.dstbx,dstbx,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 110, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_touch"});
			MathAssert.floatEqual(data1.dstby,dstby,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 111, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_touch"});
		}
	}
	,testCircleLine_tangentIn: function() {
		var _g = 0;
		var _g1 = data_CircleIntersecTestData.forTangentIn();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 119, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_tangentIn"});
			var dstax;
			var dstay;
			var dstbx;
			var dstby;
			var dstcount;
			var lvx = data1.lx1 - data1.lx0;
			var lvy = data1.ly1 - data1.ly0;
			var lvmag = lvx * lvx + lvy * lvy;
			var cvx = data1.cx - data1.lx0;
			var cvy = data1.cy - data1.ly0;
			var m = (lvx * cvx + lvy * cvy) / lvmag;
			var pvx = m * lvx;
			var pvy = m * lvy;
			var dmag = data1.crad * data1.crad - ((pvx - cvx) * (pvx - cvx) + (pvy - cvy) * (pvy - cvy));
			if(dmag > 0) {
				var sm = Math.sqrt(dmag / lvmag);
				dstax = data1.lx0 + pvx - sm * lvx;
				dstay = data1.ly0 + pvy - sm * lvy;
				dstbx = data1.lx0 + pvx + sm * lvx;
				dstby = data1.ly0 + pvy + sm * lvy;
				dstcount = 2;
			} else if(dmag == 0) {
				dstbx = data1.lx0 + pvx;
				dstax = dstbx;
				dstby = data1.ly0 + pvy;
				dstay = dstby;
				dstcount = 1;
			} else {
				dstbx = NaN;
				dstax = dstbx;
				dstby = NaN;
				dstay = dstby;
				dstcount = 0;
			}
			massive_munit_Assert.areEqual(1,dstcount,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 128, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_tangentIn"});
			MathAssert.floatEqual(data1.dstax,dstax,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 129, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_tangentIn"});
			MathAssert.floatEqual(data1.dstay,dstay,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 130, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_tangentIn"});
			MathAssert.floatEqual(data1.dstbx,dstbx,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 131, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_tangentIn"});
			MathAssert.floatEqual(data1.dstby,dstby,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 132, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_tangentIn"});
		}
	}
	,testCircleLine_tangentOut: function() {
		var _g = 0;
		var _g1 = data_CircleIntersecTestData.forTangentOut();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 140, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_tangentOut"});
			var dstax;
			var dstay;
			var dstbx;
			var dstby;
			var dstcount;
			var lvx = data1.lx1 - data1.lx0;
			var lvy = data1.ly1 - data1.ly0;
			var lvmag = lvx * lvx + lvy * lvy;
			var cvx = data1.cx - data1.lx0;
			var cvy = data1.cy - data1.ly0;
			var m = (lvx * cvx + lvy * cvy) / lvmag;
			var pvx = m * lvx;
			var pvy = m * lvy;
			var dmag = data1.crad * data1.crad - ((pvx - cvx) * (pvx - cvx) + (pvy - cvy) * (pvy - cvy));
			if(dmag > 0) {
				var sm = Math.sqrt(dmag / lvmag);
				dstax = data1.lx0 + pvx - sm * lvx;
				dstay = data1.ly0 + pvy - sm * lvy;
				dstbx = data1.lx0 + pvx + sm * lvx;
				dstby = data1.ly0 + pvy + sm * lvy;
				dstcount = 2;
			} else if(dmag == 0) {
				dstbx = data1.lx0 + pvx;
				dstax = dstbx;
				dstby = data1.ly0 + pvy;
				dstay = dstby;
				dstcount = 1;
			} else {
				dstbx = NaN;
				dstax = dstbx;
				dstby = NaN;
				dstay = dstby;
				dstcount = 0;
			}
			massive_munit_Assert.areEqual(1,dstcount,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 149, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_tangentOut"});
			MathAssert.floatEqual(data1.dstax,dstax,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 150, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_tangentOut"});
			MathAssert.floatEqual(data1.dstay,dstay,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 151, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_tangentOut"});
			MathAssert.floatEqual(data1.dstbx,dstbx,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 152, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_tangentOut"});
			MathAssert.floatEqual(data1.dstby,dstby,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 153, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_tangentOut"});
		}
	}
	,testCircleLine_projectIn: function() {
		var _g = 0;
		var _g1 = data_CircleIntersecTestData.forProjectIn();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 161, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_projectIn"});
			var dstax;
			var dstay;
			var dstbx;
			var dstby;
			var dstcount;
			var lvx = data1.lx1 - data1.lx0;
			var lvy = data1.ly1 - data1.ly0;
			var lvmag = lvx * lvx + lvy * lvy;
			var cvx = data1.cx - data1.lx0;
			var cvy = data1.cy - data1.ly0;
			var m = (lvx * cvx + lvy * cvy) / lvmag;
			var pvx = m * lvx;
			var pvy = m * lvy;
			var dmag = data1.crad * data1.crad - ((pvx - cvx) * (pvx - cvx) + (pvy - cvy) * (pvy - cvy));
			if(dmag > 0) {
				var sm = Math.sqrt(dmag / lvmag);
				dstax = data1.lx0 + pvx - sm * lvx;
				dstay = data1.ly0 + pvy - sm * lvy;
				dstbx = data1.lx0 + pvx + sm * lvx;
				dstby = data1.ly0 + pvy + sm * lvy;
				dstcount = 2;
			} else if(dmag == 0) {
				dstbx = data1.lx0 + pvx;
				dstax = dstbx;
				dstby = data1.ly0 + pvy;
				dstay = dstby;
				dstcount = 1;
			} else {
				dstbx = NaN;
				dstax = dstbx;
				dstby = NaN;
				dstay = dstby;
				dstcount = 0;
			}
			massive_munit_Assert.areEqual(2,dstcount,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 170, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_projectIn"});
			MathAssert.floatEqual(data1.dstax,dstax,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 171, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_projectIn"});
			MathAssert.floatEqual(data1.dstay,dstay,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 172, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_projectIn"});
			MathAssert.floatEqual(data1.dstbx,dstbx,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 173, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_projectIn"});
			MathAssert.floatEqual(data1.dstby,dstby,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 174, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_projectIn"});
		}
	}
	,testCircleLine_projectOut: function() {
		var _g = 0;
		var _g1 = data_CircleIntersecTestData.forProjectOut();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 182, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_projectOut"});
			var dstax;
			var dstay;
			var dstbx;
			var dstby;
			var dstcount;
			var lvx = data1.lx1 - data1.lx0;
			var lvy = data1.ly1 - data1.ly0;
			var lvmag = lvx * lvx + lvy * lvy;
			var cvx = data1.cx - data1.lx0;
			var cvy = data1.cy - data1.ly0;
			var m = (lvx * cvx + lvy * cvy) / lvmag;
			var pvx = m * lvx;
			var pvy = m * lvy;
			var dmag = data1.crad * data1.crad - ((pvx - cvx) * (pvx - cvx) + (pvy - cvy) * (pvy - cvy));
			if(dmag > 0) {
				var sm = Math.sqrt(dmag / lvmag);
				dstax = data1.lx0 + pvx - sm * lvx;
				dstay = data1.ly0 + pvy - sm * lvy;
				dstbx = data1.lx0 + pvx + sm * lvx;
				dstby = data1.ly0 + pvy + sm * lvy;
				dstcount = 2;
			} else if(dmag == 0) {
				dstbx = data1.lx0 + pvx;
				dstax = dstbx;
				dstby = data1.ly0 + pvy;
				dstay = dstby;
				dstcount = 1;
			} else {
				dstbx = NaN;
				dstax = dstbx;
				dstby = NaN;
				dstay = dstby;
				dstcount = 0;
			}
			massive_munit_Assert.areEqual(2,dstcount,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 191, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_projectOut"});
			MathAssert.floatEqual(data1.dstax,dstax,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 192, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_projectOut"});
			MathAssert.floatEqual(data1.dstay,dstay,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 193, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_projectOut"});
			MathAssert.floatEqual(data1.dstbx,dstbx,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 194, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_projectOut"});
			MathAssert.floatEqual(data1.dstby,dstby,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 195, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_projectOut"});
		}
	}
	,testCircleLine_none: function() {
		var _g = 0;
		var _g1 = data_CircleIntersecTestData.forNone();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 203, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_none"});
			var dstax;
			var dstay;
			var dstbx;
			var dstby;
			var dstcount;
			var lvx = data1.lx1 - data1.lx0;
			var lvy = data1.ly1 - data1.ly0;
			var lvmag = lvx * lvx + lvy * lvy;
			var cvx = data1.cx - data1.lx0;
			var cvy = data1.cy - data1.ly0;
			var m = (lvx * cvx + lvy * cvy) / lvmag;
			var pvx = m * lvx;
			var pvy = m * lvy;
			var dmag = data1.crad * data1.crad - ((pvx - cvx) * (pvx - cvx) + (pvy - cvy) * (pvy - cvy));
			if(dmag > 0) {
				var sm = Math.sqrt(dmag / lvmag);
				dstax = data1.lx0 + pvx - sm * lvx;
				dstay = data1.ly0 + pvy - sm * lvy;
				dstbx = data1.lx0 + pvx + sm * lvx;
				dstby = data1.ly0 + pvy + sm * lvy;
				dstcount = 2;
			} else if(dmag == 0) {
				dstbx = data1.lx0 + pvx;
				dstax = dstbx;
				dstby = data1.ly0 + pvy;
				dstay = dstby;
				dstcount = 1;
			} else {
				dstbx = NaN;
				dstax = dstbx;
				dstby = NaN;
				dstay = dstby;
				dstcount = 0;
			}
			massive_munit_Assert.areEqual(0,dstcount,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 212, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_none"});
			MathAssert.floatEqual(data1.dstax,dstax,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 213, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_none"});
			MathAssert.floatEqual(data1.dstay,dstay,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 214, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_none"});
			MathAssert.floatEqual(data1.dstbx,dstbx,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 215, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_none"});
			MathAssert.floatEqual(data1.dstby,dstby,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 216, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleLine_none"});
		}
	}
	,testCircleRay_crossFull: function() {
		var _g = 0;
		var _g1 = data_CircleIntersecTestData.forCrossFull();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 228, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_crossFull"});
			var dstax;
			var dstay;
			var dstbx;
			var dstby;
			var dstcount;
			var lvx = data1.lx1 - data1.lx0;
			var lvy = data1.ly1 - data1.ly0;
			var lvmag = lvx * lvx + lvy * lvy;
			var cvx = data1.cx - data1.lx0;
			var cvy = data1.cy - data1.ly0;
			var m = (lvx * cvx + lvy * cvy) / lvmag;
			var pvx = m * lvx;
			var pvy = m * lvy;
			var dmag = data1.crad * data1.crad - ((pvx - cvx) * (pvx - cvx) + (pvy - cvy) * (pvy - cvy));
			if(dmag > 0) {
				var sm = Math.sqrt(dmag / lvmag);
				dstax = data1.lx0 + pvx - sm * lvx;
				dstay = data1.ly0 + pvy - sm * lvy;
				dstbx = data1.lx0 + pvx + sm * lvx;
				dstby = data1.ly0 + pvy + sm * lvy;
				dstcount = 2;
			} else if(dmag == 0) {
				dstbx = data1.lx0 + pvx;
				dstax = dstbx;
				dstby = data1.ly0 + pvy;
				dstay = dstby;
				dstcount = 1;
			} else {
				dstbx = NaN;
				dstax = dstbx;
				dstby = NaN;
				dstay = dstby;
				dstcount = 0;
			}
			if(dstcount > 0 && !((data1.lx1 - data1.lx0) * (dstbx - data1.lx0) + (data1.ly1 - data1.ly0) * (dstby - data1.ly0) >= 0)) {
				--dstcount;
				dstbx = dstax;
				dstby = dstay;
			}
			if(dstcount > 0 && !((data1.lx1 - data1.lx0) * (dstax - data1.lx0) + (data1.ly1 - data1.ly0) * (dstay - data1.ly0) >= 0)) {
				--dstcount;
				dstax = dstbx;
				dstay = dstby;
			}
			massive_munit_Assert.areEqual(2,dstcount,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 237, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_crossFull"});
			MathAssert.floatEqual(data1.dstax,dstax,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 238, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_crossFull"});
			MathAssert.floatEqual(data1.dstay,dstay,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 239, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_crossFull"});
			MathAssert.floatEqual(data1.dstbx,dstbx,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 240, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_crossFull"});
			MathAssert.floatEqual(data1.dstby,dstby,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 241, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_crossFull"});
		}
	}
	,testCircleRay_crossIn: function() {
		var _g = 0;
		var _g1 = data_CircleIntersecTestData.forCrossIn();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 249, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_crossIn"});
			var dstax;
			var dstay;
			var dstbx;
			var dstby;
			var dstcount;
			var lvx = data1.lx1 - data1.lx0;
			var lvy = data1.ly1 - data1.ly0;
			var lvmag = lvx * lvx + lvy * lvy;
			var cvx = data1.cx - data1.lx0;
			var cvy = data1.cy - data1.ly0;
			var m = (lvx * cvx + lvy * cvy) / lvmag;
			var pvx = m * lvx;
			var pvy = m * lvy;
			var dmag = data1.crad * data1.crad - ((pvx - cvx) * (pvx - cvx) + (pvy - cvy) * (pvy - cvy));
			if(dmag > 0) {
				var sm = Math.sqrt(dmag / lvmag);
				dstax = data1.lx0 + pvx - sm * lvx;
				dstay = data1.ly0 + pvy - sm * lvy;
				dstbx = data1.lx0 + pvx + sm * lvx;
				dstby = data1.ly0 + pvy + sm * lvy;
				dstcount = 2;
			} else if(dmag == 0) {
				dstbx = data1.lx0 + pvx;
				dstax = dstbx;
				dstby = data1.ly0 + pvy;
				dstay = dstby;
				dstcount = 1;
			} else {
				dstbx = NaN;
				dstax = dstbx;
				dstby = NaN;
				dstay = dstby;
				dstcount = 0;
			}
			if(dstcount > 0 && !((data1.lx1 - data1.lx0) * (dstbx - data1.lx0) + (data1.ly1 - data1.ly0) * (dstby - data1.ly0) >= 0)) {
				--dstcount;
				dstbx = dstax;
				dstby = dstay;
			}
			if(dstcount > 0 && !((data1.lx1 - data1.lx0) * (dstax - data1.lx0) + (data1.ly1 - data1.ly0) * (dstay - data1.ly0) >= 0)) {
				--dstcount;
				dstax = dstbx;
				dstay = dstby;
			}
			massive_munit_Assert.areEqual(2,dstcount,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 258, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_crossIn"});
			MathAssert.floatEqual(data1.dstax,dstax,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 259, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_crossIn"});
			MathAssert.floatEqual(data1.dstay,dstay,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 260, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_crossIn"});
			MathAssert.floatEqual(data1.dstbx,dstbx,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 261, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_crossIn"});
			MathAssert.floatEqual(data1.dstby,dstby,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 262, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_crossIn"});
		}
	}
	,testCircleRay_crossOut: function() {
		var _g = 0;
		var _g1 = data_CircleIntersecTestData.forCrossOut();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 270, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_crossOut"});
			var dstax;
			var dstay;
			var dstbx;
			var dstby;
			var dstcount;
			var lvx = data1.lx1 - data1.lx0;
			var lvy = data1.ly1 - data1.ly0;
			var lvmag = lvx * lvx + lvy * lvy;
			var cvx = data1.cx - data1.lx0;
			var cvy = data1.cy - data1.ly0;
			var m = (lvx * cvx + lvy * cvy) / lvmag;
			var pvx = m * lvx;
			var pvy = m * lvy;
			var dmag = data1.crad * data1.crad - ((pvx - cvx) * (pvx - cvx) + (pvy - cvy) * (pvy - cvy));
			if(dmag > 0) {
				var sm = Math.sqrt(dmag / lvmag);
				dstax = data1.lx0 + pvx - sm * lvx;
				dstay = data1.ly0 + pvy - sm * lvy;
				dstbx = data1.lx0 + pvx + sm * lvx;
				dstby = data1.ly0 + pvy + sm * lvy;
				dstcount = 2;
			} else if(dmag == 0) {
				dstbx = data1.lx0 + pvx;
				dstax = dstbx;
				dstby = data1.ly0 + pvy;
				dstay = dstby;
				dstcount = 1;
			} else {
				dstbx = NaN;
				dstax = dstbx;
				dstby = NaN;
				dstay = dstby;
				dstcount = 0;
			}
			if(dstcount > 0 && !((data1.lx1 - data1.lx0) * (dstbx - data1.lx0) + (data1.ly1 - data1.ly0) * (dstby - data1.ly0) >= 0)) {
				--dstcount;
				dstbx = dstax;
				dstby = dstay;
			}
			if(dstcount > 0 && !((data1.lx1 - data1.lx0) * (dstax - data1.lx0) + (data1.ly1 - data1.ly0) * (dstay - data1.ly0) >= 0)) {
				--dstcount;
				dstax = dstbx;
				dstay = dstby;
			}
			massive_munit_Assert.areEqual(1,dstcount,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 279, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_crossOut"});
			MathAssert.floatEqual(dstax,dstbx,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 280, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_crossOut"});
			MathAssert.floatEqual(dstay,dstby,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 281, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_crossOut"});
			MathAssert.floatEqual(data1.dstbx,dstax,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 282, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_crossOut"});
			MathAssert.floatEqual(data1.dstby,dstay,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 283, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_crossOut"});
		}
	}
	,testCircleRay_inside: function() {
		var _g = 0;
		var _g1 = data_CircleIntersecTestData.forInside();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 291, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_inside"});
			var dstax;
			var dstay;
			var dstbx;
			var dstby;
			var dstcount;
			var lvx = data1.lx1 - data1.lx0;
			var lvy = data1.ly1 - data1.ly0;
			var lvmag = lvx * lvx + lvy * lvy;
			var cvx = data1.cx - data1.lx0;
			var cvy = data1.cy - data1.ly0;
			var m = (lvx * cvx + lvy * cvy) / lvmag;
			var pvx = m * lvx;
			var pvy = m * lvy;
			var dmag = data1.crad * data1.crad - ((pvx - cvx) * (pvx - cvx) + (pvy - cvy) * (pvy - cvy));
			if(dmag > 0) {
				var sm = Math.sqrt(dmag / lvmag);
				dstax = data1.lx0 + pvx - sm * lvx;
				dstay = data1.ly0 + pvy - sm * lvy;
				dstbx = data1.lx0 + pvx + sm * lvx;
				dstby = data1.ly0 + pvy + sm * lvy;
				dstcount = 2;
			} else if(dmag == 0) {
				dstbx = data1.lx0 + pvx;
				dstax = dstbx;
				dstby = data1.ly0 + pvy;
				dstay = dstby;
				dstcount = 1;
			} else {
				dstbx = NaN;
				dstax = dstbx;
				dstby = NaN;
				dstay = dstby;
				dstcount = 0;
			}
			if(dstcount > 0 && !((data1.lx1 - data1.lx0) * (dstbx - data1.lx0) + (data1.ly1 - data1.ly0) * (dstby - data1.ly0) >= 0)) {
				--dstcount;
				dstbx = dstax;
				dstby = dstay;
			}
			if(dstcount > 0 && !((data1.lx1 - data1.lx0) * (dstax - data1.lx0) + (data1.ly1 - data1.ly0) * (dstay - data1.ly0) >= 0)) {
				--dstcount;
				dstax = dstbx;
				dstay = dstby;
			}
			massive_munit_Assert.areEqual(1,dstcount,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 300, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_inside"});
			MathAssert.floatEqual(dstax,dstbx,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 301, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_inside"});
			MathAssert.floatEqual(dstay,dstby,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 302, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_inside"});
			MathAssert.floatEqual(data1.dstbx,dstax,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 303, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_inside"});
			MathAssert.floatEqual(data1.dstby,dstay,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 304, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_inside"});
		}
	}
	,testCircleRay_touch: function() {
		var _g = 0;
		var _g1 = data_CircleIntersecTestData.forTouch();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 312, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_touch"});
			var dstax;
			var dstay;
			var dstbx;
			var dstby;
			var dstcount;
			var lvx = data1.lx1 - data1.lx0;
			var lvy = data1.ly1 - data1.ly0;
			var lvmag = lvx * lvx + lvy * lvy;
			var cvx = data1.cx - data1.lx0;
			var cvy = data1.cy - data1.ly0;
			var m = (lvx * cvx + lvy * cvy) / lvmag;
			var pvx = m * lvx;
			var pvy = m * lvy;
			var dmag = data1.crad * data1.crad - ((pvx - cvx) * (pvx - cvx) + (pvy - cvy) * (pvy - cvy));
			if(dmag > 0) {
				var sm = Math.sqrt(dmag / lvmag);
				dstax = data1.lx0 + pvx - sm * lvx;
				dstay = data1.ly0 + pvy - sm * lvy;
				dstbx = data1.lx0 + pvx + sm * lvx;
				dstby = data1.ly0 + pvy + sm * lvy;
				dstcount = 2;
			} else if(dmag == 0) {
				dstbx = data1.lx0 + pvx;
				dstax = dstbx;
				dstby = data1.ly0 + pvy;
				dstay = dstby;
				dstcount = 1;
			} else {
				dstbx = NaN;
				dstax = dstbx;
				dstby = NaN;
				dstay = dstby;
				dstcount = 0;
			}
			if(dstcount > 0 && !((data1.lx1 - data1.lx0) * (dstbx - data1.lx0) + (data1.ly1 - data1.ly0) * (dstby - data1.ly0) >= 0)) {
				--dstcount;
				dstbx = dstax;
				dstby = dstay;
			}
			if(dstcount > 0 && !((data1.lx1 - data1.lx0) * (dstax - data1.lx0) + (data1.ly1 - data1.ly0) * (dstay - data1.ly0) >= 0)) {
				--dstcount;
				dstax = dstbx;
				dstay = dstby;
			}
			massive_munit_Assert.areNotEqual(0,dstcount,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 321, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_touch"});
			if(!MathHelper.floatEqual(data1.dstax,dstax) || !MathHelper.floatEqual(data1.dstay,dstay)) {
				MathAssert.floatEqual(data1.dstbx,dstbx,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 323, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_touch"});
				MathAssert.floatEqual(data1.dstby,dstby,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 324, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_touch"});
			} else {
				MathAssert.floatEqual(data1.dstax,dstax,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 326, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_touch"});
				MathAssert.floatEqual(data1.dstay,dstay,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 327, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_touch"});
			}
		}
	}
	,testCircleRay_tangentIn: function() {
		var _g = 0;
		var _g1 = data_CircleIntersecTestData.forTangentIn();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 336, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_tangentIn"});
			var dstax;
			var dstay;
			var dstbx;
			var dstby;
			var dstcount;
			var lvx = data1.lx1 - data1.lx0;
			var lvy = data1.ly1 - data1.ly0;
			var lvmag = lvx * lvx + lvy * lvy;
			var cvx = data1.cx - data1.lx0;
			var cvy = data1.cy - data1.ly0;
			var m = (lvx * cvx + lvy * cvy) / lvmag;
			var pvx = m * lvx;
			var pvy = m * lvy;
			var dmag = data1.crad * data1.crad - ((pvx - cvx) * (pvx - cvx) + (pvy - cvy) * (pvy - cvy));
			if(dmag > 0) {
				var sm = Math.sqrt(dmag / lvmag);
				dstax = data1.lx0 + pvx - sm * lvx;
				dstay = data1.ly0 + pvy - sm * lvy;
				dstbx = data1.lx0 + pvx + sm * lvx;
				dstby = data1.ly0 + pvy + sm * lvy;
				dstcount = 2;
			} else if(dmag == 0) {
				dstbx = data1.lx0 + pvx;
				dstax = dstbx;
				dstby = data1.ly0 + pvy;
				dstay = dstby;
				dstcount = 1;
			} else {
				dstbx = NaN;
				dstax = dstbx;
				dstby = NaN;
				dstay = dstby;
				dstcount = 0;
			}
			if(dstcount > 0 && !((data1.lx1 - data1.lx0) * (dstbx - data1.lx0) + (data1.ly1 - data1.ly0) * (dstby - data1.ly0) >= 0)) {
				--dstcount;
				dstbx = dstax;
				dstby = dstay;
			}
			if(dstcount > 0 && !((data1.lx1 - data1.lx0) * (dstax - data1.lx0) + (data1.ly1 - data1.ly0) * (dstay - data1.ly0) >= 0)) {
				--dstcount;
				dstax = dstbx;
				dstay = dstby;
			}
			massive_munit_Assert.areEqual(1,dstcount,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 345, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_tangentIn"});
			MathAssert.floatEqual(data1.dstax,dstax,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 346, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_tangentIn"});
			MathAssert.floatEqual(data1.dstay,dstay,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 347, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_tangentIn"});
		}
	}
	,testCircleRay_tangentOut: function() {
		var _g = 0;
		var _g1 = data_CircleIntersecTestData.forTangentOut();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 355, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_tangentOut"});
			var dstax;
			var dstay;
			var dstbx;
			var dstby;
			var dstcount;
			var lvx = data1.lx1 - data1.lx0;
			var lvy = data1.ly1 - data1.ly0;
			var lvmag = lvx * lvx + lvy * lvy;
			var cvx = data1.cx - data1.lx0;
			var cvy = data1.cy - data1.ly0;
			var m = (lvx * cvx + lvy * cvy) / lvmag;
			var pvx = m * lvx;
			var pvy = m * lvy;
			var dmag = data1.crad * data1.crad - ((pvx - cvx) * (pvx - cvx) + (pvy - cvy) * (pvy - cvy));
			if(dmag > 0) {
				var sm = Math.sqrt(dmag / lvmag);
				dstax = data1.lx0 + pvx - sm * lvx;
				dstay = data1.ly0 + pvy - sm * lvy;
				dstbx = data1.lx0 + pvx + sm * lvx;
				dstby = data1.ly0 + pvy + sm * lvy;
				dstcount = 2;
			} else if(dmag == 0) {
				dstbx = data1.lx0 + pvx;
				dstax = dstbx;
				dstby = data1.ly0 + pvy;
				dstay = dstby;
				dstcount = 1;
			} else {
				dstbx = NaN;
				dstax = dstbx;
				dstby = NaN;
				dstay = dstby;
				dstcount = 0;
			}
			if(dstcount > 0 && !((data1.lx1 - data1.lx0) * (dstbx - data1.lx0) + (data1.ly1 - data1.ly0) * (dstby - data1.ly0) >= 0)) {
				--dstcount;
				dstbx = dstax;
				dstby = dstay;
			}
			if(dstcount > 0 && !((data1.lx1 - data1.lx0) * (dstax - data1.lx0) + (data1.ly1 - data1.ly0) * (dstay - data1.ly0) >= 0)) {
				--dstcount;
				dstax = dstbx;
				dstay = dstby;
			}
			massive_munit_Assert.areEqual(0,dstcount,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 364, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_tangentOut"});
		}
	}
	,testCircleRay_projectIn: function() {
		var _g = 0;
		var _g1 = data_CircleIntersecTestData.forProjectIn();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 372, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_projectIn"});
			var dstax;
			var dstay;
			var dstbx;
			var dstby;
			var dstcount;
			var lvx = data1.lx1 - data1.lx0;
			var lvy = data1.ly1 - data1.ly0;
			var lvmag = lvx * lvx + lvy * lvy;
			var cvx = data1.cx - data1.lx0;
			var cvy = data1.cy - data1.ly0;
			var m = (lvx * cvx + lvy * cvy) / lvmag;
			var pvx = m * lvx;
			var pvy = m * lvy;
			var dmag = data1.crad * data1.crad - ((pvx - cvx) * (pvx - cvx) + (pvy - cvy) * (pvy - cvy));
			if(dmag > 0) {
				var sm = Math.sqrt(dmag / lvmag);
				dstax = data1.lx0 + pvx - sm * lvx;
				dstay = data1.ly0 + pvy - sm * lvy;
				dstbx = data1.lx0 + pvx + sm * lvx;
				dstby = data1.ly0 + pvy + sm * lvy;
				dstcount = 2;
			} else if(dmag == 0) {
				dstbx = data1.lx0 + pvx;
				dstax = dstbx;
				dstby = data1.ly0 + pvy;
				dstay = dstby;
				dstcount = 1;
			} else {
				dstbx = NaN;
				dstax = dstbx;
				dstby = NaN;
				dstay = dstby;
				dstcount = 0;
			}
			if(dstcount > 0 && !((data1.lx1 - data1.lx0) * (dstbx - data1.lx0) + (data1.ly1 - data1.ly0) * (dstby - data1.ly0) >= 0)) {
				--dstcount;
				dstbx = dstax;
				dstby = dstay;
			}
			if(dstcount > 0 && !((data1.lx1 - data1.lx0) * (dstax - data1.lx0) + (data1.ly1 - data1.ly0) * (dstay - data1.ly0) >= 0)) {
				--dstcount;
				dstax = dstbx;
				dstay = dstby;
			}
			massive_munit_Assert.areEqual(2,dstcount,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 381, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_projectIn"});
			MathAssert.floatEqual(data1.dstax,dstax,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 382, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_projectIn"});
			MathAssert.floatEqual(data1.dstay,dstay,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 383, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_projectIn"});
			MathAssert.floatEqual(data1.dstbx,dstbx,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 384, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_projectIn"});
			MathAssert.floatEqual(data1.dstby,dstby,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 385, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_projectIn"});
		}
	}
	,testCircleRay_projectOut: function() {
		var _g = 0;
		var _g1 = data_CircleIntersecTestData.forProjectOut();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 393, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_projectOut"});
			var dstax;
			var dstay;
			var dstbx;
			var dstby;
			var dstcount;
			var lvx = data1.lx1 - data1.lx0;
			var lvy = data1.ly1 - data1.ly0;
			var lvmag = lvx * lvx + lvy * lvy;
			var cvx = data1.cx - data1.lx0;
			var cvy = data1.cy - data1.ly0;
			var m = (lvx * cvx + lvy * cvy) / lvmag;
			var pvx = m * lvx;
			var pvy = m * lvy;
			var dmag = data1.crad * data1.crad - ((pvx - cvx) * (pvx - cvx) + (pvy - cvy) * (pvy - cvy));
			if(dmag > 0) {
				var sm = Math.sqrt(dmag / lvmag);
				dstax = data1.lx0 + pvx - sm * lvx;
				dstay = data1.ly0 + pvy - sm * lvy;
				dstbx = data1.lx0 + pvx + sm * lvx;
				dstby = data1.ly0 + pvy + sm * lvy;
				dstcount = 2;
			} else if(dmag == 0) {
				dstbx = data1.lx0 + pvx;
				dstax = dstbx;
				dstby = data1.ly0 + pvy;
				dstay = dstby;
				dstcount = 1;
			} else {
				dstbx = NaN;
				dstax = dstbx;
				dstby = NaN;
				dstay = dstby;
				dstcount = 0;
			}
			if(dstcount > 0 && !((data1.lx1 - data1.lx0) * (dstbx - data1.lx0) + (data1.ly1 - data1.ly0) * (dstby - data1.ly0) >= 0)) {
				--dstcount;
				dstbx = dstax;
				dstby = dstay;
			}
			if(dstcount > 0 && !((data1.lx1 - data1.lx0) * (dstax - data1.lx0) + (data1.ly1 - data1.ly0) * (dstay - data1.ly0) >= 0)) {
				--dstcount;
				dstax = dstbx;
				dstay = dstby;
			}
			massive_munit_Assert.areEqual(0,dstcount,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 402, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_projectOut"});
		}
	}
	,testCircleRay_none: function() {
		var _g = 0;
		var _g1 = data_CircleIntersecTestData.forNone();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 410, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_none"});
			var dstax;
			var dstay;
			var dstbx;
			var dstby;
			var dstcount;
			var lvx = data1.lx1 - data1.lx0;
			var lvy = data1.ly1 - data1.ly0;
			var lvmag = lvx * lvx + lvy * lvy;
			var cvx = data1.cx - data1.lx0;
			var cvy = data1.cy - data1.ly0;
			var m = (lvx * cvx + lvy * cvy) / lvmag;
			var pvx = m * lvx;
			var pvy = m * lvy;
			var dmag = data1.crad * data1.crad - ((pvx - cvx) * (pvx - cvx) + (pvy - cvy) * (pvy - cvy));
			if(dmag > 0) {
				var sm = Math.sqrt(dmag / lvmag);
				dstax = data1.lx0 + pvx - sm * lvx;
				dstay = data1.ly0 + pvy - sm * lvy;
				dstbx = data1.lx0 + pvx + sm * lvx;
				dstby = data1.ly0 + pvy + sm * lvy;
				dstcount = 2;
			} else if(dmag == 0) {
				dstbx = data1.lx0 + pvx;
				dstax = dstbx;
				dstby = data1.ly0 + pvy;
				dstay = dstby;
				dstcount = 1;
			} else {
				dstbx = NaN;
				dstax = dstbx;
				dstby = NaN;
				dstay = dstby;
				dstcount = 0;
			}
			if(dstcount > 0 && !((data1.lx1 - data1.lx0) * (dstbx - data1.lx0) + (data1.ly1 - data1.ly0) * (dstby - data1.ly0) >= 0)) {
				--dstcount;
				dstbx = dstax;
				dstby = dstay;
			}
			if(dstcount > 0 && !((data1.lx1 - data1.lx0) * (dstax - data1.lx0) + (data1.ly1 - data1.ly0) * (dstay - data1.ly0) >= 0)) {
				--dstcount;
				dstax = dstbx;
				dstay = dstby;
			}
			massive_munit_Assert.areEqual(0,dstcount,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 419, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleRay_none"});
		}
	}
	,testCircleSegm_crossFull: function() {
		var _g = 0;
		var _g1 = data_CircleIntersecTestData.forCrossFull();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 431, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleSegm_crossFull"});
			var dstax;
			var dstay;
			var dstbx;
			var dstby;
			var dstcount;
			var lvx = data1.lx1 - data1.lx0;
			var lvy = data1.ly1 - data1.ly0;
			var lvmag = lvx * lvx + lvy * lvy;
			var cvx = data1.cx - data1.lx0;
			var cvy = data1.cy - data1.ly0;
			var m = (lvx * cvx + lvy * cvy) / lvmag;
			var pvx = m * lvx;
			var pvy = m * lvy;
			var dmag = data1.crad * data1.crad - ((pvx - cvx) * (pvx - cvx) + (pvy - cvy) * (pvy - cvy));
			if(dmag > 0) {
				var sm = Math.sqrt(dmag / lvmag);
				dstax = data1.lx0 + pvx - sm * lvx;
				dstay = data1.ly0 + pvy - sm * lvy;
				dstbx = data1.lx0 + pvx + sm * lvx;
				dstby = data1.ly0 + pvy + sm * lvy;
				dstcount = 2;
			} else if(dmag == 0) {
				dstbx = data1.lx0 + pvx;
				dstax = dstbx;
				dstby = data1.ly0 + pvy;
				dstay = dstby;
				dstcount = 1;
			} else {
				dstbx = NaN;
				dstax = dstbx;
				dstby = NaN;
				dstay = dstby;
				dstcount = 0;
			}
			if(dstcount > 0 && !(((data1.lx1 - data1.lx0) * (dstbx - data1.lx0) + (data1.ly1 - data1.ly0) * (dstby - data1.ly0)) * ((data1.lx1 - data1.lx0) * (dstbx - (data1.lx0 + (data1.lx1 - data1.lx0))) + (data1.ly1 - data1.ly0) * (dstby - (data1.ly0 + (data1.ly1 - data1.ly0)))) <= 0)) {
				--dstcount;
				dstbx = dstax;
				dstby = dstay;
			}
			if(dstcount > 0 && !(((data1.lx1 - data1.lx0) * (dstax - data1.lx0) + (data1.ly1 - data1.ly0) * (dstay - data1.ly0)) * ((data1.lx1 - data1.lx0) * (dstax - (data1.lx0 + (data1.lx1 - data1.lx0))) + (data1.ly1 - data1.ly0) * (dstay - (data1.ly0 + (data1.ly1 - data1.ly0)))) <= 0)) {
				--dstcount;
				dstax = dstbx;
				dstay = dstby;
			}
			massive_munit_Assert.areEqual(2,dstcount,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 440, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleSegm_crossFull"});
			MathAssert.floatEqual(data1.dstax,dstax,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 441, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleSegm_crossFull"});
			MathAssert.floatEqual(data1.dstay,dstay,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 442, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleSegm_crossFull"});
			MathAssert.floatEqual(data1.dstbx,dstbx,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 443, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleSegm_crossFull"});
			MathAssert.floatEqual(data1.dstby,dstby,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 444, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleSegm_crossFull"});
		}
	}
	,testCircleSegm_crossIn: function() {
		var _g = 0;
		var _g1 = data_CircleIntersecTestData.forCrossIn();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 452, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleSegm_crossIn"});
			var dstax;
			var dstay;
			var dstbx;
			var dstby;
			var dstcount;
			var lvx = data1.lx1 - data1.lx0;
			var lvy = data1.ly1 - data1.ly0;
			var lvmag = lvx * lvx + lvy * lvy;
			var cvx = data1.cx - data1.lx0;
			var cvy = data1.cy - data1.ly0;
			var m = (lvx * cvx + lvy * cvy) / lvmag;
			var pvx = m * lvx;
			var pvy = m * lvy;
			var dmag = data1.crad * data1.crad - ((pvx - cvx) * (pvx - cvx) + (pvy - cvy) * (pvy - cvy));
			if(dmag > 0) {
				var sm = Math.sqrt(dmag / lvmag);
				dstax = data1.lx0 + pvx - sm * lvx;
				dstay = data1.ly0 + pvy - sm * lvy;
				dstbx = data1.lx0 + pvx + sm * lvx;
				dstby = data1.ly0 + pvy + sm * lvy;
				dstcount = 2;
			} else if(dmag == 0) {
				dstbx = data1.lx0 + pvx;
				dstax = dstbx;
				dstby = data1.ly0 + pvy;
				dstay = dstby;
				dstcount = 1;
			} else {
				dstbx = NaN;
				dstax = dstbx;
				dstby = NaN;
				dstay = dstby;
				dstcount = 0;
			}
			if(dstcount > 0 && !(((data1.lx1 - data1.lx0) * (dstbx - data1.lx0) + (data1.ly1 - data1.ly0) * (dstby - data1.ly0)) * ((data1.lx1 - data1.lx0) * (dstbx - (data1.lx0 + (data1.lx1 - data1.lx0))) + (data1.ly1 - data1.ly0) * (dstby - (data1.ly0 + (data1.ly1 - data1.ly0)))) <= 0)) {
				--dstcount;
				dstbx = dstax;
				dstby = dstay;
			}
			if(dstcount > 0 && !(((data1.lx1 - data1.lx0) * (dstax - data1.lx0) + (data1.ly1 - data1.ly0) * (dstay - data1.ly0)) * ((data1.lx1 - data1.lx0) * (dstax - (data1.lx0 + (data1.lx1 - data1.lx0))) + (data1.ly1 - data1.ly0) * (dstay - (data1.ly0 + (data1.ly1 - data1.ly0)))) <= 0)) {
				--dstcount;
				dstax = dstbx;
				dstay = dstby;
			}
			massive_munit_Assert.areEqual(1,dstcount,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 461, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleSegm_crossIn"});
			MathAssert.floatEqual(dstax,dstbx,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 462, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleSegm_crossIn"});
			MathAssert.floatEqual(dstay,dstby,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 463, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleSegm_crossIn"});
			MathAssert.floatEqual(data1.dstax,dstax,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 464, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleSegm_crossIn"});
			MathAssert.floatEqual(data1.dstay,dstay,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 465, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleSegm_crossIn"});
		}
	}
	,testCircleSegm_crossOut: function() {
		var _g = 0;
		var _g1 = data_CircleIntersecTestData.forCrossOut();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 473, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleSegm_crossOut"});
			var dstax;
			var dstay;
			var dstbx;
			var dstby;
			var dstcount;
			var lvx = data1.lx1 - data1.lx0;
			var lvy = data1.ly1 - data1.ly0;
			var lvmag = lvx * lvx + lvy * lvy;
			var cvx = data1.cx - data1.lx0;
			var cvy = data1.cy - data1.ly0;
			var m = (lvx * cvx + lvy * cvy) / lvmag;
			var pvx = m * lvx;
			var pvy = m * lvy;
			var dmag = data1.crad * data1.crad - ((pvx - cvx) * (pvx - cvx) + (pvy - cvy) * (pvy - cvy));
			if(dmag > 0) {
				var sm = Math.sqrt(dmag / lvmag);
				dstax = data1.lx0 + pvx - sm * lvx;
				dstay = data1.ly0 + pvy - sm * lvy;
				dstbx = data1.lx0 + pvx + sm * lvx;
				dstby = data1.ly0 + pvy + sm * lvy;
				dstcount = 2;
			} else if(dmag == 0) {
				dstbx = data1.lx0 + pvx;
				dstax = dstbx;
				dstby = data1.ly0 + pvy;
				dstay = dstby;
				dstcount = 1;
			} else {
				dstbx = NaN;
				dstax = dstbx;
				dstby = NaN;
				dstay = dstby;
				dstcount = 0;
			}
			if(dstcount > 0 && !(((data1.lx1 - data1.lx0) * (dstbx - data1.lx0) + (data1.ly1 - data1.ly0) * (dstby - data1.ly0)) * ((data1.lx1 - data1.lx0) * (dstbx - (data1.lx0 + (data1.lx1 - data1.lx0))) + (data1.ly1 - data1.ly0) * (dstby - (data1.ly0 + (data1.ly1 - data1.ly0)))) <= 0)) {
				--dstcount;
				dstbx = dstax;
				dstby = dstay;
			}
			if(dstcount > 0 && !(((data1.lx1 - data1.lx0) * (dstax - data1.lx0) + (data1.ly1 - data1.ly0) * (dstay - data1.ly0)) * ((data1.lx1 - data1.lx0) * (dstax - (data1.lx0 + (data1.lx1 - data1.lx0))) + (data1.ly1 - data1.ly0) * (dstay - (data1.ly0 + (data1.ly1 - data1.ly0)))) <= 0)) {
				--dstcount;
				dstax = dstbx;
				dstay = dstby;
			}
			massive_munit_Assert.areEqual(1,dstcount,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 482, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleSegm_crossOut"});
			MathAssert.floatEqual(dstax,dstbx,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 483, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleSegm_crossOut"});
			MathAssert.floatEqual(dstay,dstby,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 484, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleSegm_crossOut"});
			MathAssert.floatEqual(data1.dstbx,dstax,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 485, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleSegm_crossOut"});
			MathAssert.floatEqual(data1.dstby,dstay,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 486, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleSegm_crossOut"});
		}
	}
	,testCircleSegm_inside: function() {
		var _g = 0;
		var _g1 = data_CircleIntersecTestData.forInside();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 494, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleSegm_inside"});
			var dstax;
			var dstay;
			var dstbx;
			var dstby;
			var dstcount;
			var lvx = data1.lx1 - data1.lx0;
			var lvy = data1.ly1 - data1.ly0;
			var lvmag = lvx * lvx + lvy * lvy;
			var cvx = data1.cx - data1.lx0;
			var cvy = data1.cy - data1.ly0;
			var m = (lvx * cvx + lvy * cvy) / lvmag;
			var pvx = m * lvx;
			var pvy = m * lvy;
			var dmag = data1.crad * data1.crad - ((pvx - cvx) * (pvx - cvx) + (pvy - cvy) * (pvy - cvy));
			if(dmag > 0) {
				var sm = Math.sqrt(dmag / lvmag);
				dstax = data1.lx0 + pvx - sm * lvx;
				dstay = data1.ly0 + pvy - sm * lvy;
				dstbx = data1.lx0 + pvx + sm * lvx;
				dstby = data1.ly0 + pvy + sm * lvy;
				dstcount = 2;
			} else if(dmag == 0) {
				dstbx = data1.lx0 + pvx;
				dstax = dstbx;
				dstby = data1.ly0 + pvy;
				dstay = dstby;
				dstcount = 1;
			} else {
				dstbx = NaN;
				dstax = dstbx;
				dstby = NaN;
				dstay = dstby;
				dstcount = 0;
			}
			if(dstcount > 0 && !(((data1.lx1 - data1.lx0) * (dstbx - data1.lx0) + (data1.ly1 - data1.ly0) * (dstby - data1.ly0)) * ((data1.lx1 - data1.lx0) * (dstbx - (data1.lx0 + (data1.lx1 - data1.lx0))) + (data1.ly1 - data1.ly0) * (dstby - (data1.ly0 + (data1.ly1 - data1.ly0)))) <= 0)) {
				--dstcount;
				dstbx = dstax;
				dstby = dstay;
			}
			if(dstcount > 0 && !(((data1.lx1 - data1.lx0) * (dstax - data1.lx0) + (data1.ly1 - data1.ly0) * (dstay - data1.ly0)) * ((data1.lx1 - data1.lx0) * (dstax - (data1.lx0 + (data1.lx1 - data1.lx0))) + (data1.ly1 - data1.ly0) * (dstay - (data1.ly0 + (data1.ly1 - data1.ly0)))) <= 0)) {
				--dstcount;
				dstax = dstbx;
				dstay = dstby;
			}
			massive_munit_Assert.areEqual(0,dstcount,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 503, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleSegm_inside"});
			MathAssert.floatEqual(dstax,dstbx,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 504, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleSegm_inside"});
			MathAssert.floatEqual(dstay,dstby,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 505, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleSegm_inside"});
		}
	}
	,testCircleSegm_touch: function() {
		var _g = 0;
		var _g1 = data_CircleIntersecTestData.forTouch();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 513, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleSegm_touch"});
			var dstax;
			var dstay;
			var dstbx;
			var dstby;
			var dstcount;
			var lvx = data1.lx1 - data1.lx0;
			var lvy = data1.ly1 - data1.ly0;
			var lvmag = lvx * lvx + lvy * lvy;
			var cvx = data1.cx - data1.lx0;
			var cvy = data1.cy - data1.ly0;
			var m = (lvx * cvx + lvy * cvy) / lvmag;
			var pvx = m * lvx;
			var pvy = m * lvy;
			var dmag = data1.crad * data1.crad - ((pvx - cvx) * (pvx - cvx) + (pvy - cvy) * (pvy - cvy));
			if(dmag > 0) {
				var sm = Math.sqrt(dmag / lvmag);
				dstax = data1.lx0 + pvx - sm * lvx;
				dstay = data1.ly0 + pvy - sm * lvy;
				dstbx = data1.lx0 + pvx + sm * lvx;
				dstby = data1.ly0 + pvy + sm * lvy;
				dstcount = 2;
			} else if(dmag == 0) {
				dstbx = data1.lx0 + pvx;
				dstax = dstbx;
				dstby = data1.ly0 + pvy;
				dstay = dstby;
				dstcount = 1;
			} else {
				dstbx = NaN;
				dstax = dstbx;
				dstby = NaN;
				dstay = dstby;
				dstcount = 0;
			}
			if(dstcount > 0 && !(((data1.lx1 - data1.lx0) * (dstbx - data1.lx0) + (data1.ly1 - data1.ly0) * (dstby - data1.ly0)) * ((data1.lx1 - data1.lx0) * (dstbx - (data1.lx0 + (data1.lx1 - data1.lx0))) + (data1.ly1 - data1.ly0) * (dstby - (data1.ly0 + (data1.ly1 - data1.ly0)))) <= 0)) {
				--dstcount;
				dstbx = dstax;
				dstby = dstay;
			}
			if(dstcount > 0 && !(((data1.lx1 - data1.lx0) * (dstax - data1.lx0) + (data1.ly1 - data1.ly0) * (dstay - data1.ly0)) * ((data1.lx1 - data1.lx0) * (dstax - (data1.lx0 + (data1.lx1 - data1.lx0))) + (data1.ly1 - data1.ly0) * (dstay - (data1.ly0 + (data1.ly1 - data1.ly0)))) <= 0)) {
				--dstcount;
				dstax = dstbx;
				dstay = dstby;
			}
			massive_munit_Assert.areEqual(1,dstcount,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 522, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleSegm_touch"});
			if(!MathHelper.floatEqual(data1.dstax,dstax) || !MathHelper.floatEqual(data1.dstay,dstay)) {
				MathAssert.floatEqual(data1.dstbx,dstbx,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 524, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleSegm_touch"});
				MathAssert.floatEqual(data1.dstby,dstby,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 525, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleSegm_touch"});
			} else {
				MathAssert.floatEqual(data1.dstax,dstax,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 527, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleSegm_touch"});
				MathAssert.floatEqual(data1.dstay,dstay,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 528, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleSegm_touch"});
			}
		}
	}
	,testCircleSegm_tangentIn: function() {
		var _g = 0;
		var _g1 = data_CircleIntersecTestData.forTangentIn();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 537, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleSegm_tangentIn"});
			var dstax;
			var dstay;
			var dstbx;
			var dstby;
			var dstcount;
			var lvx = data1.lx1 - data1.lx0;
			var lvy = data1.ly1 - data1.ly0;
			var lvmag = lvx * lvx + lvy * lvy;
			var cvx = data1.cx - data1.lx0;
			var cvy = data1.cy - data1.ly0;
			var m = (lvx * cvx + lvy * cvy) / lvmag;
			var pvx = m * lvx;
			var pvy = m * lvy;
			var dmag = data1.crad * data1.crad - ((pvx - cvx) * (pvx - cvx) + (pvy - cvy) * (pvy - cvy));
			if(dmag > 0) {
				var sm = Math.sqrt(dmag / lvmag);
				dstax = data1.lx0 + pvx - sm * lvx;
				dstay = data1.ly0 + pvy - sm * lvy;
				dstbx = data1.lx0 + pvx + sm * lvx;
				dstby = data1.ly0 + pvy + sm * lvy;
				dstcount = 2;
			} else if(dmag == 0) {
				dstbx = data1.lx0 + pvx;
				dstax = dstbx;
				dstby = data1.ly0 + pvy;
				dstay = dstby;
				dstcount = 1;
			} else {
				dstbx = NaN;
				dstax = dstbx;
				dstby = NaN;
				dstay = dstby;
				dstcount = 0;
			}
			if(dstcount > 0 && !(((data1.lx1 - data1.lx0) * (dstbx - data1.lx0) + (data1.ly1 - data1.ly0) * (dstby - data1.ly0)) * ((data1.lx1 - data1.lx0) * (dstbx - (data1.lx0 + (data1.lx1 - data1.lx0))) + (data1.ly1 - data1.ly0) * (dstby - (data1.ly0 + (data1.ly1 - data1.ly0)))) <= 0)) {
				--dstcount;
				dstbx = dstax;
				dstby = dstay;
			}
			if(dstcount > 0 && !(((data1.lx1 - data1.lx0) * (dstax - data1.lx0) + (data1.ly1 - data1.ly0) * (dstay - data1.ly0)) * ((data1.lx1 - data1.lx0) * (dstax - (data1.lx0 + (data1.lx1 - data1.lx0))) + (data1.ly1 - data1.ly0) * (dstay - (data1.ly0 + (data1.ly1 - data1.ly0)))) <= 0)) {
				--dstcount;
				dstax = dstbx;
				dstay = dstby;
			}
			massive_munit_Assert.areEqual(0,dstcount,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 546, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleSegm_tangentIn"});
		}
	}
	,testCircleSegm_tangentOut: function() {
		var _g = 0;
		var _g1 = data_CircleIntersecTestData.forTangentOut();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 554, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleSegm_tangentOut"});
			var dstax;
			var dstay;
			var dstbx;
			var dstby;
			var dstcount;
			var lvx = data1.lx1 - data1.lx0;
			var lvy = data1.ly1 - data1.ly0;
			var lvmag = lvx * lvx + lvy * lvy;
			var cvx = data1.cx - data1.lx0;
			var cvy = data1.cy - data1.ly0;
			var m = (lvx * cvx + lvy * cvy) / lvmag;
			var pvx = m * lvx;
			var pvy = m * lvy;
			var dmag = data1.crad * data1.crad - ((pvx - cvx) * (pvx - cvx) + (pvy - cvy) * (pvy - cvy));
			if(dmag > 0) {
				var sm = Math.sqrt(dmag / lvmag);
				dstax = data1.lx0 + pvx - sm * lvx;
				dstay = data1.ly0 + pvy - sm * lvy;
				dstbx = data1.lx0 + pvx + sm * lvx;
				dstby = data1.ly0 + pvy + sm * lvy;
				dstcount = 2;
			} else if(dmag == 0) {
				dstbx = data1.lx0 + pvx;
				dstax = dstbx;
				dstby = data1.ly0 + pvy;
				dstay = dstby;
				dstcount = 1;
			} else {
				dstbx = NaN;
				dstax = dstbx;
				dstby = NaN;
				dstay = dstby;
				dstcount = 0;
			}
			if(dstcount > 0 && !(((data1.lx1 - data1.lx0) * (dstbx - data1.lx0) + (data1.ly1 - data1.ly0) * (dstby - data1.ly0)) * ((data1.lx1 - data1.lx0) * (dstbx - (data1.lx0 + (data1.lx1 - data1.lx0))) + (data1.ly1 - data1.ly0) * (dstby - (data1.ly0 + (data1.ly1 - data1.ly0)))) <= 0)) {
				--dstcount;
				dstbx = dstax;
				dstby = dstay;
			}
			if(dstcount > 0 && !(((data1.lx1 - data1.lx0) * (dstax - data1.lx0) + (data1.ly1 - data1.ly0) * (dstay - data1.ly0)) * ((data1.lx1 - data1.lx0) * (dstax - (data1.lx0 + (data1.lx1 - data1.lx0))) + (data1.ly1 - data1.ly0) * (dstay - (data1.ly0 + (data1.ly1 - data1.ly0)))) <= 0)) {
				--dstcount;
				dstax = dstbx;
				dstay = dstby;
			}
			massive_munit_Assert.areEqual(0,dstcount,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 563, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleSegm_tangentOut"});
		}
	}
	,testCircleSegm_projectIn: function() {
		var _g = 0;
		var _g1 = data_CircleIntersecTestData.forProjectIn();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 571, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleSegm_projectIn"});
			var dstax;
			var dstay;
			var dstbx;
			var dstby;
			var dstcount;
			var lvx = data1.lx1 - data1.lx0;
			var lvy = data1.ly1 - data1.ly0;
			var lvmag = lvx * lvx + lvy * lvy;
			var cvx = data1.cx - data1.lx0;
			var cvy = data1.cy - data1.ly0;
			var m = (lvx * cvx + lvy * cvy) / lvmag;
			var pvx = m * lvx;
			var pvy = m * lvy;
			var dmag = data1.crad * data1.crad - ((pvx - cvx) * (pvx - cvx) + (pvy - cvy) * (pvy - cvy));
			if(dmag > 0) {
				var sm = Math.sqrt(dmag / lvmag);
				dstax = data1.lx0 + pvx - sm * lvx;
				dstay = data1.ly0 + pvy - sm * lvy;
				dstbx = data1.lx0 + pvx + sm * lvx;
				dstby = data1.ly0 + pvy + sm * lvy;
				dstcount = 2;
			} else if(dmag == 0) {
				dstbx = data1.lx0 + pvx;
				dstax = dstbx;
				dstby = data1.ly0 + pvy;
				dstay = dstby;
				dstcount = 1;
			} else {
				dstbx = NaN;
				dstax = dstbx;
				dstby = NaN;
				dstay = dstby;
				dstcount = 0;
			}
			if(dstcount > 0 && !(((data1.lx1 - data1.lx0) * (dstbx - data1.lx0) + (data1.ly1 - data1.ly0) * (dstby - data1.ly0)) * ((data1.lx1 - data1.lx0) * (dstbx - (data1.lx0 + (data1.lx1 - data1.lx0))) + (data1.ly1 - data1.ly0) * (dstby - (data1.ly0 + (data1.ly1 - data1.ly0)))) <= 0)) {
				--dstcount;
				dstbx = dstax;
				dstby = dstay;
			}
			if(dstcount > 0 && !(((data1.lx1 - data1.lx0) * (dstax - data1.lx0) + (data1.ly1 - data1.ly0) * (dstay - data1.ly0)) * ((data1.lx1 - data1.lx0) * (dstax - (data1.lx0 + (data1.lx1 - data1.lx0))) + (data1.ly1 - data1.ly0) * (dstay - (data1.ly0 + (data1.ly1 - data1.ly0)))) <= 0)) {
				--dstcount;
				dstax = dstbx;
				dstay = dstby;
			}
			massive_munit_Assert.areEqual(0,dstcount,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 580, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleSegm_projectIn"});
		}
	}
	,testCircleSegm_projectOut: function() {
		var _g = 0;
		var _g1 = data_CircleIntersecTestData.forProjectOut();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 588, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleSegm_projectOut"});
			var dstax;
			var dstay;
			var dstbx;
			var dstby;
			var dstcount;
			var lvx = data1.lx1 - data1.lx0;
			var lvy = data1.ly1 - data1.ly0;
			var lvmag = lvx * lvx + lvy * lvy;
			var cvx = data1.cx - data1.lx0;
			var cvy = data1.cy - data1.ly0;
			var m = (lvx * cvx + lvy * cvy) / lvmag;
			var pvx = m * lvx;
			var pvy = m * lvy;
			var dmag = data1.crad * data1.crad - ((pvx - cvx) * (pvx - cvx) + (pvy - cvy) * (pvy - cvy));
			if(dmag > 0) {
				var sm = Math.sqrt(dmag / lvmag);
				dstax = data1.lx0 + pvx - sm * lvx;
				dstay = data1.ly0 + pvy - sm * lvy;
				dstbx = data1.lx0 + pvx + sm * lvx;
				dstby = data1.ly0 + pvy + sm * lvy;
				dstcount = 2;
			} else if(dmag == 0) {
				dstbx = data1.lx0 + pvx;
				dstax = dstbx;
				dstby = data1.ly0 + pvy;
				dstay = dstby;
				dstcount = 1;
			} else {
				dstbx = NaN;
				dstax = dstbx;
				dstby = NaN;
				dstay = dstby;
				dstcount = 0;
			}
			if(dstcount > 0 && !(((data1.lx1 - data1.lx0) * (dstbx - data1.lx0) + (data1.ly1 - data1.ly0) * (dstby - data1.ly0)) * ((data1.lx1 - data1.lx0) * (dstbx - (data1.lx0 + (data1.lx1 - data1.lx0))) + (data1.ly1 - data1.ly0) * (dstby - (data1.ly0 + (data1.ly1 - data1.ly0)))) <= 0)) {
				--dstcount;
				dstbx = dstax;
				dstby = dstay;
			}
			if(dstcount > 0 && !(((data1.lx1 - data1.lx0) * (dstax - data1.lx0) + (data1.ly1 - data1.ly0) * (dstay - data1.ly0)) * ((data1.lx1 - data1.lx0) * (dstax - (data1.lx0 + (data1.lx1 - data1.lx0))) + (data1.ly1 - data1.ly0) * (dstay - (data1.ly0 + (data1.ly1 - data1.ly0)))) <= 0)) {
				--dstcount;
				dstax = dstbx;
				dstay = dstby;
			}
			massive_munit_Assert.areEqual(0,dstcount,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 597, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleSegm_projectOut"});
		}
	}
	,testCircleSegm_none: function() {
		var _g = 0;
		var _g1 = data_CircleIntersecTestData.forNone();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 605, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleSegm_none"});
			var dstax;
			var dstay;
			var dstbx;
			var dstby;
			var dstcount;
			var lvx = data1.lx1 - data1.lx0;
			var lvy = data1.ly1 - data1.ly0;
			var lvmag = lvx * lvx + lvy * lvy;
			var cvx = data1.cx - data1.lx0;
			var cvy = data1.cy - data1.ly0;
			var m = (lvx * cvx + lvy * cvy) / lvmag;
			var pvx = m * lvx;
			var pvy = m * lvy;
			var dmag = data1.crad * data1.crad - ((pvx - cvx) * (pvx - cvx) + (pvy - cvy) * (pvy - cvy));
			if(dmag > 0) {
				var sm = Math.sqrt(dmag / lvmag);
				dstax = data1.lx0 + pvx - sm * lvx;
				dstay = data1.ly0 + pvy - sm * lvy;
				dstbx = data1.lx0 + pvx + sm * lvx;
				dstby = data1.ly0 + pvy + sm * lvy;
				dstcount = 2;
			} else if(dmag == 0) {
				dstbx = data1.lx0 + pvx;
				dstax = dstbx;
				dstby = data1.ly0 + pvy;
				dstay = dstby;
				dstcount = 1;
			} else {
				dstbx = NaN;
				dstax = dstbx;
				dstby = NaN;
				dstay = dstby;
				dstcount = 0;
			}
			if(dstcount > 0 && !(((data1.lx1 - data1.lx0) * (dstbx - data1.lx0) + (data1.ly1 - data1.ly0) * (dstby - data1.ly0)) * ((data1.lx1 - data1.lx0) * (dstbx - (data1.lx0 + (data1.lx1 - data1.lx0))) + (data1.ly1 - data1.ly0) * (dstby - (data1.ly0 + (data1.ly1 - data1.ly0)))) <= 0)) {
				--dstcount;
				dstbx = dstax;
				dstby = dstay;
			}
			if(dstcount > 0 && !(((data1.lx1 - data1.lx0) * (dstax - data1.lx0) + (data1.ly1 - data1.ly0) * (dstay - data1.ly0)) * ((data1.lx1 - data1.lx0) * (dstax - (data1.lx0 + (data1.lx1 - data1.lx0))) + (data1.ly1 - data1.ly0) * (dstay - (data1.ly0 + (data1.ly1 - data1.ly0)))) <= 0)) {
				--dstcount;
				dstax = dstbx;
				dstay = dstby;
			}
			massive_munit_Assert.areEqual(0,dstcount,{ fileName : "CircleIntersecMacrosTest.hx", lineNumber : 614, className : "iodev.geom2.macros.CircleIntersecMacrosTest", methodName : "testCircleSegm_none"});
		}
	}
	,__class__: iodev_geom2_macros_CircleIntersecMacrosTest
};
var iodev_geom2_macros_LineIntersecMacros = function() { };
$hxClasses["iodev.geom2.macros.LineIntersecMacros"] = iodev_geom2_macros_LineIntersecMacros;
iodev_geom2_macros_LineIntersecMacros.__name__ = ["iodev","geom2","macros","LineIntersecMacros"];
var iodev_geom2_macros_LineIntersecMacrosTest = function() { };
$hxClasses["iodev.geom2.macros.LineIntersecMacrosTest"] = iodev_geom2_macros_LineIntersecMacrosTest;
iodev_geom2_macros_LineIntersecMacrosTest.__name__ = ["iodev","geom2","macros","LineIntersecMacrosTest"];
iodev_geom2_macros_LineIntersecMacrosTest.prototype = {
	testLineLine_cross: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCross();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 14, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineLine_cross"});
			var dstx;
			var dsty;
			var dx1dy2 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var dx2dy1 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.bx0 * dx1dy2 - data1.ax0 * dx2dy1 - (data1.by0 - data1.ay0) * (data1.ax1 - data1.ax0) * (data1.bx1 - data1.bx0)) * isp;
			dsty = (data1.ay0 * dx1dy2 - data1.by0 * dx2dy1 + (data1.bx0 - data1.ax0) * (data1.ay1 - data1.ay0) * (data1.by1 - data1.by0)) * isp;
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 23, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineLine_cross"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 24, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineLine_cross"});
		}
	}
	,testLineLine_touch: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forTouch();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 32, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineLine_touch"});
			var dstx;
			var dsty;
			var dx1dy2 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var dx2dy1 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.bx0 * dx1dy2 - data1.ax0 * dx2dy1 - (data1.by0 - data1.ay0) * (data1.ax1 - data1.ax0) * (data1.bx1 - data1.bx0)) * isp;
			dsty = (data1.ay0 * dx1dy2 - data1.by0 * dx2dy1 + (data1.bx0 - data1.ax0) * (data1.ay1 - data1.ay0) * (data1.by1 - data1.by0)) * isp;
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 41, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineLine_touch"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 42, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineLine_touch"});
		}
	}
	,testLineLine_projectIn: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forProjectIn();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 50, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineLine_projectIn"});
			var dstx;
			var dsty;
			var dx1dy2 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var dx2dy1 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.bx0 * dx1dy2 - data1.ax0 * dx2dy1 - (data1.by0 - data1.ay0) * (data1.ax1 - data1.ax0) * (data1.bx1 - data1.bx0)) * isp;
			dsty = (data1.ay0 * dx1dy2 - data1.by0 * dx2dy1 + (data1.bx0 - data1.ax0) * (data1.ay1 - data1.ay0) * (data1.by1 - data1.by0)) * isp;
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 59, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineLine_projectIn"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 60, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineLine_projectIn"});
		}
	}
	,testLineLine_projectOut: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forProjectOut();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 68, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineLine_projectOut"});
			var dstx;
			var dsty;
			var dx1dy2 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var dx2dy1 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.bx0 * dx1dy2 - data1.ax0 * dx2dy1 - (data1.by0 - data1.ay0) * (data1.ax1 - data1.ax0) * (data1.bx1 - data1.bx0)) * isp;
			dsty = (data1.ay0 * dx1dy2 - data1.by0 * dx2dy1 + (data1.bx0 - data1.ax0) * (data1.ay1 - data1.ay0) * (data1.by1 - data1.by0)) * isp;
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 77, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineLine_projectOut"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 78, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineLine_projectOut"});
		}
	}
	,testLineLine_castIn: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastIn();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 86, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineLine_castIn"});
			var dstx;
			var dsty;
			var dx1dy2 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var dx2dy1 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.bx0 * dx1dy2 - data1.ax0 * dx2dy1 - (data1.by0 - data1.ay0) * (data1.ax1 - data1.ax0) * (data1.bx1 - data1.bx0)) * isp;
			dsty = (data1.ay0 * dx1dy2 - data1.by0 * dx2dy1 + (data1.bx0 - data1.ax0) * (data1.ay1 - data1.ay0) * (data1.by1 - data1.by0)) * isp;
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 95, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineLine_castIn"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 96, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineLine_castIn"});
		}
	}
	,testLineLine_castOut: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastOut();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 104, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineLine_castOut"});
			var dstx;
			var dsty;
			var dx1dy2 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var dx2dy1 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.bx0 * dx1dy2 - data1.ax0 * dx2dy1 - (data1.by0 - data1.ay0) * (data1.ax1 - data1.ax0) * (data1.bx1 - data1.bx0)) * isp;
			dsty = (data1.ay0 * dx1dy2 - data1.by0 * dx2dy1 + (data1.bx0 - data1.ax0) * (data1.ay1 - data1.ay0) * (data1.by1 - data1.by0)) * isp;
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 113, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineLine_castOut"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 114, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineLine_castOut"});
		}
	}
	,testLineLine_castAway: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastAway();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 122, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineLine_castAway"});
			var dstx;
			var dsty;
			var dx1dy2 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var dx2dy1 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.bx0 * dx1dy2 - data1.ax0 * dx2dy1 - (data1.by0 - data1.ay0) * (data1.ax1 - data1.ax0) * (data1.bx1 - data1.bx0)) * isp;
			dsty = (data1.ay0 * dx1dy2 - data1.by0 * dx2dy1 + (data1.bx0 - data1.ax0) * (data1.ay1 - data1.ay0) * (data1.by1 - data1.by0)) * isp;
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 131, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineLine_castAway"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 132, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineLine_castAway"});
		}
	}
	,testLineLine_parallel: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forParallel();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 140, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineLine_parallel"});
			var dstx;
			var dsty;
			var dx1dy2 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var dx2dy1 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.bx0 * dx1dy2 - data1.ax0 * dx2dy1 - (data1.by0 - data1.ay0) * (data1.ax1 - data1.ax0) * (data1.bx1 - data1.bx0)) * isp;
			dsty = (data1.ay0 * dx1dy2 - data1.by0 * dx2dy1 + (data1.bx0 - data1.ax0) * (data1.ay1 - data1.ay0) * (data1.by1 - data1.by0)) * isp;
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 149, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineLine_parallel"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 150, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineLine_parallel"});
		}
	}
	,testLineRay_cross: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCross();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 162, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineRay_cross"});
			var dstres;
			var dstx;
			var dsty;
			var dx1dy2 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var dx2dy1 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.bx0 * dx1dy2 - data1.ax0 * dx2dy1 - (data1.by0 - data1.ay0) * (data1.ax1 - data1.ax0) * (data1.bx1 - data1.bx0)) * isp;
			dsty = (data1.ay0 * dx1dy2 - data1.by0 * dx2dy1 + (data1.bx0 - data1.ax0) * (data1.ay1 - data1.ay0) * (data1.by1 - data1.by0)) * isp;
			dstres = (data1.bx1 - data1.bx0) * (dstx - data1.bx0) + (data1.by1 - data1.by0) * (dsty - data1.by0) >= 0;
			massive_munit_Assert.isTrue(dstres,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 171, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineRay_cross"});
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 172, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineRay_cross"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 173, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineRay_cross"});
		}
	}
	,testLineRay_touch: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forTouch();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 181, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineRay_touch"});
			var dstres;
			var dstx;
			var dsty;
			var dx1dy2 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var dx2dy1 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.bx0 * dx1dy2 - data1.ax0 * dx2dy1 - (data1.by0 - data1.ay0) * (data1.ax1 - data1.ax0) * (data1.bx1 - data1.bx0)) * isp;
			dsty = (data1.ay0 * dx1dy2 - data1.by0 * dx2dy1 + (data1.bx0 - data1.ax0) * (data1.ay1 - data1.ay0) * (data1.by1 - data1.by0)) * isp;
			dstres = (data1.bx1 - data1.bx0) * (dstx - data1.bx0) + (data1.by1 - data1.by0) * (dsty - data1.by0) >= 0;
			massive_munit_Assert.isTrue(dstres,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 190, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineRay_touch"});
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 191, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineRay_touch"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 192, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineRay_touch"});
		}
	}
	,testLineRay_projectIn_ba: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forProjectIn();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 200, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineRay_projectIn_ba"});
			var dstres;
			var dstx;
			var dsty;
			var dx1dy2 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var dx2dy1 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.ax0 * dx1dy2 - data1.bx0 * dx2dy1 - (data1.ay0 - data1.by0) * (data1.bx1 - data1.bx0) * (data1.ax1 - data1.ax0)) * isp;
			dsty = (data1.by0 * dx1dy2 - data1.ay0 * dx2dy1 + (data1.ax0 - data1.bx0) * (data1.by1 - data1.by0) * (data1.ay1 - data1.ay0)) * isp;
			dstres = (data1.ax1 - data1.ax0) * (dstx - data1.ax0) + (data1.ay1 - data1.ay0) * (dsty - data1.ay0) >= 0;
			massive_munit_Assert.isTrue(dstres,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 209, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineRay_projectIn_ba"});
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 210, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineRay_projectIn_ba"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 211, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineRay_projectIn_ba"});
		}
	}
	,testLineRay_projectOut_ba: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forProjectOut();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 219, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineRay_projectOut_ba"});
			var dstres;
			var dstx;
			var dsty;
			var dx1dy2 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var dx2dy1 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.ax0 * dx1dy2 - data1.bx0 * dx2dy1 - (data1.ay0 - data1.by0) * (data1.bx1 - data1.bx0) * (data1.ax1 - data1.ax0)) * isp;
			dsty = (data1.by0 * dx1dy2 - data1.ay0 * dx2dy1 + (data1.ax0 - data1.bx0) * (data1.by1 - data1.by0) * (data1.ay1 - data1.ay0)) * isp;
			dstres = (data1.ax1 - data1.ax0) * (dstx - data1.ax0) + (data1.ay1 - data1.ay0) * (dsty - data1.ay0) >= 0;
			massive_munit_Assert.isFalse(dstres,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 228, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineRay_projectOut_ba"});
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 229, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineRay_projectOut_ba"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 230, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineRay_projectOut_ba"});
		}
	}
	,testLineRay_castIn: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastIn();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 238, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineRay_castIn"});
			var dstres;
			var dstx;
			var dsty;
			var dx1dy2 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var dx2dy1 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.bx0 * dx1dy2 - data1.ax0 * dx2dy1 - (data1.by0 - data1.ay0) * (data1.ax1 - data1.ax0) * (data1.bx1 - data1.bx0)) * isp;
			dsty = (data1.ay0 * dx1dy2 - data1.by0 * dx2dy1 + (data1.bx0 - data1.ax0) * (data1.ay1 - data1.ay0) * (data1.by1 - data1.by0)) * isp;
			dstres = (data1.bx1 - data1.bx0) * (dstx - data1.bx0) + (data1.by1 - data1.by0) * (dsty - data1.by0) >= 0;
			massive_munit_Assert.isTrue(dstres,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 247, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineRay_castIn"});
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 248, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineRay_castIn"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 249, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineRay_castIn"});
		}
	}
	,testLineRay_castOut_ba: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastOut();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 257, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineRay_castOut_ba"});
			var dstres;
			var dstx;
			var dsty;
			var dx1dy2 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var dx2dy1 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.ax0 * dx1dy2 - data1.bx0 * dx2dy1 - (data1.ay0 - data1.by0) * (data1.bx1 - data1.bx0) * (data1.ax1 - data1.ax0)) * isp;
			dsty = (data1.by0 * dx1dy2 - data1.ay0 * dx2dy1 + (data1.ax0 - data1.bx0) * (data1.by1 - data1.by0) * (data1.ay1 - data1.ay0)) * isp;
			dstres = (data1.ax1 - data1.ax0) * (dstx - data1.ax0) + (data1.ay1 - data1.ay0) * (dsty - data1.ay0) >= 0;
			massive_munit_Assert.isFalse(dstres,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 266, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineRay_castOut_ba"});
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 267, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineRay_castOut_ba"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 268, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineRay_castOut_ba"});
		}
	}
	,testLineRay_castAway: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastAway();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 276, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineRay_castAway"});
			var dstres;
			var dstx;
			var dsty;
			var dx1dy2 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var dx2dy1 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.bx0 * dx1dy2 - data1.ax0 * dx2dy1 - (data1.by0 - data1.ay0) * (data1.ax1 - data1.ax0) * (data1.bx1 - data1.bx0)) * isp;
			dsty = (data1.ay0 * dx1dy2 - data1.by0 * dx2dy1 + (data1.bx0 - data1.ax0) * (data1.ay1 - data1.ay0) * (data1.by1 - data1.by0)) * isp;
			dstres = (data1.bx1 - data1.bx0) * (dstx - data1.bx0) + (data1.by1 - data1.by0) * (dsty - data1.by0) >= 0;
			massive_munit_Assert.isFalse(dstres,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 285, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineRay_castAway"});
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 286, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineRay_castAway"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 287, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineRay_castAway"});
		}
	}
	,testLineRay_parallel_lite: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forParallel();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 295, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineRay_parallel_lite"});
			var dstres;
			var dstx;
			var dsty;
			var dx1dy2 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var dx2dy1 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.bx0 * dx1dy2 - data1.ax0 * dx2dy1 - (data1.by0 - data1.ay0) * (data1.ax1 - data1.ax0) * (data1.bx1 - data1.bx0)) * isp;
			dsty = (data1.ay0 * dx1dy2 - data1.by0 * dx2dy1 + (data1.bx0 - data1.ax0) * (data1.ay1 - data1.ay0) * (data1.by1 - data1.by0)) * isp;
			dstres = (data1.bx1 - data1.bx0) * (dstx - data1.bx0) + (data1.by1 - data1.by0) * (dsty - data1.by0) >= 0;
			if(dstres) {
				MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 305, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineRay_parallel_lite"});
				MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 306, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineRay_parallel_lite"});
			}
		}
	}
	,testLineSegm_cross: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCross();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 319, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineSegm_cross"});
			var dstres;
			var dstx;
			var dsty;
			var dx1dy2 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var dx2dy1 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.bx0 * dx1dy2 - data1.ax0 * dx2dy1 - (data1.by0 - data1.ay0) * (data1.ax1 - data1.ax0) * (data1.bx1 - data1.bx0)) * isp;
			dsty = (data1.ay0 * dx1dy2 - data1.by0 * dx2dy1 + (data1.bx0 - data1.ax0) * (data1.ay1 - data1.ay0) * (data1.by1 - data1.by0)) * isp;
			dstres = ((data1.bx1 - data1.bx0) * (dstx - data1.bx0) + (data1.by1 - data1.by0) * (dsty - data1.by0)) * ((data1.bx1 - data1.bx0) * (dstx - (data1.bx0 + (data1.bx1 - data1.bx0))) + (data1.by1 - data1.by0) * (dsty - (data1.by0 + (data1.by1 - data1.by0)))) <= 0;
			massive_munit_Assert.isTrue(dstres,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 328, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineSegm_cross"});
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 329, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineSegm_cross"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 330, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineSegm_cross"});
		}
	}
	,testLineSegm_touch: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forTouch();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 338, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineSegm_touch"});
			var dstres;
			var dstx;
			var dsty;
			var dx1dy2 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var dx2dy1 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.bx0 * dx1dy2 - data1.ax0 * dx2dy1 - (data1.by0 - data1.ay0) * (data1.ax1 - data1.ax0) * (data1.bx1 - data1.bx0)) * isp;
			dsty = (data1.ay0 * dx1dy2 - data1.by0 * dx2dy1 + (data1.bx0 - data1.ax0) * (data1.ay1 - data1.ay0) * (data1.by1 - data1.by0)) * isp;
			dstres = ((data1.bx1 - data1.bx0) * (dstx - data1.bx0) + (data1.by1 - data1.by0) * (dsty - data1.by0)) * ((data1.bx1 - data1.bx0) * (dstx - (data1.bx0 + (data1.bx1 - data1.bx0))) + (data1.by1 - data1.by0) * (dsty - (data1.by0 + (data1.by1 - data1.by0)))) <= 0;
			massive_munit_Assert.isTrue(dstres,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 347, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineSegm_touch"});
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 348, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineSegm_touch"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 349, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineSegm_touch"});
		}
	}
	,testLineSegm_projectIn_ba: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forProjectIn();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 357, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineSegm_projectIn_ba"});
			var dstres;
			var dstx;
			var dsty;
			var dx1dy2 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var dx2dy1 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.ax0 * dx1dy2 - data1.bx0 * dx2dy1 - (data1.ay0 - data1.by0) * (data1.bx1 - data1.bx0) * (data1.ax1 - data1.ax0)) * isp;
			dsty = (data1.by0 * dx1dy2 - data1.ay0 * dx2dy1 + (data1.ax0 - data1.bx0) * (data1.by1 - data1.by0) * (data1.ay1 - data1.ay0)) * isp;
			dstres = ((data1.ax1 - data1.ax0) * (dstx - data1.ax0) + (data1.ay1 - data1.ay0) * (dsty - data1.ay0)) * ((data1.ax1 - data1.ax0) * (dstx - (data1.ax0 + (data1.ax1 - data1.ax0))) + (data1.ay1 - data1.ay0) * (dsty - (data1.ay0 + (data1.ay1 - data1.ay0)))) <= 0;
			massive_munit_Assert.isFalse(dstres,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 366, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineSegm_projectIn_ba"});
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 367, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineSegm_projectIn_ba"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 368, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineSegm_projectIn_ba"});
		}
	}
	,testLineSegm_projectOut_ba: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forProjectOut();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 376, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineSegm_projectOut_ba"});
			var dstres;
			var dstx;
			var dsty;
			var dx1dy2 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var dx2dy1 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.ax0 * dx1dy2 - data1.bx0 * dx2dy1 - (data1.ay0 - data1.by0) * (data1.bx1 - data1.bx0) * (data1.ax1 - data1.ax0)) * isp;
			dsty = (data1.by0 * dx1dy2 - data1.ay0 * dx2dy1 + (data1.ax0 - data1.bx0) * (data1.by1 - data1.by0) * (data1.ay1 - data1.ay0)) * isp;
			dstres = ((data1.ax1 - data1.ax0) * (dstx - data1.ax0) + (data1.ay1 - data1.ay0) * (dsty - data1.ay0)) * ((data1.ax1 - data1.ax0) * (dstx - (data1.ax0 + (data1.ax1 - data1.ax0))) + (data1.ay1 - data1.ay0) * (dsty - (data1.ay0 + (data1.ay1 - data1.ay0)))) <= 0;
			massive_munit_Assert.isFalse(dstres,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 385, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineSegm_projectOut_ba"});
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 386, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineSegm_projectOut_ba"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 387, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineSegm_projectOut_ba"});
		}
	}
	,testLineSegm_castIn: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastIn();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 395, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineSegm_castIn"});
			var dstres;
			var dstx;
			var dsty;
			var dx1dy2 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var dx2dy1 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.bx0 * dx1dy2 - data1.ax0 * dx2dy1 - (data1.by0 - data1.ay0) * (data1.ax1 - data1.ax0) * (data1.bx1 - data1.bx0)) * isp;
			dsty = (data1.ay0 * dx1dy2 - data1.by0 * dx2dy1 + (data1.bx0 - data1.ax0) * (data1.ay1 - data1.ay0) * (data1.by1 - data1.by0)) * isp;
			dstres = ((data1.bx1 - data1.bx0) * (dstx - data1.bx0) + (data1.by1 - data1.by0) * (dsty - data1.by0)) * ((data1.bx1 - data1.bx0) * (dstx - (data1.bx0 + (data1.bx1 - data1.bx0))) + (data1.by1 - data1.by0) * (dsty - (data1.by0 + (data1.by1 - data1.by0)))) <= 0;
			massive_munit_Assert.isFalse(dstres,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 404, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineSegm_castIn"});
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 405, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineSegm_castIn"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 406, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineSegm_castIn"});
		}
	}
	,testLineSegm_castOut_ba: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastOut();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 414, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineSegm_castOut_ba"});
			var dstres;
			var dstx;
			var dsty;
			var dx1dy2 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var dx2dy1 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.ax0 * dx1dy2 - data1.bx0 * dx2dy1 - (data1.ay0 - data1.by0) * (data1.bx1 - data1.bx0) * (data1.ax1 - data1.ax0)) * isp;
			dsty = (data1.by0 * dx1dy2 - data1.ay0 * dx2dy1 + (data1.ax0 - data1.bx0) * (data1.by1 - data1.by0) * (data1.ay1 - data1.ay0)) * isp;
			dstres = ((data1.ax1 - data1.ax0) * (dstx - data1.ax0) + (data1.ay1 - data1.ay0) * (dsty - data1.ay0)) * ((data1.ax1 - data1.ax0) * (dstx - (data1.ax0 + (data1.ax1 - data1.ax0))) + (data1.ay1 - data1.ay0) * (dsty - (data1.ay0 + (data1.ay1 - data1.ay0)))) <= 0;
			massive_munit_Assert.isFalse(dstres,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 423, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineSegm_castOut_ba"});
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 424, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineSegm_castOut_ba"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 425, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineSegm_castOut_ba"});
		}
	}
	,testLineSegm_castAway: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastAway();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 433, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineSegm_castAway"});
			var dstres;
			var dstx;
			var dsty;
			var dx1dy2 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var dx2dy1 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.bx0 * dx1dy2 - data1.ax0 * dx2dy1 - (data1.by0 - data1.ay0) * (data1.ax1 - data1.ax0) * (data1.bx1 - data1.bx0)) * isp;
			dsty = (data1.ay0 * dx1dy2 - data1.by0 * dx2dy1 + (data1.bx0 - data1.ax0) * (data1.ay1 - data1.ay0) * (data1.by1 - data1.by0)) * isp;
			dstres = ((data1.bx1 - data1.bx0) * (dstx - data1.bx0) + (data1.by1 - data1.by0) * (dsty - data1.by0)) * ((data1.bx1 - data1.bx0) * (dstx - (data1.bx0 + (data1.bx1 - data1.bx0))) + (data1.by1 - data1.by0) * (dsty - (data1.by0 + (data1.by1 - data1.by0)))) <= 0;
			massive_munit_Assert.isFalse(dstres,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 442, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineSegm_castAway"});
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 443, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineSegm_castAway"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 444, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineSegm_castAway"});
		}
	}
	,testLineSegm_parallel: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forParallel();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 452, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineSegm_parallel"});
			var dstres;
			var dstx;
			var dsty;
			var dx1dy2 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var dx2dy1 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.bx0 * dx1dy2 - data1.ax0 * dx2dy1 - (data1.by0 - data1.ay0) * (data1.ax1 - data1.ax0) * (data1.bx1 - data1.bx0)) * isp;
			dsty = (data1.ay0 * dx1dy2 - data1.by0 * dx2dy1 + (data1.bx0 - data1.ax0) * (data1.ay1 - data1.ay0) * (data1.by1 - data1.by0)) * isp;
			dstres = ((data1.bx1 - data1.bx0) * (dstx - data1.bx0) + (data1.by1 - data1.by0) * (dsty - data1.by0)) * ((data1.bx1 - data1.bx0) * (dstx - (data1.bx0 + (data1.bx1 - data1.bx0))) + (data1.by1 - data1.by0) * (dsty - (data1.by0 + (data1.by1 - data1.by0)))) <= 0;
			massive_munit_Assert.isFalse(dstres,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 461, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineSegm_parallel"});
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 462, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineSegm_parallel"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 463, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testLineSegm_parallel"});
		}
	}
	,testRayRay_cross: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCross();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 475, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRayRay_cross"});
			var dstres;
			var dstx;
			var dsty;
			var dx1dy2 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var dx2dy1 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.bx0 * dx1dy2 - data1.ax0 * dx2dy1 - (data1.by0 - data1.ay0) * (data1.ax1 - data1.ax0) * (data1.bx1 - data1.bx0)) * isp;
			dsty = (data1.ay0 * dx1dy2 - data1.by0 * dx2dy1 + (data1.bx0 - data1.ax0) * (data1.ay1 - data1.ay0) * (data1.by1 - data1.by0)) * isp;
			if((data1.ax1 - data1.ax0) * (dstx - data1.ax0) + (data1.ay1 - data1.ay0) * (dsty - data1.ay0) >= 0) {
				dstres = (data1.bx1 - data1.bx0) * (dstx - data1.bx0) + (data1.by1 - data1.by0) * (dsty - data1.by0) >= 0;
			} else {
				dstres = false;
			}
			massive_munit_Assert.isTrue(dstres,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 484, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRayRay_cross"});
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 485, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRayRay_cross"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 486, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRayRay_cross"});
		}
	}
	,testRayRay_touch: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forTouch();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 494, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRayRay_touch"});
			var dstres;
			var dstx;
			var dsty;
			var dx1dy2 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var dx2dy1 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.bx0 * dx1dy2 - data1.ax0 * dx2dy1 - (data1.by0 - data1.ay0) * (data1.ax1 - data1.ax0) * (data1.bx1 - data1.bx0)) * isp;
			dsty = (data1.ay0 * dx1dy2 - data1.by0 * dx2dy1 + (data1.bx0 - data1.ax0) * (data1.ay1 - data1.ay0) * (data1.by1 - data1.by0)) * isp;
			if((data1.ax1 - data1.ax0) * (dstx - data1.ax0) + (data1.ay1 - data1.ay0) * (dsty - data1.ay0) >= 0) {
				dstres = (data1.bx1 - data1.bx0) * (dstx - data1.bx0) + (data1.by1 - data1.by0) * (dsty - data1.by0) >= 0;
			} else {
				dstres = false;
			}
			massive_munit_Assert.isTrue(dstres,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 503, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRayRay_touch"});
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 504, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRayRay_touch"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 505, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRayRay_touch"});
		}
	}
	,testRayRay_projectIn: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forProjectIn();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 513, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRayRay_projectIn"});
			var dstres;
			var dstx;
			var dsty;
			var dx1dy2 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var dx2dy1 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.bx0 * dx1dy2 - data1.ax0 * dx2dy1 - (data1.by0 - data1.ay0) * (data1.ax1 - data1.ax0) * (data1.bx1 - data1.bx0)) * isp;
			dsty = (data1.ay0 * dx1dy2 - data1.by0 * dx2dy1 + (data1.bx0 - data1.ax0) * (data1.ay1 - data1.ay0) * (data1.by1 - data1.by0)) * isp;
			if((data1.ax1 - data1.ax0) * (dstx - data1.ax0) + (data1.ay1 - data1.ay0) * (dsty - data1.ay0) >= 0) {
				dstres = (data1.bx1 - data1.bx0) * (dstx - data1.bx0) + (data1.by1 - data1.by0) * (dsty - data1.by0) >= 0;
			} else {
				dstres = false;
			}
			massive_munit_Assert.isTrue(dstres,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 522, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRayRay_projectIn"});
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 523, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRayRay_projectIn"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 524, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRayRay_projectIn"});
		}
	}
	,testRayRay_projectOut: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forProjectOut();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 532, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRayRay_projectOut"});
			var dstres;
			var dstx;
			var dsty;
			var dx1dy2 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var dx2dy1 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.bx0 * dx1dy2 - data1.ax0 * dx2dy1 - (data1.by0 - data1.ay0) * (data1.ax1 - data1.ax0) * (data1.bx1 - data1.bx0)) * isp;
			dsty = (data1.ay0 * dx1dy2 - data1.by0 * dx2dy1 + (data1.bx0 - data1.ax0) * (data1.ay1 - data1.ay0) * (data1.by1 - data1.by0)) * isp;
			if((data1.ax1 - data1.ax0) * (dstx - data1.ax0) + (data1.ay1 - data1.ay0) * (dsty - data1.ay0) >= 0) {
				dstres = (data1.bx1 - data1.bx0) * (dstx - data1.bx0) + (data1.by1 - data1.by0) * (dsty - data1.by0) >= 0;
			} else {
				dstres = false;
			}
			massive_munit_Assert.isFalse(dstres,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 541, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRayRay_projectOut"});
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 542, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRayRay_projectOut"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 543, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRayRay_projectOut"});
		}
	}
	,testRayRay_castIn: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastIn();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 551, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRayRay_castIn"});
			var dstres;
			var dstx;
			var dsty;
			var dx1dy2 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var dx2dy1 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.bx0 * dx1dy2 - data1.ax0 * dx2dy1 - (data1.by0 - data1.ay0) * (data1.ax1 - data1.ax0) * (data1.bx1 - data1.bx0)) * isp;
			dsty = (data1.ay0 * dx1dy2 - data1.by0 * dx2dy1 + (data1.bx0 - data1.ax0) * (data1.ay1 - data1.ay0) * (data1.by1 - data1.by0)) * isp;
			if((data1.ax1 - data1.ax0) * (dstx - data1.ax0) + (data1.ay1 - data1.ay0) * (dsty - data1.ay0) >= 0) {
				dstres = (data1.bx1 - data1.bx0) * (dstx - data1.bx0) + (data1.by1 - data1.by0) * (dsty - data1.by0) >= 0;
			} else {
				dstres = false;
			}
			massive_munit_Assert.isTrue(dstres,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 560, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRayRay_castIn"});
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 561, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRayRay_castIn"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 562, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRayRay_castIn"});
		}
	}
	,testRayRay_castOut: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastOut();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 570, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRayRay_castOut"});
			var dstres;
			var dstx;
			var dsty;
			var dx1dy2 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var dx2dy1 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.bx0 * dx1dy2 - data1.ax0 * dx2dy1 - (data1.by0 - data1.ay0) * (data1.ax1 - data1.ax0) * (data1.bx1 - data1.bx0)) * isp;
			dsty = (data1.ay0 * dx1dy2 - data1.by0 * dx2dy1 + (data1.bx0 - data1.ax0) * (data1.ay1 - data1.ay0) * (data1.by1 - data1.by0)) * isp;
			if((data1.ax1 - data1.ax0) * (dstx - data1.ax0) + (data1.ay1 - data1.ay0) * (dsty - data1.ay0) >= 0) {
				dstres = (data1.bx1 - data1.bx0) * (dstx - data1.bx0) + (data1.by1 - data1.by0) * (dsty - data1.by0) >= 0;
			} else {
				dstres = false;
			}
			massive_munit_Assert.isFalse(dstres,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 579, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRayRay_castOut"});
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 580, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRayRay_castOut"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 581, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRayRay_castOut"});
		}
	}
	,testRayRay_castAway: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastAway();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 589, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRayRay_castAway"});
			var dstres;
			var dstx;
			var dsty;
			var dx1dy2 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var dx2dy1 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.bx0 * dx1dy2 - data1.ax0 * dx2dy1 - (data1.by0 - data1.ay0) * (data1.ax1 - data1.ax0) * (data1.bx1 - data1.bx0)) * isp;
			dsty = (data1.ay0 * dx1dy2 - data1.by0 * dx2dy1 + (data1.bx0 - data1.ax0) * (data1.ay1 - data1.ay0) * (data1.by1 - data1.by0)) * isp;
			if((data1.ax1 - data1.ax0) * (dstx - data1.ax0) + (data1.ay1 - data1.ay0) * (dsty - data1.ay0) >= 0) {
				dstres = (data1.bx1 - data1.bx0) * (dstx - data1.bx0) + (data1.by1 - data1.by0) * (dsty - data1.by0) >= 0;
			} else {
				dstres = false;
			}
			massive_munit_Assert.isFalse(dstres,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 598, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRayRay_castAway"});
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 599, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRayRay_castAway"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 600, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRayRay_castAway"});
		}
	}
	,testRayRay_parallel_lite: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forParallel();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 608, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRayRay_parallel_lite"});
			var dstres;
			var dstx;
			var dsty;
			var dx1dy2 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var dx2dy1 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.bx0 * dx1dy2 - data1.ax0 * dx2dy1 - (data1.by0 - data1.ay0) * (data1.ax1 - data1.ax0) * (data1.bx1 - data1.bx0)) * isp;
			dsty = (data1.ay0 * dx1dy2 - data1.by0 * dx2dy1 + (data1.bx0 - data1.ax0) * (data1.ay1 - data1.ay0) * (data1.by1 - data1.by0)) * isp;
			if((data1.ax1 - data1.ax0) * (dstx - data1.ax0) + (data1.ay1 - data1.ay0) * (dsty - data1.ay0) >= 0) {
				dstres = (data1.bx1 - data1.bx0) * (dstx - data1.bx0) + (data1.by1 - data1.by0) * (dsty - data1.by0) >= 0;
			} else {
				dstres = false;
			}
			if(dstres) {
				MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 618, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRayRay_parallel_lite"});
				MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 619, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRayRay_parallel_lite"});
			}
		}
	}
	,testRaySegm_cross: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCross();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 632, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRaySegm_cross"});
			var dstres;
			var dstx;
			var dsty;
			var dx1dy2 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var dx2dy1 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.bx0 * dx1dy2 - data1.ax0 * dx2dy1 - (data1.by0 - data1.ay0) * (data1.ax1 - data1.ax0) * (data1.bx1 - data1.bx0)) * isp;
			dsty = (data1.ay0 * dx1dy2 - data1.by0 * dx2dy1 + (data1.bx0 - data1.ax0) * (data1.ay1 - data1.ay0) * (data1.by1 - data1.by0)) * isp;
			if((data1.ax1 - data1.ax0) * (dstx - data1.ax0) + (data1.ay1 - data1.ay0) * (dsty - data1.ay0) >= 0) {
				dstres = ((data1.bx1 - data1.bx0) * (dstx - data1.bx0) + (data1.by1 - data1.by0) * (dsty - data1.by0)) * ((data1.bx1 - data1.bx0) * (dstx - (data1.bx0 + (data1.bx1 - data1.bx0))) + (data1.by1 - data1.by0) * (dsty - (data1.by0 + (data1.by1 - data1.by0)))) <= 0;
			} else {
				dstres = false;
			}
			massive_munit_Assert.isTrue(dstres,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 641, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRaySegm_cross"});
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 642, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRaySegm_cross"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 643, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRaySegm_cross"});
		}
	}
	,testRaySegm_touch: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forTouch();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 651, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRaySegm_touch"});
			var dstres;
			var dstx;
			var dsty;
			var dx1dy2 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var dx2dy1 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.bx0 * dx1dy2 - data1.ax0 * dx2dy1 - (data1.by0 - data1.ay0) * (data1.ax1 - data1.ax0) * (data1.bx1 - data1.bx0)) * isp;
			dsty = (data1.ay0 * dx1dy2 - data1.by0 * dx2dy1 + (data1.bx0 - data1.ax0) * (data1.ay1 - data1.ay0) * (data1.by1 - data1.by0)) * isp;
			if((data1.ax1 - data1.ax0) * (dstx - data1.ax0) + (data1.ay1 - data1.ay0) * (dsty - data1.ay0) >= 0) {
				dstres = ((data1.bx1 - data1.bx0) * (dstx - data1.bx0) + (data1.by1 - data1.by0) * (dsty - data1.by0)) * ((data1.bx1 - data1.bx0) * (dstx - (data1.bx0 + (data1.bx1 - data1.bx0))) + (data1.by1 - data1.by0) * (dsty - (data1.by0 + (data1.by1 - data1.by0)))) <= 0;
			} else {
				dstres = false;
			}
			massive_munit_Assert.isTrue(dstres,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 660, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRaySegm_touch"});
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 661, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRaySegm_touch"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 662, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRaySegm_touch"});
		}
	}
	,testRaySegm_projectIn: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forProjectIn();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 670, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRaySegm_projectIn"});
			var dstres;
			var dstx;
			var dsty;
			var dx1dy2 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var dx2dy1 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.bx0 * dx1dy2 - data1.ax0 * dx2dy1 - (data1.by0 - data1.ay0) * (data1.ax1 - data1.ax0) * (data1.bx1 - data1.bx0)) * isp;
			dsty = (data1.ay0 * dx1dy2 - data1.by0 * dx2dy1 + (data1.bx0 - data1.ax0) * (data1.ay1 - data1.ay0) * (data1.by1 - data1.by0)) * isp;
			if((data1.ax1 - data1.ax0) * (dstx - data1.ax0) + (data1.ay1 - data1.ay0) * (dsty - data1.ay0) >= 0) {
				dstres = ((data1.bx1 - data1.bx0) * (dstx - data1.bx0) + (data1.by1 - data1.by0) * (dsty - data1.by0)) * ((data1.bx1 - data1.bx0) * (dstx - (data1.bx0 + (data1.bx1 - data1.bx0))) + (data1.by1 - data1.by0) * (dsty - (data1.by0 + (data1.by1 - data1.by0)))) <= 0;
			} else {
				dstres = false;
			}
			massive_munit_Assert.isTrue(dstres,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 679, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRaySegm_projectIn"});
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 680, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRaySegm_projectIn"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 681, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRaySegm_projectIn"});
		}
	}
	,testRaySegm_projectOut: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forProjectOut();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 689, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRaySegm_projectOut"});
			var dstres;
			var dstx;
			var dsty;
			var dx1dy2 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var dx2dy1 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.bx0 * dx1dy2 - data1.ax0 * dx2dy1 - (data1.by0 - data1.ay0) * (data1.ax1 - data1.ax0) * (data1.bx1 - data1.bx0)) * isp;
			dsty = (data1.ay0 * dx1dy2 - data1.by0 * dx2dy1 + (data1.bx0 - data1.ax0) * (data1.ay1 - data1.ay0) * (data1.by1 - data1.by0)) * isp;
			if((data1.ax1 - data1.ax0) * (dstx - data1.ax0) + (data1.ay1 - data1.ay0) * (dsty - data1.ay0) >= 0) {
				dstres = ((data1.bx1 - data1.bx0) * (dstx - data1.bx0) + (data1.by1 - data1.by0) * (dsty - data1.by0)) * ((data1.bx1 - data1.bx0) * (dstx - (data1.bx0 + (data1.bx1 - data1.bx0))) + (data1.by1 - data1.by0) * (dsty - (data1.by0 + (data1.by1 - data1.by0)))) <= 0;
			} else {
				dstres = false;
			}
			massive_munit_Assert.isFalse(dstres,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 698, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRaySegm_projectOut"});
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 699, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRaySegm_projectOut"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 700, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRaySegm_projectOut"});
		}
	}
	,testRaySegm_castIn: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastIn();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 708, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRaySegm_castIn"});
			var dstres;
			var dstx;
			var dsty;
			var dx1dy2 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var dx2dy1 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.bx0 * dx1dy2 - data1.ax0 * dx2dy1 - (data1.by0 - data1.ay0) * (data1.ax1 - data1.ax0) * (data1.bx1 - data1.bx0)) * isp;
			dsty = (data1.ay0 * dx1dy2 - data1.by0 * dx2dy1 + (data1.bx0 - data1.ax0) * (data1.ay1 - data1.ay0) * (data1.by1 - data1.by0)) * isp;
			if((data1.ax1 - data1.ax0) * (dstx - data1.ax0) + (data1.ay1 - data1.ay0) * (dsty - data1.ay0) >= 0) {
				dstres = ((data1.bx1 - data1.bx0) * (dstx - data1.bx0) + (data1.by1 - data1.by0) * (dsty - data1.by0)) * ((data1.bx1 - data1.bx0) * (dstx - (data1.bx0 + (data1.bx1 - data1.bx0))) + (data1.by1 - data1.by0) * (dsty - (data1.by0 + (data1.by1 - data1.by0)))) <= 0;
			} else {
				dstres = false;
			}
			massive_munit_Assert.isFalse(dstres,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 717, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRaySegm_castIn"});
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 718, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRaySegm_castIn"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 719, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRaySegm_castIn"});
		}
	}
	,testRaySegm_castOut: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastOut();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 727, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRaySegm_castOut"});
			var dstres;
			var dstx;
			var dsty;
			var dx1dy2 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var dx2dy1 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.bx0 * dx1dy2 - data1.ax0 * dx2dy1 - (data1.by0 - data1.ay0) * (data1.ax1 - data1.ax0) * (data1.bx1 - data1.bx0)) * isp;
			dsty = (data1.ay0 * dx1dy2 - data1.by0 * dx2dy1 + (data1.bx0 - data1.ax0) * (data1.ay1 - data1.ay0) * (data1.by1 - data1.by0)) * isp;
			if((data1.ax1 - data1.ax0) * (dstx - data1.ax0) + (data1.ay1 - data1.ay0) * (dsty - data1.ay0) >= 0) {
				dstres = ((data1.bx1 - data1.bx0) * (dstx - data1.bx0) + (data1.by1 - data1.by0) * (dsty - data1.by0)) * ((data1.bx1 - data1.bx0) * (dstx - (data1.bx0 + (data1.bx1 - data1.bx0))) + (data1.by1 - data1.by0) * (dsty - (data1.by0 + (data1.by1 - data1.by0)))) <= 0;
			} else {
				dstres = false;
			}
			massive_munit_Assert.isFalse(dstres,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 736, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRaySegm_castOut"});
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 737, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRaySegm_castOut"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 738, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRaySegm_castOut"});
		}
	}
	,testRaySegm_castAway: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastAway();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 746, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRaySegm_castAway"});
			var dstres;
			var dstx;
			var dsty;
			var dx1dy2 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var dx2dy1 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.bx0 * dx1dy2 - data1.ax0 * dx2dy1 - (data1.by0 - data1.ay0) * (data1.ax1 - data1.ax0) * (data1.bx1 - data1.bx0)) * isp;
			dsty = (data1.ay0 * dx1dy2 - data1.by0 * dx2dy1 + (data1.bx0 - data1.ax0) * (data1.ay1 - data1.ay0) * (data1.by1 - data1.by0)) * isp;
			if((data1.ax1 - data1.ax0) * (dstx - data1.ax0) + (data1.ay1 - data1.ay0) * (dsty - data1.ay0) >= 0) {
				dstres = ((data1.bx1 - data1.bx0) * (dstx - data1.bx0) + (data1.by1 - data1.by0) * (dsty - data1.by0)) * ((data1.bx1 - data1.bx0) * (dstx - (data1.bx0 + (data1.bx1 - data1.bx0))) + (data1.by1 - data1.by0) * (dsty - (data1.by0 + (data1.by1 - data1.by0)))) <= 0;
			} else {
				dstres = false;
			}
			massive_munit_Assert.isFalse(dstres,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 755, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRaySegm_castAway"});
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 756, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRaySegm_castAway"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 757, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRaySegm_castAway"});
		}
	}
	,testRaySegm_parallel: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forParallel();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 765, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRaySegm_parallel"});
			var dstres;
			var dstx;
			var dsty;
			var dx1dy2 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var dx2dy1 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.bx0 * dx1dy2 - data1.ax0 * dx2dy1 - (data1.by0 - data1.ay0) * (data1.ax1 - data1.ax0) * (data1.bx1 - data1.bx0)) * isp;
			dsty = (data1.ay0 * dx1dy2 - data1.by0 * dx2dy1 + (data1.bx0 - data1.ax0) * (data1.ay1 - data1.ay0) * (data1.by1 - data1.by0)) * isp;
			if((data1.ax1 - data1.ax0) * (dstx - data1.ax0) + (data1.ay1 - data1.ay0) * (dsty - data1.ay0) >= 0) {
				dstres = ((data1.bx1 - data1.bx0) * (dstx - data1.bx0) + (data1.by1 - data1.by0) * (dsty - data1.by0)) * ((data1.bx1 - data1.bx0) * (dstx - (data1.bx0 + (data1.bx1 - data1.bx0))) + (data1.by1 - data1.by0) * (dsty - (data1.by0 + (data1.by1 - data1.by0)))) <= 0;
			} else {
				dstres = false;
			}
			massive_munit_Assert.isFalse(dstres,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 774, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRaySegm_parallel"});
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 775, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRaySegm_parallel"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 776, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testRaySegm_parallel"});
		}
	}
	,testSegmSegm_cross: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCross();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 788, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testSegmSegm_cross"});
			var dstres;
			var dstx;
			var dsty;
			var dx1dy2 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var dx2dy1 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.bx0 * dx1dy2 - data1.ax0 * dx2dy1 - (data1.by0 - data1.ay0) * (data1.ax1 - data1.ax0) * (data1.bx1 - data1.bx0)) * isp;
			dsty = (data1.ay0 * dx1dy2 - data1.by0 * dx2dy1 + (data1.bx0 - data1.ax0) * (data1.ay1 - data1.ay0) * (data1.by1 - data1.by0)) * isp;
			if(((data1.ax1 - data1.ax0) * (dstx - data1.ax0) + (data1.ay1 - data1.ay0) * (dsty - data1.ay0)) * ((data1.ax1 - data1.ax0) * (dstx - (data1.ax0 + (data1.ax1 - data1.ax0))) + (data1.ay1 - data1.ay0) * (dsty - (data1.ay0 + (data1.ay1 - data1.ay0)))) <= 0) {
				dstres = ((data1.bx1 - data1.bx0) * (dstx - data1.bx0) + (data1.by1 - data1.by0) * (dsty - data1.by0)) * ((data1.bx1 - data1.bx0) * (dstx - (data1.bx0 + (data1.bx1 - data1.bx0))) + (data1.by1 - data1.by0) * (dsty - (data1.by0 + (data1.by1 - data1.by0)))) <= 0;
			} else {
				dstres = false;
			}
			massive_munit_Assert.isTrue(dstres,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 797, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testSegmSegm_cross"});
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 798, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testSegmSegm_cross"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 799, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testSegmSegm_cross"});
		}
	}
	,testSegmSegm_touch: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forTouch();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 807, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testSegmSegm_touch"});
			var dstres;
			var dstx;
			var dsty;
			var dx1dy2 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var dx2dy1 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.bx0 * dx1dy2 - data1.ax0 * dx2dy1 - (data1.by0 - data1.ay0) * (data1.ax1 - data1.ax0) * (data1.bx1 - data1.bx0)) * isp;
			dsty = (data1.ay0 * dx1dy2 - data1.by0 * dx2dy1 + (data1.bx0 - data1.ax0) * (data1.ay1 - data1.ay0) * (data1.by1 - data1.by0)) * isp;
			if(((data1.ax1 - data1.ax0) * (dstx - data1.ax0) + (data1.ay1 - data1.ay0) * (dsty - data1.ay0)) * ((data1.ax1 - data1.ax0) * (dstx - (data1.ax0 + (data1.ax1 - data1.ax0))) + (data1.ay1 - data1.ay0) * (dsty - (data1.ay0 + (data1.ay1 - data1.ay0)))) <= 0) {
				dstres = ((data1.bx1 - data1.bx0) * (dstx - data1.bx0) + (data1.by1 - data1.by0) * (dsty - data1.by0)) * ((data1.bx1 - data1.bx0) * (dstx - (data1.bx0 + (data1.bx1 - data1.bx0))) + (data1.by1 - data1.by0) * (dsty - (data1.by0 + (data1.by1 - data1.by0)))) <= 0;
			} else {
				dstres = false;
			}
			massive_munit_Assert.isTrue(dstres,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 816, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testSegmSegm_touch"});
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 817, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testSegmSegm_touch"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 818, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testSegmSegm_touch"});
		}
	}
	,testSegmSegm_projectIn: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forProjectIn();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 826, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testSegmSegm_projectIn"});
			var dstres;
			var dstx;
			var dsty;
			var dx1dy2 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var dx2dy1 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.bx0 * dx1dy2 - data1.ax0 * dx2dy1 - (data1.by0 - data1.ay0) * (data1.ax1 - data1.ax0) * (data1.bx1 - data1.bx0)) * isp;
			dsty = (data1.ay0 * dx1dy2 - data1.by0 * dx2dy1 + (data1.bx0 - data1.ax0) * (data1.ay1 - data1.ay0) * (data1.by1 - data1.by0)) * isp;
			if(((data1.ax1 - data1.ax0) * (dstx - data1.ax0) + (data1.ay1 - data1.ay0) * (dsty - data1.ay0)) * ((data1.ax1 - data1.ax0) * (dstx - (data1.ax0 + (data1.ax1 - data1.ax0))) + (data1.ay1 - data1.ay0) * (dsty - (data1.ay0 + (data1.ay1 - data1.ay0)))) <= 0) {
				dstres = ((data1.bx1 - data1.bx0) * (dstx - data1.bx0) + (data1.by1 - data1.by0) * (dsty - data1.by0)) * ((data1.bx1 - data1.bx0) * (dstx - (data1.bx0 + (data1.bx1 - data1.bx0))) + (data1.by1 - data1.by0) * (dsty - (data1.by0 + (data1.by1 - data1.by0)))) <= 0;
			} else {
				dstres = false;
			}
			massive_munit_Assert.isFalse(dstres,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 835, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testSegmSegm_projectIn"});
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 836, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testSegmSegm_projectIn"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 837, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testSegmSegm_projectIn"});
		}
	}
	,testSegmSegm_projectOut: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forProjectOut();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 845, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testSegmSegm_projectOut"});
			var dstres;
			var dstx;
			var dsty;
			var dx1dy2 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var dx2dy1 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.bx0 * dx1dy2 - data1.ax0 * dx2dy1 - (data1.by0 - data1.ay0) * (data1.ax1 - data1.ax0) * (data1.bx1 - data1.bx0)) * isp;
			dsty = (data1.ay0 * dx1dy2 - data1.by0 * dx2dy1 + (data1.bx0 - data1.ax0) * (data1.ay1 - data1.ay0) * (data1.by1 - data1.by0)) * isp;
			if(((data1.ax1 - data1.ax0) * (dstx - data1.ax0) + (data1.ay1 - data1.ay0) * (dsty - data1.ay0)) * ((data1.ax1 - data1.ax0) * (dstx - (data1.ax0 + (data1.ax1 - data1.ax0))) + (data1.ay1 - data1.ay0) * (dsty - (data1.ay0 + (data1.ay1 - data1.ay0)))) <= 0) {
				dstres = ((data1.bx1 - data1.bx0) * (dstx - data1.bx0) + (data1.by1 - data1.by0) * (dsty - data1.by0)) * ((data1.bx1 - data1.bx0) * (dstx - (data1.bx0 + (data1.bx1 - data1.bx0))) + (data1.by1 - data1.by0) * (dsty - (data1.by0 + (data1.by1 - data1.by0)))) <= 0;
			} else {
				dstres = false;
			}
			massive_munit_Assert.isFalse(dstres,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 854, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testSegmSegm_projectOut"});
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 855, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testSegmSegm_projectOut"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 856, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testSegmSegm_projectOut"});
		}
	}
	,testSegmSegm_castIn: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastIn();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 864, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testSegmSegm_castIn"});
			var dstres;
			var dstx;
			var dsty;
			var dx1dy2 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var dx2dy1 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.bx0 * dx1dy2 - data1.ax0 * dx2dy1 - (data1.by0 - data1.ay0) * (data1.ax1 - data1.ax0) * (data1.bx1 - data1.bx0)) * isp;
			dsty = (data1.ay0 * dx1dy2 - data1.by0 * dx2dy1 + (data1.bx0 - data1.ax0) * (data1.ay1 - data1.ay0) * (data1.by1 - data1.by0)) * isp;
			if(((data1.ax1 - data1.ax0) * (dstx - data1.ax0) + (data1.ay1 - data1.ay0) * (dsty - data1.ay0)) * ((data1.ax1 - data1.ax0) * (dstx - (data1.ax0 + (data1.ax1 - data1.ax0))) + (data1.ay1 - data1.ay0) * (dsty - (data1.ay0 + (data1.ay1 - data1.ay0)))) <= 0) {
				dstres = ((data1.bx1 - data1.bx0) * (dstx - data1.bx0) + (data1.by1 - data1.by0) * (dsty - data1.by0)) * ((data1.bx1 - data1.bx0) * (dstx - (data1.bx0 + (data1.bx1 - data1.bx0))) + (data1.by1 - data1.by0) * (dsty - (data1.by0 + (data1.by1 - data1.by0)))) <= 0;
			} else {
				dstres = false;
			}
			massive_munit_Assert.isFalse(dstres,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 873, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testSegmSegm_castIn"});
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 874, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testSegmSegm_castIn"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 875, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testSegmSegm_castIn"});
		}
	}
	,testSegmSegm_castOut: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastOut();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 883, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testSegmSegm_castOut"});
			var dstres;
			var dstx;
			var dsty;
			var dx1dy2 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var dx2dy1 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.bx0 * dx1dy2 - data1.ax0 * dx2dy1 - (data1.by0 - data1.ay0) * (data1.ax1 - data1.ax0) * (data1.bx1 - data1.bx0)) * isp;
			dsty = (data1.ay0 * dx1dy2 - data1.by0 * dx2dy1 + (data1.bx0 - data1.ax0) * (data1.ay1 - data1.ay0) * (data1.by1 - data1.by0)) * isp;
			if(((data1.ax1 - data1.ax0) * (dstx - data1.ax0) + (data1.ay1 - data1.ay0) * (dsty - data1.ay0)) * ((data1.ax1 - data1.ax0) * (dstx - (data1.ax0 + (data1.ax1 - data1.ax0))) + (data1.ay1 - data1.ay0) * (dsty - (data1.ay0 + (data1.ay1 - data1.ay0)))) <= 0) {
				dstres = ((data1.bx1 - data1.bx0) * (dstx - data1.bx0) + (data1.by1 - data1.by0) * (dsty - data1.by0)) * ((data1.bx1 - data1.bx0) * (dstx - (data1.bx0 + (data1.bx1 - data1.bx0))) + (data1.by1 - data1.by0) * (dsty - (data1.by0 + (data1.by1 - data1.by0)))) <= 0;
			} else {
				dstres = false;
			}
			massive_munit_Assert.isFalse(dstres,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 892, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testSegmSegm_castOut"});
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 893, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testSegmSegm_castOut"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 894, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testSegmSegm_castOut"});
		}
	}
	,testSegmSegm_castAway: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forCastAway();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 902, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testSegmSegm_castAway"});
			var dstres;
			var dstx;
			var dsty;
			var dx1dy2 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var dx2dy1 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.bx0 * dx1dy2 - data1.ax0 * dx2dy1 - (data1.by0 - data1.ay0) * (data1.ax1 - data1.ax0) * (data1.bx1 - data1.bx0)) * isp;
			dsty = (data1.ay0 * dx1dy2 - data1.by0 * dx2dy1 + (data1.bx0 - data1.ax0) * (data1.ay1 - data1.ay0) * (data1.by1 - data1.by0)) * isp;
			if(((data1.ax1 - data1.ax0) * (dstx - data1.ax0) + (data1.ay1 - data1.ay0) * (dsty - data1.ay0)) * ((data1.ax1 - data1.ax0) * (dstx - (data1.ax0 + (data1.ax1 - data1.ax0))) + (data1.ay1 - data1.ay0) * (dsty - (data1.ay0 + (data1.ay1 - data1.ay0)))) <= 0) {
				dstres = ((data1.bx1 - data1.bx0) * (dstx - data1.bx0) + (data1.by1 - data1.by0) * (dsty - data1.by0)) * ((data1.bx1 - data1.bx0) * (dstx - (data1.bx0 + (data1.bx1 - data1.bx0))) + (data1.by1 - data1.by0) * (dsty - (data1.by0 + (data1.by1 - data1.by0)))) <= 0;
			} else {
				dstres = false;
			}
			massive_munit_Assert.isFalse(dstres,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 911, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testSegmSegm_castAway"});
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 912, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testSegmSegm_castAway"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 913, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testSegmSegm_castAway"});
		}
	}
	,testSegmSegm_parallel: function() {
		var _g = 0;
		var _g1 = data_LineIntersecTestData.forParallel();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 921, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testSegmSegm_parallel"});
			var dstres;
			var dstx;
			var dsty;
			var dx1dy2 = (data1.ax1 - data1.ax0) * (data1.by1 - data1.by0);
			var dx2dy1 = (data1.bx1 - data1.bx0) * (data1.ay1 - data1.ay0);
			var isp = 1.0 / (dx1dy2 - dx2dy1);
			dstx = (data1.bx0 * dx1dy2 - data1.ax0 * dx2dy1 - (data1.by0 - data1.ay0) * (data1.ax1 - data1.ax0) * (data1.bx1 - data1.bx0)) * isp;
			dsty = (data1.ay0 * dx1dy2 - data1.by0 * dx2dy1 + (data1.bx0 - data1.ax0) * (data1.ay1 - data1.ay0) * (data1.by1 - data1.by0)) * isp;
			if(((data1.ax1 - data1.ax0) * (dstx - data1.ax0) + (data1.ay1 - data1.ay0) * (dsty - data1.ay0)) * ((data1.ax1 - data1.ax0) * (dstx - (data1.ax0 + (data1.ax1 - data1.ax0))) + (data1.ay1 - data1.ay0) * (dsty - (data1.ay0 + (data1.ay1 - data1.ay0)))) <= 0) {
				dstres = ((data1.bx1 - data1.bx0) * (dstx - data1.bx0) + (data1.by1 - data1.by0) * (dsty - data1.by0)) * ((data1.bx1 - data1.bx0) * (dstx - (data1.bx0 + (data1.bx1 - data1.bx0))) + (data1.by1 - data1.by0) * (dsty - (data1.by0 + (data1.by1 - data1.by0)))) <= 0;
			} else {
				dstres = false;
			}
			massive_munit_Assert.isFalse(dstres,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 930, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testSegmSegm_parallel"});
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 931, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testSegmSegm_parallel"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "LineIntersecMacrosTest.hx", lineNumber : 932, className : "iodev.geom2.macros.LineIntersecMacrosTest", methodName : "testSegmSegm_parallel"});
		}
	}
	,__class__: iodev_geom2_macros_LineIntersecMacrosTest
};
var iodev_geom2_macros_PrimitiveMacros = function() { };
$hxClasses["iodev.geom2.macros.PrimitiveMacros"] = iodev_geom2_macros_PrimitiveMacros;
iodev_geom2_macros_PrimitiveMacros.__name__ = ["iodev","geom2","macros","PrimitiveMacros"];
var iodev_geom2_macros_SpaceTestMacros = function() { };
$hxClasses["iodev.geom2.macros.SpaceTestMacros"] = iodev_geom2_macros_SpaceTestMacros;
iodev_geom2_macros_SpaceTestMacros.__name__ = ["iodev","geom2","macros","SpaceTestMacros"];
var iodev_geom2_macros_VecMacros = function() { };
$hxClasses["iodev.geom2.macros.VecMacros"] = iodev_geom2_macros_VecMacros;
iodev_geom2_macros_VecMacros.__name__ = ["iodev","geom2","macros","VecMacros"];
var iodev_geom2_macros_VecMacrosTest = function() { };
$hxClasses["iodev.geom2.macros.VecMacrosTest"] = iodev_geom2_macros_VecMacrosTest;
iodev_geom2_macros_VecMacrosTest.__name__ = ["iodev","geom2","macros","VecMacrosTest"];
iodev_geom2_macros_VecMacrosTest.prototype = {
	testArrayFromTwoOrLess_two: function() {
		var ax = Math.random();
		var ay = Math.random();
		var bx = Math.random();
		var by = Math.random();
		var cnt = 2;
		var arr = null;
		if(cnt == 2) {
			arr = [new iodev_geom2_Vec(ax,ay),new iodev_geom2_Vec(bx,by)];
		} else if(cnt == 1) {
			arr = [new iodev_geom2_Vec(ax,ay)];
		} else {
			arr = [];
		}
		massive_munit_Assert.isNotNull(arr,{ fileName : "VecMacrosTest.hx", lineNumber : 20, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testArrayFromTwoOrLess_two"});
		massive_munit_Assert.areEqual(cnt,arr.length,{ fileName : "VecMacrosTest.hx", lineNumber : 21, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testArrayFromTwoOrLess_two"});
		MathAssert.floatEqual(ax,arr[0].x,{ fileName : "VecMacrosTest.hx", lineNumber : 22, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testArrayFromTwoOrLess_two"});
		MathAssert.floatEqual(ay,arr[0].y,{ fileName : "VecMacrosTest.hx", lineNumber : 23, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testArrayFromTwoOrLess_two"});
		MathAssert.floatEqual(bx,arr[1].x,{ fileName : "VecMacrosTest.hx", lineNumber : 24, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testArrayFromTwoOrLess_two"});
		MathAssert.floatEqual(by,arr[1].y,{ fileName : "VecMacrosTest.hx", lineNumber : 25, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testArrayFromTwoOrLess_two"});
	}
	,testArrayFromTwoOrLess_one: function() {
		var ax = Math.random();
		var ay = Math.random();
		var arr = null;
		arr = [new iodev_geom2_Vec(ax,ay)];
		massive_munit_Assert.isNotNull(arr,{ fileName : "VecMacrosTest.hx", lineNumber : 36, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testArrayFromTwoOrLess_one"});
		massive_munit_Assert.areEqual(1,arr.length,{ fileName : "VecMacrosTest.hx", lineNumber : 37, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testArrayFromTwoOrLess_one"});
		MathAssert.floatEqual(ax,arr[0].x,{ fileName : "VecMacrosTest.hx", lineNumber : 38, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testArrayFromTwoOrLess_one"});
		MathAssert.floatEqual(ay,arr[0].y,{ fileName : "VecMacrosTest.hx", lineNumber : 39, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testArrayFromTwoOrLess_one"});
	}
	,testArrayFromTwoOrLess_zero: function() {
		var arr = null;
		arr = [];
		massive_munit_Assert.isNotNull(arr,{ fileName : "VecMacrosTest.hx", lineNumber : 48, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testArrayFromTwoOrLess_zero"});
		massive_munit_Assert.areEqual(0,arr.length,{ fileName : "VecMacrosTest.hx", lineNumber : 49, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testArrayFromTwoOrLess_zero"});
	}
	,testEquals: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forEquals();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecMacrosTest.hx", lineNumber : 56, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testEquals"});
			var a = new iodev_geom2_Vec(data1.ax,data1.ay);
			var b = new iodev_geom2_Vec(data1.bx,data1.by);
			var res = a.x == b.x && a.y == b.y;
			massive_munit_Assert.areEqual(res,data1.res,{ fileName : "VecMacrosTest.hx", lineNumber : 62, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testEquals"});
		}
	}
	,testNegate: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forNegate();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecMacrosTest.hx", lineNumber : 70, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testNegate"});
			var a = new iodev_geom2_Vec(data1.ax,data1.ay);
			var dst = new iodev_geom2_Vec();
			dst.x = -a.x;
			dst.y = -a.y;
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "VecMacrosTest.hx", lineNumber : 76, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testNegate"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "VecMacrosTest.hx", lineNumber : 77, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testNegate"});
		}
	}
	,testSwapXY: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forSwapXY();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecMacrosTest.hx", lineNumber : 85, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testSwapXY"});
			var a = new iodev_geom2_Vec(data1.ax,data1.ay);
			var dst = new iodev_geom2_Vec();
			var t = a.x;
			dst.x = a.y;
			dst.y = t;
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "VecMacrosTest.hx", lineNumber : 91, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testSwapXY"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "VecMacrosTest.hx", lineNumber : 92, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testSwapXY"});
		}
	}
	,testSwapVecs: function() {
		var outax;
		var outay;
		var outbx;
		var outby;
		outax = Math.random();
		var ax = outax;
		outay = Math.random();
		var ay = outay;
		outbx = Math.random();
		var bx = outbx;
		outby = Math.random();
		var by = outby;
		var t = outax;
		outax = outbx;
		outbx = t;
		t = outay;
		outay = outby;
		outby = t;
		MathAssert.floatEqual(ax,outbx,{ fileName : "VecMacrosTest.hx", lineNumber : 106, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testSwapVecs"});
		MathAssert.floatEqual(ay,outby,{ fileName : "VecMacrosTest.hx", lineNumber : 107, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testSwapVecs"});
		MathAssert.floatEqual(bx,outax,{ fileName : "VecMacrosTest.hx", lineNumber : 108, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testSwapVecs"});
		MathAssert.floatEqual(by,outay,{ fileName : "VecMacrosTest.hx", lineNumber : 109, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testSwapVecs"});
	}
	,testAdd: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forAdd();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecMacrosTest.hx", lineNumber : 116, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testAdd"});
			var a = new iodev_geom2_Vec(data1.ax,data1.ay);
			var b = new iodev_geom2_Vec(data1.bx,data1.by);
			var dst = new iodev_geom2_Vec();
			dst.x = a.x + b.x;
			dst.y = a.y + b.y;
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "VecMacrosTest.hx", lineNumber : 123, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testAdd"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "VecMacrosTest.hx", lineNumber : 124, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testAdd"});
		}
	}
	,testSub: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forSub();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecMacrosTest.hx", lineNumber : 132, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testSub"});
			var a = new iodev_geom2_Vec(data1.ax,data1.ay);
			var b = new iodev_geom2_Vec(data1.bx,data1.by);
			var dst = new iodev_geom2_Vec();
			dst.x = a.x - b.x;
			dst.y = a.y - b.y;
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "VecMacrosTest.hx", lineNumber : 139, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testSub"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "VecMacrosTest.hx", lineNumber : 140, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testSub"});
		}
	}
	,testMul: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forMul();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecMacrosTest.hx", lineNumber : 148, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testMul"});
			var a = new iodev_geom2_Vec(data1.ax,data1.ay);
			var b = new iodev_geom2_Vec(data1.bx,data1.by);
			var dst = new iodev_geom2_Vec();
			dst.x = a.x * b.x;
			dst.y = a.y * b.y;
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "VecMacrosTest.hx", lineNumber : 155, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testMul"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "VecMacrosTest.hx", lineNumber : 156, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testMul"});
		}
	}
	,testDiv: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forDiv();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecMacrosTest.hx", lineNumber : 164, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testDiv"});
			var a = new iodev_geom2_Vec(data1.ax,data1.ay);
			var b = new iodev_geom2_Vec(data1.bx,data1.by);
			var dst = new iodev_geom2_Vec();
			dst.x = a.x / b.x;
			dst.y = a.y / b.y;
			MathAssert.floatEqual(data1.dstx,dst.x,{ fileName : "VecMacrosTest.hx", lineNumber : 171, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testDiv"});
			MathAssert.floatEqual(data1.dsty,dst.y,{ fileName : "VecMacrosTest.hx", lineNumber : 172, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testDiv"});
		}
	}
	,testMagnitude: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forMagnitude();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecMacrosTest.hx", lineNumber : 180, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testMagnitude"});
			var mag = data1.x * data1.x + data1.y * data1.y;
			MathAssert.floatEqual(data1.mag,mag,{ fileName : "VecMacrosTest.hx", lineNumber : 184, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testMagnitude"});
		}
	}
	,testMagnitudeBetween: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forMagnitudeBetween();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecMacrosTest.hx", lineNumber : 192, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testMagnitudeBetween"});
			var vX = data1.bx - data1.ax;
			var vY = data1.by - data1.ay;
			var res = vX * vX + vY * vY;
			MathAssert.floatEqual(data1.res,res,{ fileName : "VecMacrosTest.hx", lineNumber : 196, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testMagnitudeBetween"});
		}
	}
	,testNormalize: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forNormalize();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecMacrosTest.hx", lineNumber : 204, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testNormalize"});
			var nx = 0;
			var ny = 0;
			var m = data1.nlen / Math.sqrt(data1.x * data1.x + data1.y * data1.y);
			nx = m * data1.x;
			ny = m * data1.y;
			MathAssert.floatEqual(data1.nx,nx,{ fileName : "VecMacrosTest.hx", lineNumber : 210, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testNormalize"});
			MathAssert.floatEqual(data1.ny,ny,{ fileName : "VecMacrosTest.hx", lineNumber : 211, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testNormalize"});
		}
	}
	,testLength: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forLength();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecMacrosTest.hx", lineNumber : 219, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testLength"});
			var vx = data1.x;
			var vy = data1.y;
			var len = Math.sqrt(vx * vx + vy * vy);
			MathAssert.floatEqual(data1.len,len,{ fileName : "VecMacrosTest.hx", lineNumber : 225, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testLength"});
		}
	}
	,testLengthBetween: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forLengthBetween();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecMacrosTest.hx", lineNumber : 234, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testLengthBetween"});
			var vX = data1.bx - data1.ax;
			var vY = data1.by - data1.ay;
			var res = Math.sqrt(vX * vX + vY * vY);
			MathAssert.floatEqual(data1.res,res,{ fileName : "VecMacrosTest.hx", lineNumber : 237, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testLengthBetween"});
		}
	}
	,testDotProd: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forDotProd();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecMacrosTest.hx", lineNumber : 246, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testDotProd"});
			var res = data1.ax * data1.bx + data1.ay * data1.by;
			MathAssert.floatEqual(data1.res,res,{ fileName : "VecMacrosTest.hx", lineNumber : 249, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testDotProd"});
		}
	}
	,testSkewProd: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forSkewProd();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecMacrosTest.hx", lineNumber : 258, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testSkewProd"});
			var res = data1.ax * data1.by - data1.ay * data1.bx;
			MathAssert.floatEqual(data1.res,res,{ fileName : "VecMacrosTest.hx", lineNumber : 261, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testSkewProd"});
		}
	}
	,testPolar: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forPolar();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecMacrosTest.hx", lineNumber : 270, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testPolar"});
			var dstx;
			var dsty;
			dstx = data1.len * Math.cos(data1.radians);
			dsty = data1.len * Math.sin(data1.radians);
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "VecMacrosTest.hx", lineNumber : 275, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testPolar"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "VecMacrosTest.hx", lineNumber : 276, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testPolar"});
		}
	}
	,testRadiansOf: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forRadiansOf();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecMacrosTest.hx", lineNumber : 285, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testRadiansOf"});
			var res = Math.atan2(data1.y,data1.x);
			MathAssert.floatEqual(data1.res,res,{ fileName : "VecMacrosTest.hx", lineNumber : 288, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testRadiansOf"});
		}
	}
	,testRadiansBetween: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forRadiansBetween();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecMacrosTest.hx", lineNumber : 297, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testRadiansBetween"});
			var normAX;
			var normAY;
			var normBX;
			var normBY;
			var m = 1.0 / Math.sqrt(data1.ax * data1.ax + data1.ay * data1.ay);
			normAX = m * data1.ax;
			normAY = m * data1.ay;
			var m1 = 1.0 / Math.sqrt(data1.bx * data1.bx + data1.by * data1.by);
			normBX = m1 * data1.bx;
			normBY = m1 * data1.by;
			var res = Math.acos(normAX * normBX + normAY * normBY);
			MathAssert.floatEqual(data1.res,res,{ fileName : "VecMacrosTest.hx", lineNumber : 300, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testRadiansBetween"});
		}
	}
	,testRadiansBetweenNormals: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forRadiansBetweenNormals();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecMacrosTest.hx", lineNumber : 309, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testRadiansBetweenNormals"});
			var res = Math.acos(data1.ax * data1.bx + data1.ay * data1.by);
			MathAssert.floatEqual(data1.res,res,{ fileName : "VecMacrosTest.hx", lineNumber : 312, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testRadiansBetweenNormals"});
		}
	}
	,testRadiansBetweenNormals_unnormalized: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forRadiansBetween_notnormal();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecMacrosTest.hx", lineNumber : 320, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testRadiansBetweenNormals_unnormalized"});
			var res = Math.acos(data1.ax * data1.bx + data1.ay * data1.by);
			MathAssert.floatNotEqual(data1.res,res,{ fileName : "VecMacrosTest.hx", lineNumber : 323, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testRadiansBetweenNormals_unnormalized"});
		}
	}
	,testNormalBisector: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forNormalBisector();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecMacrosTest.hx", lineNumber : 332, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testNormalBisector"});
			var dstx;
			var dsty;
			var normAX;
			var normAY;
			var normBX;
			var normBY;
			var sumX;
			var sumY;
			var m = 1.0 / Math.sqrt(data1.ax * data1.ax + data1.ay * data1.ay);
			normAX = m * data1.ax;
			normAY = m * data1.ay;
			var m1 = 1.0 / Math.sqrt(data1.bx * data1.bx + data1.by * data1.by);
			normBX = m1 * data1.bx;
			normBY = m1 * data1.by;
			sumX = normAX + normBX;
			sumY = normAY + normBY;
			var m2 = 1.0 / Math.sqrt(sumX * sumX + sumY * sumY);
			dstx = m2 * sumX;
			dsty = m2 * sumY;
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "VecMacrosTest.hx", lineNumber : 337, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testNormalBisector"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "VecMacrosTest.hx", lineNumber : 338, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testNormalBisector"});
		}
	}
	,testRotate: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forRotate();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecMacrosTest.hx", lineNumber : 347, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testRotate"});
			var dstx;
			var dsty;
			var sn = Math.sin(data1.rad);
			var cs = Math.cos(data1.rad);
			var sx = data1.x;
			dstx = sx * cs - data1.y * sn;
			dsty = sx * sn + data1.y * cs;
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "VecMacrosTest.hx", lineNumber : 352, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testRotate"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "VecMacrosTest.hx", lineNumber : 353, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testRotate"});
		}
	}
	,testRotateQuart: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forRotateQuart();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecMacrosTest.hx", lineNumber : 362, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testRotateQuart"});
			var times = data1.times;
			var dstx;
			var dsty;
			var n = (4 + times % 4) % 4;
			var sn = (2 - n) % 2;
			var cs = (1 - n) % 2;
			var sx = data1.x;
			dstx = sx * cs - data1.y * sn;
			dsty = sx * sn + data1.y * cs;
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "VecMacrosTest.hx", lineNumber : 368, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testRotateQuart"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "VecMacrosTest.hx", lineNumber : 369, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testRotateQuart"});
		}
	}
	,testMirrorBy: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forMirrorBy();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecMacrosTest.hx", lineNumber : 378, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testMirrorBy"});
			var dstx;
			var dsty;
			var nx;
			var ny;
			var m = 1.0 / Math.sqrt(data1.dirx * data1.dirx + data1.diry * data1.diry);
			nx = m * data1.dirx;
			ny = m * data1.diry;
			var rx = ny;
			var ry = -nx;
			var m1 = -2.0 * (data1.vx * rx + data1.vy * ry);
			dstx = data1.vx + m1 * rx;
			dsty = data1.vy + m1 * ry;
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "VecMacrosTest.hx", lineNumber : 383, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testMirrorBy"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "VecMacrosTest.hx", lineNumber : 384, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testMirrorBy"});
		}
	}
	,testMirrorByNormal: function() {
		var _g = 0;
		var _g1 = data_VecTestData.forMirrorByNormal();
		while(_g < _g1.length) {
			var data1 = _g1[_g];
			++_g;
			haxe_Log.trace(data1.title,{ fileName : "VecMacrosTest.hx", lineNumber : 393, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testMirrorByNormal"});
			var dstx;
			var dsty;
			var rx = data1.diry;
			var ry = -data1.dirx;
			var m = -2.0 * (data1.vx * rx + data1.vy * ry);
			dstx = data1.vx + m * rx;
			dsty = data1.vy + m * ry;
			MathAssert.floatEqual(data1.dstx,dstx,{ fileName : "VecMacrosTest.hx", lineNumber : 398, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testMirrorByNormal"});
			MathAssert.floatEqual(data1.dsty,dsty,{ fileName : "VecMacrosTest.hx", lineNumber : 399, className : "iodev.geom2.macros.VecMacrosTest", methodName : "testMirrorByNormal"});
		}
	}
	,__class__: iodev_geom2_macros_VecMacrosTest
};
var iodev_geom2_macros_VecMacrosTest_$argTest = function() { };
$hxClasses["iodev.geom2.macros.VecMacrosTest_argTest"] = iodev_geom2_macros_VecMacrosTest_$argTest;
iodev_geom2_macros_VecMacrosTest_$argTest.__name__ = ["iodev","geom2","macros","VecMacrosTest_argTest"];
iodev_geom2_macros_VecMacrosTest_$argTest.prototype = {
	testEquals_immutation: function() {
		var ax = Math.random();
		var ay = Math.random();
		var a = new iodev_geom2_Vec(ax,ay);
		var bx = Math.random();
		var by = Math.random();
		var b = new iodev_geom2_Vec(bx,by);
		var dst = new iodev_geom2_Vec();
		var tmp = a.x == b.x;
		MathAssert.floatEqual(ax,a.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 21, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testEquals_immutation"});
		MathAssert.floatEqual(ay,a.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 22, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testEquals_immutation"});
		MathAssert.floatEqual(bx,b.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 24, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testEquals_immutation"});
		MathAssert.floatEqual(by,b.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 25, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testEquals_immutation"});
	}
	,testNegate_immutation: function() {
		var ax = Math.random();
		var ay = Math.random();
		var a = new iodev_geom2_Vec(ax,ay);
		var dst = new iodev_geom2_Vec();
		dst.x = -a.x;
		dst.y = -a.y;
		MathAssert.floatEqual(ax,a.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 40, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testNegate_immutation"});
		MathAssert.floatEqual(ay,a.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 41, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testNegate_immutation"});
	}
	,testAdd_asOutput: function() {
		var ax = Math.random();
		var ay = Math.random();
		var a = new iodev_geom2_Vec(ax,ay);
		var dst = a;
		dst.x = -a.x;
		dst.y = -a.y;
		MathAssert.floatNotEqual(ax,a.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 54, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testAdd_asOutput"});
		MathAssert.floatNotEqual(ay,a.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 55, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testAdd_asOutput"});
	}
	,testSwapXY_immutation: function() {
		var ax = Math.random();
		var ay = Math.random();
		var a = new iodev_geom2_Vec(ax,ay);
		var dst = new iodev_geom2_Vec();
		var t = a.x;
		dst.x = a.y;
		dst.y = t;
		MathAssert.floatEqual(ax,a.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 70, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testSwapXY_immutation"});
		MathAssert.floatEqual(ay,a.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 71, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testSwapXY_immutation"});
	}
	,testSwapXY_asOutput: function() {
		var ax = Math.random();
		var ay = Math.random();
		var a = new iodev_geom2_Vec(ax,ay);
		var dst = a;
		var t = a.x;
		dst.x = a.y;
		dst.y = t;
		MathAssert.floatNotEqual(ax,a.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 84, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testSwapXY_asOutput"});
		MathAssert.floatNotEqual(ay,a.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 85, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testSwapXY_asOutput"});
	}
	,testAdd_immutation: function() {
		var ax = Math.random();
		var ay = Math.random();
		var a = new iodev_geom2_Vec(ax,ay);
		var bx = Math.random();
		var by = Math.random();
		var b = new iodev_geom2_Vec(bx,by);
		var dst = new iodev_geom2_Vec();
		dst.x = a.x + b.x;
		dst.y = a.y + b.y;
		MathAssert.floatEqual(ax,a.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 104, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testAdd_immutation"});
		MathAssert.floatEqual(ay,a.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 105, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testAdd_immutation"});
		MathAssert.floatEqual(bx,b.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 107, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testAdd_immutation"});
		MathAssert.floatEqual(by,b.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 108, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testAdd_immutation"});
	}
	,testAdd_asOutput_a: function() {
		var ax = Math.random();
		var ay = Math.random();
		var a = new iodev_geom2_Vec(ax,ay);
		var bx = Math.random();
		var by = Math.random();
		var b = new iodev_geom2_Vec(bx,by);
		var dst = a;
		dst.x = a.x + b.x;
		dst.y = a.y + b.y;
		MathAssert.floatNotEqual(ax,a.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 125, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testAdd_asOutput_a"});
		MathAssert.floatNotEqual(ay,a.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 126, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testAdd_asOutput_a"});
		MathAssert.floatEqual(bx,b.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 128, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testAdd_asOutput_a"});
		MathAssert.floatEqual(by,b.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 129, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testAdd_asOutput_a"});
	}
	,testAdd_asOutput_b: function() {
		var ax = Math.random();
		var ay = Math.random();
		var a = new iodev_geom2_Vec(ax,ay);
		var bx = Math.random();
		var by = Math.random();
		var b = new iodev_geom2_Vec(bx,by);
		var dst = b;
		dst.x = a.x + b.x;
		dst.y = a.y + b.y;
		MathAssert.floatEqual(ax,a.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 146, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testAdd_asOutput_b"});
		MathAssert.floatEqual(ay,a.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 147, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testAdd_asOutput_b"});
		MathAssert.floatNotEqual(bx,b.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 149, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testAdd_asOutput_b"});
		MathAssert.floatNotEqual(by,b.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 150, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testAdd_asOutput_b"});
	}
	,testSub_immutation: function() {
		var ax = Math.random();
		var ay = Math.random();
		var a = new iodev_geom2_Vec(ax,ay);
		var bx = Math.random();
		var by = Math.random();
		var b = new iodev_geom2_Vec(bx,by);
		var dst = new iodev_geom2_Vec();
		dst.x = a.x - b.x;
		dst.y = a.y - b.y;
		MathAssert.floatEqual(ax,a.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 169, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testSub_immutation"});
		MathAssert.floatEqual(ay,a.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 170, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testSub_immutation"});
		MathAssert.floatEqual(bx,b.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 172, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testSub_immutation"});
		MathAssert.floatEqual(by,b.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 173, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testSub_immutation"});
	}
	,testSub_asOutput_a: function() {
		var ax = Math.random();
		var ay = Math.random();
		var a = new iodev_geom2_Vec(ax,ay);
		var bx = Math.random();
		var by = Math.random();
		var b = new iodev_geom2_Vec(bx,by);
		var dst = a;
		dst.x = a.x - b.x;
		dst.y = a.y - b.y;
		MathAssert.floatNotEqual(ax,a.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 190, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testSub_asOutput_a"});
		MathAssert.floatNotEqual(ay,a.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 191, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testSub_asOutput_a"});
		MathAssert.floatEqual(bx,b.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 193, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testSub_asOutput_a"});
		MathAssert.floatEqual(by,b.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 194, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testSub_asOutput_a"});
	}
	,testSub_asOutput_b: function() {
		var ax = Math.random();
		var ay = Math.random();
		var a = new iodev_geom2_Vec(ax,ay);
		var bx = Math.random();
		var by = Math.random();
		var b = new iodev_geom2_Vec(bx,by);
		var dst = b;
		dst.x = a.x - b.x;
		dst.y = a.y - b.y;
		MathAssert.floatEqual(ax,a.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 211, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testSub_asOutput_b"});
		MathAssert.floatEqual(ay,a.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 212, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testSub_asOutput_b"});
		MathAssert.floatNotEqual(bx,b.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 214, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testSub_asOutput_b"});
		MathAssert.floatNotEqual(by,b.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 215, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testSub_asOutput_b"});
	}
	,testMul_immutation: function() {
		var ax = Math.random();
		var ay = Math.random();
		var a = new iodev_geom2_Vec(ax,ay);
		var bx = Math.random();
		var by = Math.random();
		var b = new iodev_geom2_Vec(bx,by);
		var dst = new iodev_geom2_Vec();
		dst.x = a.x * b.x;
		dst.y = a.y * b.y;
		MathAssert.floatEqual(ax,a.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 234, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMul_immutation"});
		MathAssert.floatEqual(ay,a.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 235, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMul_immutation"});
		MathAssert.floatEqual(bx,b.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 237, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMul_immutation"});
		MathAssert.floatEqual(by,b.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 238, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMul_immutation"});
	}
	,testMul_asOutput_a: function() {
		var ax = Math.random();
		var ay = Math.random();
		var a = new iodev_geom2_Vec(ax,ay);
		var bx = Math.random();
		var by = Math.random();
		var b = new iodev_geom2_Vec(bx,by);
		var dst = a;
		dst.x = a.x * b.x;
		dst.y = a.y * b.y;
		MathAssert.floatNotEqual(ax,a.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 255, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMul_asOutput_a"});
		MathAssert.floatNotEqual(ay,a.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 256, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMul_asOutput_a"});
		MathAssert.floatEqual(bx,b.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 258, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMul_asOutput_a"});
		MathAssert.floatEqual(by,b.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 259, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMul_asOutput_a"});
	}
	,testMul_asOutput_b: function() {
		var ax = Math.random();
		var ay = Math.random();
		var a = new iodev_geom2_Vec(ax,ay);
		var bx = Math.random();
		var by = Math.random();
		var b = new iodev_geom2_Vec(bx,by);
		var dst = b;
		dst.x = a.x * b.x;
		dst.y = a.y * b.y;
		MathAssert.floatEqual(ax,a.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 276, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMul_asOutput_b"});
		MathAssert.floatEqual(ay,a.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 277, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMul_asOutput_b"});
		MathAssert.floatNotEqual(bx,b.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 279, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMul_asOutput_b"});
		MathAssert.floatNotEqual(by,b.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 280, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMul_asOutput_b"});
	}
	,testDiv_immutation: function() {
		var ax = 1.0 + Math.random();
		var ay = 1.0 + Math.random();
		var a = new iodev_geom2_Vec(ax,ay);
		var bx = 1.0 + Math.random();
		var by = 1.0 + Math.random();
		var b = new iodev_geom2_Vec(bx,by);
		var dst = new iodev_geom2_Vec();
		dst.x = a.x / b.x;
		dst.y = a.y / b.y;
		MathAssert.floatEqual(ax,a.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 299, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testDiv_immutation"});
		MathAssert.floatEqual(ay,a.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 300, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testDiv_immutation"});
		MathAssert.floatEqual(bx,b.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 302, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testDiv_immutation"});
		MathAssert.floatEqual(by,b.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 303, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testDiv_immutation"});
	}
	,testDiv_asOutput_a: function() {
		var ax = Math.random();
		var ay = Math.random();
		var a = new iodev_geom2_Vec(ax,ay);
		var bx = Math.random();
		var by = Math.random();
		var b = new iodev_geom2_Vec(bx,by);
		var dst = a;
		dst.x = a.x / b.x;
		dst.y = a.y / b.y;
		MathAssert.floatNotEqual(ax,a.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 320, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testDiv_asOutput_a"});
		MathAssert.floatNotEqual(ay,a.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 321, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testDiv_asOutput_a"});
		MathAssert.floatEqual(bx,b.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 323, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testDiv_asOutput_a"});
		MathAssert.floatEqual(by,b.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 324, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testDiv_asOutput_a"});
	}
	,testDiv_asOutput_b: function() {
		var ax = Math.random();
		var ay = Math.random();
		var a = new iodev_geom2_Vec(ax,ay);
		var bx = Math.random();
		var by = Math.random();
		var b = new iodev_geom2_Vec(bx,by);
		var dst = b;
		dst.x = a.x / b.x;
		dst.y = a.y / b.y;
		MathAssert.floatEqual(ax,a.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 341, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testDiv_asOutput_b"});
		MathAssert.floatEqual(ay,a.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 342, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testDiv_asOutput_b"});
		MathAssert.floatNotEqual(bx,b.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 344, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testDiv_asOutput_b"});
		MathAssert.floatNotEqual(by,b.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 345, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testDiv_asOutput_b"});
	}
	,testNormalBisector_immutation: function() {
		var ax = 1.0 + Math.random();
		var ay = 1.0 + Math.random();
		var a = new iodev_geom2_Vec(ax,ay);
		var bx = 1.0 + Math.random();
		var by = 1.0 + Math.random();
		var b = new iodev_geom2_Vec(bx,by);
		var dst = new iodev_geom2_Vec();
		var normAX;
		var normAY;
		var normBX;
		var normBY;
		var sumX;
		var sumY;
		var m = 1.0 / Math.sqrt(a.x * a.x + a.y * a.y);
		normAX = m * a.x;
		normAY = m * a.y;
		var m1 = 1.0 / Math.sqrt(b.x * b.x + b.y * b.y);
		normBX = m1 * b.x;
		normBY = m1 * b.y;
		sumX = normAX + normBX;
		sumY = normAY + normBY;
		var m2 = 1.0 / Math.sqrt(sumX * sumX + sumY * sumY);
		dst.x = m2 * sumX;
		dst.y = m2 * sumY;
		MathAssert.floatEqual(ax,a.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 364, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testNormalBisector_immutation"});
		MathAssert.floatEqual(ay,a.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 365, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testNormalBisector_immutation"});
		MathAssert.floatEqual(bx,b.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 367, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testNormalBisector_immutation"});
		MathAssert.floatEqual(by,b.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 368, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testNormalBisector_immutation"});
		massive_munit_Assert.areNotSame(a,dst,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 370, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testNormalBisector_immutation"});
		massive_munit_Assert.areNotSame(b,dst,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 371, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testNormalBisector_immutation"});
	}
	,testNormalBisector_asOutput_a: function() {
		var ax = Math.random();
		var ay = Math.random();
		var a = new iodev_geom2_Vec(ax,ay);
		var bx = Math.random();
		var by = Math.random();
		var b = new iodev_geom2_Vec(bx,by);
		var dst = a;
		var normAX;
		var normAY;
		var normBX;
		var normBY;
		var sumX;
		var sumY;
		var m = 1.0 / Math.sqrt(a.x * a.x + a.y * a.y);
		normAX = m * a.x;
		normAY = m * a.y;
		var m1 = 1.0 / Math.sqrt(b.x * b.x + b.y * b.y);
		normBX = m1 * b.x;
		normBY = m1 * b.y;
		sumX = normAX + normBX;
		sumY = normAY + normBY;
		var m2 = 1.0 / Math.sqrt(sumX * sumX + sumY * sumY);
		dst.x = m2 * sumX;
		dst.y = m2 * sumY;
		MathAssert.floatNotEqual(ax,a.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 388, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testNormalBisector_asOutput_a"});
		MathAssert.floatNotEqual(ay,a.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 389, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testNormalBisector_asOutput_a"});
		MathAssert.floatEqual(bx,b.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 391, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testNormalBisector_asOutput_a"});
		MathAssert.floatEqual(by,b.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 392, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testNormalBisector_asOutput_a"});
		massive_munit_Assert.areSame(a,dst,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 394, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testNormalBisector_asOutput_a"});
		massive_munit_Assert.areNotSame(b,dst,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 395, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testNormalBisector_asOutput_a"});
	}
	,testNormalBisector_asOutput_b: function() {
		var ax = Math.random();
		var ay = Math.random();
		var a = new iodev_geom2_Vec(ax,ay);
		var bx = Math.random();
		var by = Math.random();
		var b = new iodev_geom2_Vec(bx,by);
		var dst = b;
		var normAX;
		var normAY;
		var normBX;
		var normBY;
		var sumX;
		var sumY;
		var m = 1.0 / Math.sqrt(a.x * a.x + a.y * a.y);
		normAX = m * a.x;
		normAY = m * a.y;
		var m1 = 1.0 / Math.sqrt(b.x * b.x + b.y * b.y);
		normBX = m1 * b.x;
		normBY = m1 * b.y;
		sumX = normAX + normBX;
		sumY = normAY + normBY;
		var m2 = 1.0 / Math.sqrt(sumX * sumX + sumY * sumY);
		dst.x = m2 * sumX;
		dst.y = m2 * sumY;
		MathAssert.floatEqual(ax,a.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 412, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testNormalBisector_asOutput_b"});
		MathAssert.floatEqual(ay,a.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 413, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testNormalBisector_asOutput_b"});
		MathAssert.floatNotEqual(bx,b.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 415, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testNormalBisector_asOutput_b"});
		MathAssert.floatNotEqual(by,b.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 416, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testNormalBisector_asOutput_b"});
		massive_munit_Assert.areNotSame(a,dst,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 418, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testNormalBisector_asOutput_b"});
		massive_munit_Assert.areSame(b,dst,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 419, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testNormalBisector_asOutput_b"});
	}
	,testRotate_immutation: function() {
		var ax = 1.0 + Math.random();
		var ay = 1.0 + Math.random();
		var a = new iodev_geom2_Vec(ax,ay);
		var dst = new iodev_geom2_Vec();
		var sn = Math.sin(0.2);
		var cs = Math.cos(0.2);
		var sx = a.x;
		dst.x = sx * cs - a.y * sn;
		dst.y = sx * sn + a.y * cs;
		MathAssert.floatEqual(ax,a.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 434, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testRotate_immutation"});
		MathAssert.floatEqual(ay,a.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 435, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testRotate_immutation"});
	}
	,testRotate_asOutput: function() {
		var ax = 1.0 + Math.random();
		var ay = 1.0 + Math.random();
		var a = new iodev_geom2_Vec(ax,ay);
		var dst = a;
		var sn = Math.sin(0.2);
		var cs = Math.cos(0.2);
		var sx = a.x;
		dst.x = sx * cs - a.y * sn;
		dst.y = sx * sn + a.y * cs;
		MathAssert.floatNotEqual(ax,a.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 448, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testRotate_asOutput"});
		MathAssert.floatNotEqual(ay,a.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 449, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testRotate_asOutput"});
	}
	,testRotateQuart_immutation: function() {
		var ax = 1.0 + Math.random();
		var ay = 1.0 + Math.random();
		var a = new iodev_geom2_Vec(ax,ay);
		var dst = new iodev_geom2_Vec();
		var sn = Math.sin(-7);
		var cs = Math.cos(-7);
		var sx = a.x;
		dst.x = sx * cs - a.y * sn;
		dst.y = sx * sn + a.y * cs;
		MathAssert.floatEqual(ax,a.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 464, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testRotateQuart_immutation"});
		MathAssert.floatEqual(ay,a.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 465, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testRotateQuart_immutation"});
	}
	,testRotateQuart_asOutput: function() {
		var ax = 1.0 + Math.random();
		var ay = 1.0 + Math.random();
		var a = new iodev_geom2_Vec(ax,ay);
		var dst = a;
		var sn = Math.sin(9);
		var cs = Math.cos(9);
		var sx = a.x;
		dst.x = sx * cs - a.y * sn;
		dst.y = sx * sn + a.y * cs;
		MathAssert.floatNotEqual(ax,a.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 478, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testRotateQuart_asOutput"});
		MathAssert.floatNotEqual(ay,a.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 479, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testRotateQuart_asOutput"});
	}
	,testMirrorBy_immutation: function() {
		var ax = 1.0 + Math.random();
		var ay = 1.0 + Math.random();
		var a = new iodev_geom2_Vec(ax,ay);
		var bx = 1.0 + Math.random();
		var by = 1.0 + Math.random();
		var b = new iodev_geom2_Vec(bx,by);
		var dst = new iodev_geom2_Vec();
		var nx;
		var ny;
		var m = 1.0 / Math.sqrt(b.x * b.x + b.y * b.y);
		nx = m * b.x;
		ny = m * b.y;
		var rx = ny;
		var ry = -nx;
		var m1 = -2.0 * (a.x * rx + a.y * ry);
		dst.x = a.x + m1 * rx;
		dst.y = a.y + m1 * ry;
		MathAssert.floatEqual(ax,a.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 498, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMirrorBy_immutation"});
		MathAssert.floatEqual(ay,a.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 499, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMirrorBy_immutation"});
		MathAssert.floatEqual(bx,b.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 501, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMirrorBy_immutation"});
		MathAssert.floatEqual(by,b.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 502, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMirrorBy_immutation"});
		massive_munit_Assert.areNotSame(a,dst,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 504, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMirrorBy_immutation"});
		massive_munit_Assert.areNotSame(b,dst,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 505, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMirrorBy_immutation"});
	}
	,testMirrorBy_asOutput_a: function() {
		var ax = Math.random();
		var ay = Math.random();
		var a = new iodev_geom2_Vec(ax,ay);
		var bx = Math.random();
		var by = Math.random();
		var b = new iodev_geom2_Vec(bx,by);
		var dst = a;
		var nx;
		var ny;
		var m = 1.0 / Math.sqrt(b.x * b.x + b.y * b.y);
		nx = m * b.x;
		ny = m * b.y;
		var rx = ny;
		var ry = -nx;
		var m1 = -2.0 * (a.x * rx + a.y * ry);
		dst.x = a.x + m1 * rx;
		dst.y = a.y + m1 * ry;
		MathAssert.floatNotEqual(ax,a.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 522, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMirrorBy_asOutput_a"});
		MathAssert.floatNotEqual(ay,a.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 523, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMirrorBy_asOutput_a"});
		MathAssert.floatEqual(bx,b.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 525, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMirrorBy_asOutput_a"});
		MathAssert.floatEqual(by,b.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 526, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMirrorBy_asOutput_a"});
		massive_munit_Assert.areSame(a,dst,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 528, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMirrorBy_asOutput_a"});
		massive_munit_Assert.areNotSame(b,dst,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 529, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMirrorBy_asOutput_a"});
	}
	,testMirrorBy_asOutput_b: function() {
		var ax = Math.random();
		var ay = Math.random();
		var a = new iodev_geom2_Vec(ax,ay);
		var bx = Math.random();
		var by = Math.random();
		var b = new iodev_geom2_Vec(bx,by);
		var dst = b;
		var nx;
		var ny;
		var m = 1.0 / Math.sqrt(b.x * b.x + b.y * b.y);
		nx = m * b.x;
		ny = m * b.y;
		var rx = ny;
		var ry = -nx;
		var m1 = -2.0 * (a.x * rx + a.y * ry);
		dst.x = a.x + m1 * rx;
		dst.y = a.y + m1 * ry;
		MathAssert.floatEqual(ax,a.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 546, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMirrorBy_asOutput_b"});
		MathAssert.floatEqual(ay,a.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 547, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMirrorBy_asOutput_b"});
		MathAssert.floatNotEqual(bx,b.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 549, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMirrorBy_asOutput_b"});
		MathAssert.floatNotEqual(by,b.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 550, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMirrorBy_asOutput_b"});
		massive_munit_Assert.areNotSame(a,dst,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 552, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMirrorBy_asOutput_b"});
		massive_munit_Assert.areSame(b,dst,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 553, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMirrorBy_asOutput_b"});
	}
	,testMirrorByNormal_immutation: function() {
		var ax = 1.0 + Math.random();
		var ay = 1.0 + Math.random();
		var a = new iodev_geom2_Vec(ax,ay);
		var bx = 1.0 + Math.random();
		var by = 1.0 + Math.random();
		var b = new iodev_geom2_Vec(bx,by);
		var dst = new iodev_geom2_Vec();
		var rx = b.y;
		var ry = -b.x;
		var m = -2.0 * (a.x * rx + a.y * ry);
		dst.x = a.x + m * rx;
		dst.y = a.y + m * ry;
		MathAssert.floatEqual(ax,a.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 572, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMirrorByNormal_immutation"});
		MathAssert.floatEqual(ay,a.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 573, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMirrorByNormal_immutation"});
		MathAssert.floatEqual(bx,b.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 575, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMirrorByNormal_immutation"});
		MathAssert.floatEqual(by,b.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 576, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMirrorByNormal_immutation"});
		massive_munit_Assert.areNotSame(a,dst,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 578, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMirrorByNormal_immutation"});
		massive_munit_Assert.areNotSame(b,dst,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 579, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMirrorByNormal_immutation"});
	}
	,testMirrorByNormal_asOutput_a: function() {
		var ax = Math.random();
		var ay = Math.random();
		var a = new iodev_geom2_Vec(ax,ay);
		var bx = Math.random();
		var by = Math.random();
		var b = new iodev_geom2_Vec(bx,by);
		var dst = a;
		var rx = b.y;
		var ry = -b.x;
		var m = -2.0 * (a.x * rx + a.y * ry);
		dst.x = a.x + m * rx;
		dst.y = a.y + m * ry;
		MathAssert.floatNotEqual(ax,a.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 596, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMirrorByNormal_asOutput_a"});
		MathAssert.floatNotEqual(ay,a.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 597, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMirrorByNormal_asOutput_a"});
		MathAssert.floatEqual(bx,b.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 599, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMirrorByNormal_asOutput_a"});
		MathAssert.floatEqual(by,b.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 600, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMirrorByNormal_asOutput_a"});
		massive_munit_Assert.areSame(a,dst,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 602, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMirrorByNormal_asOutput_a"});
		massive_munit_Assert.areNotSame(b,dst,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 603, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMirrorByNormal_asOutput_a"});
	}
	,testMirrorByNormal_asOutput_b: function() {
		var ax = Math.random();
		var ay = Math.random();
		var a = new iodev_geom2_Vec(ax,ay);
		var bx = Math.random();
		var by = Math.random();
		var b = new iodev_geom2_Vec(bx,by);
		var dst = b;
		var rx = b.y;
		var ry = -b.x;
		var m = -2.0 * (a.x * rx + a.y * ry);
		dst.x = a.x + m * rx;
		dst.y = a.y + m * ry;
		MathAssert.floatEqual(ax,a.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 620, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMirrorByNormal_asOutput_b"});
		MathAssert.floatEqual(ay,a.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 621, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMirrorByNormal_asOutput_b"});
		MathAssert.floatNotEqual(bx,b.x,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 623, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMirrorByNormal_asOutput_b"});
		MathAssert.floatNotEqual(by,b.y,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 624, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMirrorByNormal_asOutput_b"});
		massive_munit_Assert.areNotSame(a,dst,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 626, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMirrorByNormal_asOutput_b"});
		massive_munit_Assert.areSame(b,dst,{ fileName : "VecMacrosTest_argTest.hx", lineNumber : 627, className : "iodev.geom2.macros.VecMacrosTest_argTest", methodName : "testMirrorByNormal_asOutput_b"});
	}
	,__class__: iodev_geom2_macros_VecMacrosTest_$argTest
};
var iodev_geom2_tests_HitTest = function() { };
$hxClasses["iodev.geom2.tests.HitTest"] = iodev_geom2_tests_HitTest;
iodev_geom2_tests_HitTest.__name__ = ["iodev","geom2","tests","HitTest"];
var iodev_geom2_tests_SpaceTest = function() { };
$hxClasses["iodev.geom2.tests.SpaceTest"] = iodev_geom2_tests_SpaceTest;
iodev_geom2_tests_SpaceTest.__name__ = ["iodev","geom2","tests","SpaceTest"];
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	this.message = String(val);
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
$hxClasses["js._Boot.HaxeError"] = js__$Boot_HaxeError;
js__$Boot_HaxeError.__name__ = ["js","_Boot","HaxeError"];
js__$Boot_HaxeError.wrap = function(val) {
	if((val instanceof Error)) {
		return val;
	} else {
		return new js__$Boot_HaxeError(val);
	}
};
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
	__class__: js__$Boot_HaxeError
});
var js_Boot = function() { };
$hxClasses["js.Boot"] = js_Boot;
js_Boot.__name__ = ["js","Boot"];
js_Boot.__unhtml = function(s) {
	return s.split("&").join("&amp;").split("<").join("&lt;").split(">").join("&gt;");
};
js_Boot.__trace = function(v,i) {
	var msg = i != null ? i.fileName + ":" + i.lineNumber + ": " : "";
	msg += js_Boot.__string_rec(v,"");
	if(i != null && i.customParams != null) {
		var _g = 0;
		var _g1 = i.customParams;
		while(_g < _g1.length) {
			var v1 = _g1[_g];
			++_g;
			msg += "," + js_Boot.__string_rec(v1,"");
		}
	}
	var d;
	var tmp;
	if(typeof(document) != "undefined") {
		d = document.getElementById("haxe:trace");
		tmp = d != null;
	} else {
		tmp = false;
	}
	if(tmp) {
		d.innerHTML += js_Boot.__unhtml(msg) + "<br/>";
	} else if(typeof console != "undefined" && console.log != null) {
		console.log(msg);
	}
};
js_Boot.getClass = function(o) {
	if((o instanceof Array) && o.__enum__ == null) {
		return Array;
	} else {
		var cl = o.__class__;
		if(cl != null) {
			return cl;
		}
		var name = js_Boot.__nativeClassName(o);
		if(name != null) {
			return js_Boot.__resolveNativeClass(name);
		}
		return null;
	}
};
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o instanceof Array) {
			if(o.__enum__) {
				if(o.length == 2) {
					return o[0];
				}
				var str = o[0] + "(";
				s += "\t";
				var _g1 = 2;
				var _g = o.length;
				while(_g1 < _g) {
					var i = _g1++;
					if(i != 2) {
						str += "," + js_Boot.__string_rec(o[i],s);
					} else {
						str += js_Boot.__string_rec(o[i],s);
					}
				}
				return str + ")";
			}
			var l = o.length;
			var i1;
			var str1 = "[";
			s += "\t";
			var _g11 = 0;
			var _g2 = l;
			while(_g11 < _g2) {
				var i2 = _g11++;
				str1 += (i2 > 0 ? "," : "") + js_Boot.__string_rec(o[i2],s);
			}
			str1 += "]";
			return str1;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e ) {
			haxe_CallStack.lastException = e;
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var k = null;
		var str2 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		for( var k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str2.length != 2) {
			str2 += ", \n";
		}
		str2 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str2 += "\n" + s + "}";
		return str2;
	case "string":
		return o;
	default:
		return String(o);
	}
};
js_Boot.__interfLoop = function(cc,cl) {
	if(cc == null) {
		return false;
	}
	if(cc == cl) {
		return true;
	}
	var intf = cc.__interfaces__;
	if(intf != null) {
		var _g1 = 0;
		var _g = intf.length;
		while(_g1 < _g) {
			var i = _g1++;
			var i1 = intf[i];
			if(i1 == cl || js_Boot.__interfLoop(i1,cl)) {
				return true;
			}
		}
	}
	return js_Boot.__interfLoop(cc.__super__,cl);
};
js_Boot.__instanceof = function(o,cl) {
	if(cl == null) {
		return false;
	}
	switch(cl) {
	case Array:
		if((o instanceof Array)) {
			return o.__enum__ == null;
		} else {
			return false;
		}
		break;
	case Bool:
		return typeof(o) == "boolean";
	case Dynamic:
		return true;
	case Float:
		return typeof(o) == "number";
	case Int:
		if(typeof(o) == "number") {
			return (o|0) === o;
		} else {
			return false;
		}
		break;
	case String:
		return typeof(o) == "string";
	default:
		if(o != null) {
			if(typeof(cl) == "function") {
				if(o instanceof cl) {
					return true;
				}
				if(js_Boot.__interfLoop(js_Boot.getClass(o),cl)) {
					return true;
				}
			} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
				if(o instanceof cl) {
					return true;
				}
			}
		} else {
			return false;
		}
		if(cl == Class ? o.__name__ != null : false) {
			return true;
		}
		if(cl == Enum ? o.__ename__ != null : false) {
			return true;
		}
		return o.__enum__ == cl;
	}
};
js_Boot.__cast = function(o,t) {
	if(js_Boot.__instanceof(o,t)) {
		return o;
	} else {
		throw new js__$Boot_HaxeError("Cannot cast " + Std.string(o) + " to " + Std.string(t));
	}
};
js_Boot.__nativeClassName = function(o) {
	var name = js_Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
		return null;
	}
	return name;
};
js_Boot.__isNativeObj = function(o) {
	return js_Boot.__nativeClassName(o) != null;
};
js_Boot.__resolveNativeClass = function(name) {
	return $global[name];
};
var js_Browser = function() { };
$hxClasses["js.Browser"] = js_Browser;
js_Browser.__name__ = ["js","Browser"];
js_Browser.createXMLHttpRequest = function() {
	if(typeof XMLHttpRequest != "undefined") {
		return new XMLHttpRequest();
	}
	if(typeof ActiveXObject != "undefined") {
		return new ActiveXObject("Microsoft.XMLHTTP");
	}
	throw new js__$Boot_HaxeError("Unable to create XMLHttpRequest object.");
};
var js_Lib = function() { };
$hxClasses["js.Lib"] = js_Lib;
js_Lib.__name__ = ["js","Lib"];
js_Lib.alert = function(v) {
	alert(js_Boot.__string_rec(v,""));
};
var js_html_compat_ArrayBuffer = function(a) {
	if((a instanceof Array) && a.__enum__ == null) {
		this.a = a;
		this.byteLength = a.length;
	} else {
		var len = a;
		this.a = [];
		var _g1 = 0;
		var _g = len;
		while(_g1 < _g) {
			var i = _g1++;
			this.a[i] = 0;
		}
		this.byteLength = len;
	}
};
$hxClasses["js.html.compat.ArrayBuffer"] = js_html_compat_ArrayBuffer;
js_html_compat_ArrayBuffer.__name__ = ["js","html","compat","ArrayBuffer"];
js_html_compat_ArrayBuffer.sliceImpl = function(begin,end) {
	var u = new Uint8Array(this,begin,end == null ? null : end - begin);
	var result = new ArrayBuffer(u.byteLength);
	var resultArray = new Uint8Array(result);
	resultArray.set(u);
	return result;
};
js_html_compat_ArrayBuffer.prototype = {
	slice: function(begin,end) {
		return new js_html_compat_ArrayBuffer(this.a.slice(begin,end));
	}
	,__class__: js_html_compat_ArrayBuffer
};
var js_html_compat_Uint8Array = function() { };
$hxClasses["js.html.compat.Uint8Array"] = js_html_compat_Uint8Array;
js_html_compat_Uint8Array.__name__ = ["js","html","compat","Uint8Array"];
js_html_compat_Uint8Array._new = function(arg1,offset,length) {
	var arr;
	if(typeof(arg1) == "number") {
		arr = [];
		var _g1 = 0;
		var _g = arg1;
		while(_g1 < _g) {
			var i = _g1++;
			arr[i] = 0;
		}
		arr.byteLength = arr.length;
		arr.byteOffset = 0;
		arr.buffer = new js_html_compat_ArrayBuffer(arr);
	} else if(js_Boot.__instanceof(arg1,js_html_compat_ArrayBuffer)) {
		var buffer = arg1;
		if(offset == null) {
			offset = 0;
		}
		if(length == null) {
			length = buffer.byteLength - offset;
		}
		if(offset == 0) {
			arr = buffer.a;
		} else {
			arr = buffer.a.slice(offset,offset + length);
		}
		arr.byteLength = arr.length;
		arr.byteOffset = offset;
		arr.buffer = buffer;
	} else if((arg1 instanceof Array) && arg1.__enum__ == null) {
		arr = arg1.slice();
		arr.byteLength = arr.length;
		arr.byteOffset = 0;
		arr.buffer = new js_html_compat_ArrayBuffer(arr);
	} else {
		throw new js__$Boot_HaxeError("TODO " + Std.string(arg1));
	}
	arr.subarray = js_html_compat_Uint8Array._subarray;
	arr.set = js_html_compat_Uint8Array._set;
	return arr;
};
js_html_compat_Uint8Array._set = function(arg,offset) {
	if(js_Boot.__instanceof(arg.buffer,js_html_compat_ArrayBuffer)) {
		var a = arg;
		if(arg.byteLength + offset > this.byteLength) {
			throw new js__$Boot_HaxeError("set() outside of range");
		}
		var _g1 = 0;
		var _g = arg.byteLength;
		while(_g1 < _g) {
			var i = _g1++;
			this[i + offset] = a[i];
		}
	} else if((arg instanceof Array) && arg.__enum__ == null) {
		var a1 = arg;
		if(a1.length + offset > this.byteLength) {
			throw new js__$Boot_HaxeError("set() outside of range");
		}
		var _g11 = 0;
		var _g2 = a1.length;
		while(_g11 < _g2) {
			var i1 = _g11++;
			this[i1 + offset] = a1[i1];
		}
	} else {
		throw new js__$Boot_HaxeError("TODO");
	}
};
js_html_compat_Uint8Array._subarray = function(start,end) {
	var a = js_html_compat_Uint8Array._new(this.slice(start,end));
	a.byteOffset = start;
	return a;
};
var massive_haxe_Exception = function(message,info) {
	this.message = message;
	this.info = info;
	this.type = massive_haxe_util_ReflectUtil.here({ fileName : "Exception.hx", lineNumber : 70, className : "massive.haxe.Exception", methodName : "new"}).className;
};
$hxClasses["massive.haxe.Exception"] = massive_haxe_Exception;
massive_haxe_Exception.__name__ = ["massive","haxe","Exception"];
massive_haxe_Exception.prototype = {
	toString: function() {
		var str = this.type + ": " + this.message;
		if(this.info != null) {
			str += " at " + this.info.className + "#" + this.info.methodName + " (" + this.info.lineNumber + ")";
		}
		return str;
	}
	,__class__: massive_haxe_Exception
};
var massive_haxe_util_ReflectUtil = function() { };
$hxClasses["massive.haxe.util.ReflectUtil"] = massive_haxe_util_ReflectUtil;
massive_haxe_util_ReflectUtil.__name__ = ["massive","haxe","util","ReflectUtil"];
massive_haxe_util_ReflectUtil.here = function(info) {
	return info;
};
var massive_munit_Assert = function() { };
$hxClasses["massive.munit.Assert"] = massive_munit_Assert;
massive_munit_Assert.__name__ = ["massive","munit","Assert"];
massive_munit_Assert.isTrue = function(value,info) {
	massive_munit_Assert.assertionCount++;
	if(value != true) {
		massive_munit_Assert.fail("Expected TRUE but was [" + (value == null ? "null" : "" + value) + "]",info);
	}
};
massive_munit_Assert.isFalse = function(value,info) {
	massive_munit_Assert.assertionCount++;
	if(value != false) {
		massive_munit_Assert.fail("Expected FALSE but was [" + (value == null ? "null" : "" + value) + "]",info);
	}
};
massive_munit_Assert.isNull = function(value,info) {
	massive_munit_Assert.assertionCount++;
	if(value != null) {
		massive_munit_Assert.fail("Value [" + Std.string(value) + "] was not NULL",info);
	}
};
massive_munit_Assert.isNotNull = function(value,info) {
	massive_munit_Assert.assertionCount++;
	if(value == null) {
		massive_munit_Assert.fail("Value [" + Std.string(value) + "] was NULL",info);
	}
};
massive_munit_Assert.isNaN = function(value,info) {
	massive_munit_Assert.assertionCount++;
	if(!isNaN(value)) {
		massive_munit_Assert.fail("Value [" + value + "]  was not NaN",info);
	}
};
massive_munit_Assert.isNotNaN = function(value,info) {
	massive_munit_Assert.assertionCount++;
	if(isNaN(value)) {
		massive_munit_Assert.fail("Value [" + value + "] was NaN",info);
	}
};
massive_munit_Assert.isType = function(value,type,info) {
	massive_munit_Assert.assertionCount++;
	if(!js_Boot.__instanceof(value,type)) {
		massive_munit_Assert.fail("Value [" + Std.string(value) + "] was not of type: " + Type.getClassName(type),info);
	}
};
massive_munit_Assert.isNotType = function(value,type,info) {
	massive_munit_Assert.assertionCount++;
	if(js_Boot.__instanceof(value,type)) {
		massive_munit_Assert.fail("Value [" + Std.string(value) + "] was of type: " + Type.getClassName(type),info);
	}
};
massive_munit_Assert.areEqual = function(expected,actual,info) {
	massive_munit_Assert.assertionCount++;
	var equal;
	var _g = Type["typeof"](expected);
	if(_g[1] == 7) {
		equal = Type.enumEq(expected,actual);
	} else {
		equal = expected == actual;
	}
	if(!equal) {
		massive_munit_Assert.fail("Value [" + Std.string(actual) + "] was not equal to expected value [" + Std.string(expected) + "]",info);
	}
};
massive_munit_Assert.areNotEqual = function(expected,actual,info) {
	massive_munit_Assert.assertionCount++;
	var equal;
	var _g = Type["typeof"](expected);
	if(_g[1] == 7) {
		equal = Type.enumEq(expected,actual);
	} else {
		equal = expected == actual;
	}
	if(equal) {
		massive_munit_Assert.fail("Value [" + Std.string(actual) + "] was equal to value [" + Std.string(expected) + "]",info);
	}
};
massive_munit_Assert.areSame = function(expected,actual,info) {
	massive_munit_Assert.assertionCount++;
	if(expected != actual) {
		massive_munit_Assert.fail("Value [" + Std.string(actual) + "] was not the same as expected value [" + Std.string(expected) + "]",info);
	}
};
massive_munit_Assert.areNotSame = function(expected,actual,info) {
	massive_munit_Assert.assertionCount++;
	if(expected == actual) {
		massive_munit_Assert.fail("Value [" + Std.string(actual) + "] was the same as expected value [" + Std.string(expected) + "]",info);
	}
};
massive_munit_Assert.fail = function(msg,info) {
	throw new js__$Boot_HaxeError(new massive_munit_AssertionException(msg,info));
};
var massive_munit_MUnitException = function(message,info) {
	massive_haxe_Exception.call(this,message,info);
	this.type = massive_haxe_util_ReflectUtil.here({ fileName : "MUnitException.hx", lineNumber : 50, className : "massive.munit.MUnitException", methodName : "new"}).className;
};
$hxClasses["massive.munit.MUnitException"] = massive_munit_MUnitException;
massive_munit_MUnitException.__name__ = ["massive","munit","MUnitException"];
massive_munit_MUnitException.__super__ = massive_haxe_Exception;
massive_munit_MUnitException.prototype = $extend(massive_haxe_Exception.prototype,{
	__class__: massive_munit_MUnitException
});
var massive_munit_AssertionException = function(msg,info) {
	massive_munit_MUnitException.call(this,msg,info);
	this.type = massive_haxe_util_ReflectUtil.here({ fileName : "AssertionException.hx", lineNumber : 49, className : "massive.munit.AssertionException", methodName : "new"}).className;
};
$hxClasses["massive.munit.AssertionException"] = massive_munit_AssertionException;
massive_munit_AssertionException.__name__ = ["massive","munit","AssertionException"];
massive_munit_AssertionException.__super__ = massive_munit_MUnitException;
massive_munit_AssertionException.prototype = $extend(massive_munit_MUnitException.prototype,{
	__class__: massive_munit_AssertionException
});
var massive_munit_ITestResultClient = function() { };
$hxClasses["massive.munit.ITestResultClient"] = massive_munit_ITestResultClient;
massive_munit_ITestResultClient.__name__ = ["massive","munit","ITestResultClient"];
massive_munit_ITestResultClient.prototype = {
	__class__: massive_munit_ITestResultClient
};
var massive_munit_IAdvancedTestResultClient = function() { };
$hxClasses["massive.munit.IAdvancedTestResultClient"] = massive_munit_IAdvancedTestResultClient;
massive_munit_IAdvancedTestResultClient.__name__ = ["massive","munit","IAdvancedTestResultClient"];
massive_munit_IAdvancedTestResultClient.__interfaces__ = [massive_munit_ITestResultClient];
massive_munit_IAdvancedTestResultClient.prototype = {
	__class__: massive_munit_IAdvancedTestResultClient
};
var massive_munit_ICoverageTestResultClient = function() { };
$hxClasses["massive.munit.ICoverageTestResultClient"] = massive_munit_ICoverageTestResultClient;
massive_munit_ICoverageTestResultClient.__name__ = ["massive","munit","ICoverageTestResultClient"];
massive_munit_ICoverageTestResultClient.__interfaces__ = [massive_munit_IAdvancedTestResultClient];
massive_munit_ICoverageTestResultClient.prototype = {
	__class__: massive_munit_ICoverageTestResultClient
};
var massive_munit_TestClassHelper = function(type,isDebug) {
	if(isDebug == null) {
		isDebug = false;
	}
	this.type = type;
	this.isDebug = isDebug;
	this.tests = [];
	this.index = 0;
	this.className = Type.getClassName(type);
	this.beforeClass = $bind(this,this.nullFunc);
	this.afterClass = $bind(this,this.nullFunc);
	this.before = $bind(this,this.nullFunc);
	this.after = $bind(this,this.nullFunc);
	this.parse(type);
};
$hxClasses["massive.munit.TestClassHelper"] = massive_munit_TestClassHelper;
massive_munit_TestClassHelper.__name__ = ["massive","munit","TestClassHelper"];
massive_munit_TestClassHelper.prototype = {
	hasNext: function() {
		return this.index < this.tests.length;
	}
	,next: function() {
		if(this.hasNext()) {
			return this.tests[this.index++];
		} else {
			return null;
		}
	}
	,current: function() {
		if(this.index <= 0) {
			return this.tests[0];
		} else {
			return this.tests[this.index - 1];
		}
	}
	,parse: function(type) {
		this.test = Type.createEmptyInstance(type);
		var inherintanceChain = this.getInheritanceChain(type);
		var fieldMeta = this.collateFieldMeta(inherintanceChain);
		this.scanForTests(fieldMeta);
		this.tests.sort($bind(this,this.sortTestsByName));
	}
	,getInheritanceChain: function(clazz) {
		var inherintanceChain = [clazz];
		while(true) {
			clazz = Type.getSuperClass(clazz);
			if(!(clazz != null)) {
				break;
			}
			inherintanceChain.push(clazz);
		}
		return inherintanceChain;
	}
	,collateFieldMeta: function(inherintanceChain) {
		var meta = { };
		while(inherintanceChain.length > 0) {
			var clazz = inherintanceChain.pop();
			var newMeta = haxe_rtti_Meta.getFields(clazz);
			var markedFieldNames = Reflect.fields(newMeta);
			var _g = 0;
			while(_g < markedFieldNames.length) {
				var fieldName = markedFieldNames[_g];
				++_g;
				var recordedFieldTags = Reflect.field(meta,fieldName);
				var newFieldTags = Reflect.field(newMeta,fieldName);
				var newTagNames = Reflect.fields(newFieldTags);
				if(recordedFieldTags == null) {
					var tagsCopy = { };
					var _g1 = 0;
					while(_g1 < newTagNames.length) {
						var tagName = newTagNames[_g1];
						++_g1;
						tagsCopy[tagName] = Reflect.field(newFieldTags,tagName);
					}
					meta[fieldName] = tagsCopy;
				} else {
					var ignored = false;
					var _g11 = 0;
					while(_g11 < newTagNames.length) {
						var tagName1 = newTagNames[_g11];
						++_g11;
						if(tagName1 == "Ignore") {
							ignored = true;
						}
						if(!ignored && (tagName1 == "Test" || tagName1 == "AsyncTest") && Object.prototype.hasOwnProperty.call(recordedFieldTags,"Ignore")) {
							Reflect.deleteField(recordedFieldTags,"Ignore");
						}
						var tagValue = Reflect.field(newFieldTags,tagName1);
						recordedFieldTags[tagName1] = tagValue;
					}
				}
			}
		}
		return meta;
	}
	,scanForTests: function(fieldMeta) {
		var fieldNames = Reflect.fields(fieldMeta);
		var _g = 0;
		while(_g < fieldNames.length) {
			var fieldName = fieldNames[_g];
			++_g;
			var f = Reflect.field(this.test,fieldName);
			if(Reflect.isFunction(f)) {
				var funcMeta = Reflect.field(fieldMeta,fieldName);
				this.searchForMatchingTags(fieldName,f,funcMeta);
			}
		}
	}
	,searchForMatchingTags: function(fieldName,func,funcMeta) {
		var _g = 0;
		var _g1 = massive_munit_TestClassHelper.META_TAGS;
		while(_g < _g1.length) {
			var tag = _g1[_g];
			++_g;
			if(Object.prototype.hasOwnProperty.call(funcMeta,tag)) {
				var args = Reflect.field(funcMeta,tag);
				var description = args != null ? args[0] : "";
				var isAsync = args != null && description == "Async";
				var isIgnored = Object.prototype.hasOwnProperty.call(funcMeta,"Ignore");
				if(isAsync) {
					description = "";
				} else if(isIgnored) {
					args = Reflect.field(funcMeta,"Ignore");
					if(args != null) {
						description = args[0];
					} else {
						description = "";
					}
				}
				switch(tag) {
				case "After":
					this.after = func;
					break;
				case "AfterClass":
					this.afterClass = func;
					break;
				case "AsyncTest":
					if(!this.isDebug) {
						this.addTest(fieldName,func,this.test,true,isIgnored,description);
					}
					break;
				case "Before":
					this.before = func;
					break;
				case "BeforeClass":
					this.beforeClass = func;
					break;
				case "Test":
					if(!this.isDebug) {
						this.addTest(fieldName,func,this.test,isAsync,isIgnored,description);
					}
					break;
				case "TestDebug":
					if(this.isDebug) {
						this.addTest(fieldName,func,this.test,isAsync,isIgnored,description);
					}
					break;
				}
			}
		}
	}
	,addTest: function(field,testFunction,testInstance,isAsync,isIgnored,description) {
		var result = new massive_munit_TestResult();
		result.async = isAsync;
		result.ignore = isIgnored;
		result.className = this.className;
		result.description = description;
		result.name = field;
		var data = { test : testFunction, scope : testInstance, result : result};
		this.tests.push(data);
	}
	,sortTestsByName: function(x,y) {
		if(x.result.name == y.result.name) {
			return 0;
		}
		if(x.result.name > y.result.name) {
			return 1;
		} else {
			return -1;
		}
	}
	,nullFunc: function() {
	}
	,__class__: massive_munit_TestClassHelper
};
var massive_munit_TestResult = function() {
	this.passed = false;
	this.executionTime = 0.0;
	this.name = "";
	this.className = "";
	this.description = "";
	this.async = false;
	this.ignore = false;
	this.error = null;
	this.failure = null;
};
$hxClasses["massive.munit.TestResult"] = massive_munit_TestResult;
massive_munit_TestResult.__name__ = ["massive","munit","TestResult"];
massive_munit_TestResult.prototype = {
	get_location: function() {
		if(this.name == "" && this.className == "") {
			return "";
		} else {
			return this.className + "#" + this.name;
		}
	}
	,get_type: function() {
		if(this.error != null) {
			return massive_munit_TestResultType.ERROR;
		}
		if(this.failure != null) {
			return massive_munit_TestResultType.FAIL;
		}
		if(this.ignore == true) {
			return massive_munit_TestResultType.IGNORE;
		}
		if(this.passed == true) {
			return massive_munit_TestResultType.PASS;
		}
		return massive_munit_TestResultType.UNKNOWN;
	}
	,__class__: massive_munit_TestResult
};
var massive_munit_TestResultType = $hxClasses["massive.munit.TestResultType"] = { __ename__ : ["massive","munit","TestResultType"], __constructs__ : ["UNKNOWN","PASS","FAIL","ERROR","IGNORE"] };
massive_munit_TestResultType.UNKNOWN = ["UNKNOWN",0];
massive_munit_TestResultType.UNKNOWN.toString = $estr;
massive_munit_TestResultType.UNKNOWN.__enum__ = massive_munit_TestResultType;
massive_munit_TestResultType.PASS = ["PASS",1];
massive_munit_TestResultType.PASS.toString = $estr;
massive_munit_TestResultType.PASS.__enum__ = massive_munit_TestResultType;
massive_munit_TestResultType.FAIL = ["FAIL",2];
massive_munit_TestResultType.FAIL.toString = $estr;
massive_munit_TestResultType.FAIL.__enum__ = massive_munit_TestResultType;
massive_munit_TestResultType.ERROR = ["ERROR",3];
massive_munit_TestResultType.ERROR.toString = $estr;
massive_munit_TestResultType.ERROR.__enum__ = massive_munit_TestResultType;
massive_munit_TestResultType.IGNORE = ["IGNORE",4];
massive_munit_TestResultType.IGNORE.toString = $estr;
massive_munit_TestResultType.IGNORE.__enum__ = massive_munit_TestResultType;
var massive_munit_async_IAsyncDelegateObserver = function() { };
$hxClasses["massive.munit.async.IAsyncDelegateObserver"] = massive_munit_async_IAsyncDelegateObserver;
massive_munit_async_IAsyncDelegateObserver.__name__ = ["massive","munit","async","IAsyncDelegateObserver"];
massive_munit_async_IAsyncDelegateObserver.prototype = {
	__class__: massive_munit_async_IAsyncDelegateObserver
};
var massive_munit_TestRunner = function(resultClient) {
	this.clients = [];
	this.addResultClient(resultClient);
	this.set_asyncFactory(this.createAsyncFactory());
	this.running = false;
	this.isDebug = false;
};
$hxClasses["massive.munit.TestRunner"] = massive_munit_TestRunner;
massive_munit_TestRunner.__name__ = ["massive","munit","TestRunner"];
massive_munit_TestRunner.__interfaces__ = [massive_munit_async_IAsyncDelegateObserver];
massive_munit_TestRunner.prototype = {
	get_clientCount: function() {
		return this.clients.length;
	}
	,set_asyncFactory: function(value) {
		if(value == this.asyncFactory) {
			return value;
		}
		if(this.running) {
			throw new js__$Boot_HaxeError(new massive_munit_MUnitException("Can't change AsyncFactory while tests are running",{ fileName : "TestRunner.hx", lineNumber : 127, className : "massive.munit.TestRunner", methodName : "set_asyncFactory"}));
		}
		value.observer = this;
		return this.asyncFactory = value;
	}
	,addResultClient: function(resultClient) {
		var _g = 0;
		var _g1 = this.clients;
		while(_g < _g1.length) {
			var client = _g1[_g];
			++_g;
			if(client == resultClient) {
				return;
			}
		}
		resultClient.set_completionHandler($bind(this,this.clientCompletionHandler));
		this.clients.push(resultClient);
	}
	,debug: function(testSuiteClasses) {
		this.isDebug = true;
		this.run(testSuiteClasses);
	}
	,run: function(testSuiteClasses) {
		if(this.running) {
			return;
		}
		this.running = true;
		this.asyncPending = false;
		this.asyncDelegate = null;
		this.testCount = 0;
		this.failCount = 0;
		this.errorCount = 0;
		this.passCount = 0;
		this.ignoreCount = 0;
		this.suiteIndex = 0;
		this.clientCompleteCount = 0;
		massive_munit_Assert.assertionCount = 0;
		this.emptyParams = [];
		this.testSuites = [];
		this.startTime = massive_munit_util_Timer.stamp();
		var _g = 0;
		while(_g < testSuiteClasses.length) {
			var suiteType = testSuiteClasses[_g];
			++_g;
			this.testSuites.push(Type.createInstance(suiteType,[]));
		}
		this.execute();
	}
	,execute: function() {
		var _g1 = this.suiteIndex;
		var _g = this.testSuites.length;
		while(_g1 < _g) {
			var i = _g1++;
			var suite = this.testSuites[i];
			var testClass = suite;
			while(testClass.hasNext()) {
				var testClass1 = testClass.next();
				if(this.activeHelper == null || this.activeHelper.type != testClass1) {
					this.activeHelper = new massive_munit_TestClassHelper(testClass1,this.isDebug);
					this.activeHelper.beforeClass.apply(this.activeHelper.test,this.emptyParams);
				}
				this.executeTestCases();
				if(!this.asyncPending) {
					this.activeHelper.afterClass.apply(this.activeHelper.test,this.emptyParams);
				} else {
					suite.repeat();
					this.suiteIndex = i;
					return;
				}
			}
			this.testSuites[i] = null;
		}
		if(!this.asyncPending) {
			var time = massive_munit_util_Timer.stamp() - this.startTime;
			var _g2 = 0;
			var _g11 = this.clients;
			while(_g2 < _g11.length) {
				var client = _g11[_g2];
				++_g2;
				if(js_Boot.__instanceof(client,massive_munit_IAdvancedTestResultClient)) {
					var cl = client;
					cl.setCurrentTestClass(null);
				}
				client.reportFinalStatistics(this.testCount,this.passCount,this.failCount,this.errorCount,this.ignoreCount,time);
			}
		}
	}
	,executeTestCases: function() {
		var _g = 0;
		var _g1 = this.clients;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			if(js_Boot.__instanceof(c,massive_munit_IAdvancedTestResultClient)) {
				if(this.activeHelper.hasNext()) {
					var cl = c;
					cl.setCurrentTestClass(this.activeHelper.className);
				}
			}
		}
		var testCaseData = this.activeHelper;
		while(testCaseData.hasNext()) {
			var testCaseData1 = testCaseData.next();
			if(testCaseData1.result.ignore) {
				this.ignoreCount++;
				var _g2 = 0;
				var _g11 = this.clients;
				while(_g2 < _g11.length) {
					var c1 = _g11[_g2];
					++_g2;
					c1.addIgnore(testCaseData1.result);
				}
			} else {
				this.testCount++;
				this.activeHelper.before.apply(this.activeHelper.test,this.emptyParams);
				this.testStartTime = massive_munit_util_Timer.stamp();
				this.executeTestCase(testCaseData1,testCaseData1.result.async);
				if(!this.asyncPending) {
					this.activeHelper.after.apply(this.activeHelper.test,this.emptyParams);
				} else {
					break;
				}
			}
		}
	}
	,executeTestCase: function(testCaseData,async) {
		var result = testCaseData.result;
		try {
			var assertionCount = massive_munit_Assert.assertionCount;
			if(async) {
				testCaseData.test.apply(testCaseData.scope,[this.asyncFactory]);
				if(this.asyncDelegate == null) {
					throw new js__$Boot_HaxeError(new massive_munit_async_MissingAsyncDelegateException("No AsyncDelegate was created in async test at " + result.get_location(),null));
				}
				this.asyncPending = true;
			} else {
				testCaseData.test.apply(testCaseData.scope,this.emptyParams);
				result.passed = true;
				result.executionTime = massive_munit_util_Timer.stamp() - this.testStartTime;
				this.passCount++;
				var _g = 0;
				var _g1 = this.clients;
				while(_g < _g1.length) {
					var c = _g1[_g];
					++_g;
					c.addPass(result);
				}
			}
		} catch( e ) {
			haxe_CallStack.lastException = e;
			if (e instanceof js__$Boot_HaxeError) e = e.val;
			if(async && this.asyncDelegate != null) {
				this.asyncDelegate.cancelTest();
				this.asyncDelegate = null;
			}
			if(js_Boot.__instanceof(e,org_hamcrest_AssertionException)) {
				e = new massive_munit_AssertionException(e.message,e.info);
			}
			if(js_Boot.__instanceof(e,massive_munit_AssertionException)) {
				result.executionTime = massive_munit_util_Timer.stamp() - this.testStartTime;
				result.failure = e;
				this.failCount++;
				var _g2 = 0;
				var _g11 = this.clients;
				while(_g2 < _g11.length) {
					var c1 = _g11[_g2];
					++_g2;
					c1.addFail(result);
				}
			} else {
				result.executionTime = massive_munit_util_Timer.stamp() - this.testStartTime;
				if(!js_Boot.__instanceof(e,massive_munit_MUnitException)) {
					e = new massive_munit_UnhandledException(e,result.get_location());
				}
				result.error = e;
				this.errorCount++;
				var _g3 = 0;
				var _g12 = this.clients;
				while(_g3 < _g12.length) {
					var c2 = _g12[_g3];
					++_g3;
					c2.addError(result);
				}
			}
		}
	}
	,clientCompletionHandler: function(resultClient) {
		if(++this.clientCompleteCount == this.clients.length) {
			if(this.completionHandler != null) {
				var successful = this.passCount == this.testCount;
				var handler = this.completionHandler;
				massive_munit_util_Timer.delay(function() {
					handler(successful);
				},10);
			}
			this.running = false;
		}
	}
	,asyncResponseHandler: function(delegate) {
		var testCaseData = this.activeHelper.current();
		testCaseData.test = $bind(delegate,delegate.runTest);
		testCaseData.scope = delegate;
		this.asyncPending = false;
		this.asyncDelegate = null;
		this.executeTestCase(testCaseData,false);
		this.activeHelper.after.apply(this.activeHelper.test,this.emptyParams);
		this.execute();
	}
	,asyncTimeoutHandler: function(delegate) {
		var testCaseData = this.activeHelper.current();
		var result = testCaseData.result;
		result.executionTime = massive_munit_util_Timer.stamp() - this.testStartTime;
		result.error = new massive_munit_async_AsyncTimeoutException("",delegate.info);
		this.asyncPending = false;
		this.asyncDelegate = null;
		this.errorCount++;
		var _g = 0;
		var _g1 = this.clients;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			c.addError(result);
		}
		this.activeHelper.after.apply(this.activeHelper.test,this.emptyParams);
		this.execute();
	}
	,asyncDelegateCreatedHandler: function(delegate) {
		this.asyncDelegate = delegate;
	}
	,createAsyncFactory: function() {
		return new massive_munit_async_AsyncFactory(this);
	}
	,__class__: massive_munit_TestRunner
};
var massive_munit_UnhandledException = function(source,testLocation) {
	massive_munit_MUnitException.call(this,Std.string(source.toString()) + this.formatLocation(source,testLocation),null);
	this.type = massive_haxe_util_ReflectUtil.here({ fileName : "UnhandledException.hx", lineNumber : 53, className : "massive.munit.UnhandledException", methodName : "new"}).className;
};
$hxClasses["massive.munit.UnhandledException"] = massive_munit_UnhandledException;
massive_munit_UnhandledException.__name__ = ["massive","munit","UnhandledException"];
massive_munit_UnhandledException.__super__ = massive_munit_MUnitException;
massive_munit_UnhandledException.prototype = $extend(massive_munit_MUnitException.prototype,{
	formatLocation: function(source,testLocation) {
		var stackTrace = " at " + testLocation;
		var stack = this.getStackTrace(source);
		if(stack != "") {
			stackTrace += " " + HxOverrides.substr(stack,1,null);
		}
		return stackTrace;
	}
	,getStackTrace: function(source) {
		var s = "";
		if(s == "") {
			var stack = haxe_CallStack.exceptionStack();
			while(stack.length > 0) {
				var _g = stack.shift();
				if(_g != null) {
					switch(_g[1]) {
					case 2:
						var line = _g[4];
						var file = _g[3];
						s += "\tat " + file + " (" + line + ")\n";
						break;
					case 3:
						var method = _g[3];
						var classname = _g[2];
						s += "\tat " + classname + "#" + method + "\n";
						break;
					default:
					}
				}
			}
		}
		return s;
	}
	,__class__: massive_munit_UnhandledException
});
var massive_munit_async_AsyncDelegate = function(testCase,handler,timeout,info) {
	var self = this;
	this.testCase = testCase;
	this.handler = handler;
	this.delegateHandler = Reflect.makeVarArgs($bind(this,this.responseHandler));
	this.info = info;
	this.params = [];
	this.timedOut = false;
	this.canceled = false;
	if(timeout == null || timeout <= 0) {
		timeout = 400;
	}
	this.timeoutDelay = timeout;
	this.timer = massive_munit_util_Timer.delay($bind(this,this.timeoutHandler),this.timeoutDelay);
};
$hxClasses["massive.munit.async.AsyncDelegate"] = massive_munit_async_AsyncDelegate;
massive_munit_async_AsyncDelegate.__name__ = ["massive","munit","async","AsyncDelegate"];
massive_munit_async_AsyncDelegate.prototype = {
	runTest: function() {
		this.handler.apply(this.testCase,this.params);
	}
	,cancelTest: function() {
		this.canceled = true;
		this.timer.stop();
		if(this.deferredTimer != null) {
			this.deferredTimer.stop();
		}
	}
	,responseHandler: function(params) {
		if(this.timedOut || this.canceled) {
			return null;
		}
		this.timer.stop();
		if(this.deferredTimer != null) {
			this.deferredTimer.stop();
		}
		if(params == null) {
			params = [];
		}
		this.params = params;
		if(this.observer != null) {
			massive_munit_util_Timer.delay($bind(this,this.delayActualResponseHandler),1);
		}
		return null;
	}
	,delayActualResponseHandler: function() {
		this.observer.asyncResponseHandler(this);
		this.observer = null;
	}
	,timeoutHandler: function() {
		this.actualTimeoutHandler();
	}
	,actualTimeoutHandler: function() {
		this.deferredTimer = null;
		this.handler = null;
		this.delegateHandler = null;
		this.timedOut = true;
		if(this.observer != null) {
			this.observer.asyncTimeoutHandler(this);
			this.observer = null;
		}
	}
	,__class__: massive_munit_async_AsyncDelegate
};
var massive_munit_async_AsyncFactory = function(observer) {
	this.observer = observer;
	this.asyncDelegateCount = 0;
};
$hxClasses["massive.munit.async.AsyncFactory"] = massive_munit_async_AsyncFactory;
massive_munit_async_AsyncFactory.__name__ = ["massive","munit","async","AsyncFactory"];
massive_munit_async_AsyncFactory.prototype = {
	createHandler: function(testCase,handler,timeout,info) {
		var delegate = new massive_munit_async_AsyncDelegate(testCase,handler,timeout,info);
		delegate.observer = this.observer;
		this.asyncDelegateCount++;
		this.observer.asyncDelegateCreatedHandler(delegate);
		return delegate.delegateHandler;
	}
	,__class__: massive_munit_async_AsyncFactory
};
var massive_munit_async_AsyncTimeoutException = function(message,info) {
	massive_munit_MUnitException.call(this,message,info);
	this.type = massive_haxe_util_ReflectUtil.here({ fileName : "AsyncTimeoutException.hx", lineNumber : 47, className : "massive.munit.async.AsyncTimeoutException", methodName : "new"}).className;
};
$hxClasses["massive.munit.async.AsyncTimeoutException"] = massive_munit_async_AsyncTimeoutException;
massive_munit_async_AsyncTimeoutException.__name__ = ["massive","munit","async","AsyncTimeoutException"];
massive_munit_async_AsyncTimeoutException.__super__ = massive_munit_MUnitException;
massive_munit_async_AsyncTimeoutException.prototype = $extend(massive_munit_MUnitException.prototype,{
	__class__: massive_munit_async_AsyncTimeoutException
});
var massive_munit_async_MissingAsyncDelegateException = function(message,info) {
	massive_munit_MUnitException.call(this,message,info);
	this.type = massive_haxe_util_ReflectUtil.here({ fileName : "MissingAsyncDelegateException.hx", lineNumber : 47, className : "massive.munit.async.MissingAsyncDelegateException", methodName : "new"}).className;
};
$hxClasses["massive.munit.async.MissingAsyncDelegateException"] = massive_munit_async_MissingAsyncDelegateException;
massive_munit_async_MissingAsyncDelegateException.__name__ = ["massive","munit","async","MissingAsyncDelegateException"];
massive_munit_async_MissingAsyncDelegateException.__super__ = massive_munit_MUnitException;
massive_munit_async_MissingAsyncDelegateException.prototype = $extend(massive_munit_MUnitException.prototype,{
	__class__: massive_munit_async_MissingAsyncDelegateException
});
var massive_munit_client_AbstractTestResultClient = function() {
	this.init();
};
$hxClasses["massive.munit.client.AbstractTestResultClient"] = massive_munit_client_AbstractTestResultClient;
massive_munit_client_AbstractTestResultClient.__name__ = ["massive","munit","client","AbstractTestResultClient"];
massive_munit_client_AbstractTestResultClient.__interfaces__ = [massive_munit_ICoverageTestResultClient,massive_munit_IAdvancedTestResultClient];
massive_munit_client_AbstractTestResultClient.prototype = {
	get_completionHandler: function() {
		return this.completionHandler;
	}
	,set_completionHandler: function(value) {
		return this.completionHandler = value;
	}
	,get_output: function() {
		return this.output;
	}
	,init: function() {
		this.currentTestClass = null;
		this.currentClassResults = [];
		massive_munit_client_AbstractTestResultClient.traces = [];
		this.passCount = 0;
		this.failCount = 0;
		this.errorCount = 0;
		this.ignoreCount = 0;
		this.currentCoverageResult = null;
		this.totalResults = [];
		this.totalCoveragePercent = 0;
		this.totalCoverageReport = null;
		this.totalCoverageResults = null;
	}
	,setCurrentTestClass: function(className) {
		if(this.currentTestClass == className) {
			return;
		}
		if(this.currentTestClass != null) {
			this.finalizeTestClass();
		}
		this.currentTestClass = className;
		if(this.currentTestClass != null) {
			this.initializeTestClass();
		}
	}
	,addPass: function(result) {
		this.passCount++;
		this.updateTestClass(result);
	}
	,addFail: function(result) {
		this.failCount++;
		this.updateTestClass(result);
	}
	,addError: function(result) {
		this.errorCount++;
		this.updateTestClass(result);
	}
	,addIgnore: function(result) {
		this.ignoreCount++;
		this.updateTestClass(result);
	}
	,setCurrentTestClassCoverage: function(result) {
		this.currentCoverageResult = result;
	}
	,reportFinalCoverage: function(percent,missingCoverageResults,summary,classBreakdown,packageBreakdown,executionFrequency) {
		if(percent == null) {
			percent = 0;
		}
		this.totalCoveragePercent = percent;
		this.totalCoverageResults = missingCoverageResults;
		this.totalCoverageReport = summary;
	}
	,reportFinalStatistics: function(testCount,passCount,failCount,errorCount,ignoreCount,time) {
		this.finalResult = passCount == testCount;
		this.printReports();
		this.printFinalStatistics(this.finalResult,testCount,passCount,failCount,errorCount,ignoreCount,time);
		this.printOverallResult(this.finalResult);
		haxe_Log.trace = this.originalTrace;
		if(this.get_completionHandler() != null) {
			(this.get_completionHandler())(this);
		}
		return this.get_output();
	}
	,initializeTestClass: function() {
		this.currentClassResults = [];
		massive_munit_client_AbstractTestResultClient.traces = [];
		this.passCount = 0;
		this.failCount = 0;
		this.errorCount = 0;
		this.ignoreCount = 0;
	}
	,updateTestClass: function(result) {
		this.currentClassResults.push(result);
		this.totalResults.push(result);
	}
	,finalizeTestClass: function() {
		this.currentClassResults.sort($bind(this,this.sortTestResults));
	}
	,printReports: function() {
	}
	,printFinalStatistics: function(result,testCount,passCount,failCount,errorCount,ignoreCount,time) {
	}
	,printOverallResult: function(result) {
	}
	,addTrace: function(value,info) {
		var traceString = info.fileName + "|" + info.lineNumber + "| " + Std.string(value);
		massive_munit_client_AbstractTestResultClient.traces.push(traceString);
	}
	,getTraces: function() {
		return massive_munit_client_AbstractTestResultClient.traces.concat([]);
	}
	,sortTestResults: function(a,b) {
		var aInt;
		var _g = a.get_type();
		switch(_g[1]) {
		case 1:
			aInt = -1;
			break;
		case 2:
			aInt = 1;
			break;
		case 3:
			aInt = 2;
			break;
		case 4:
			aInt = 0;
			break;
		default:
			aInt = -2;
		}
		var bInt;
		var _g1 = b.get_type();
		switch(_g1[1]) {
		case 1:
			bInt = -1;
			break;
		case 2:
			bInt = 1;
			break;
		case 3:
			bInt = 2;
			break;
		case 4:
			bInt = 0;
			break;
		default:
			bInt = -2;
		}
		return aInt - bInt;
	}
	,__class__: massive_munit_client_AbstractTestResultClient
};
var massive_munit_client_HTTPClient = function(client,url,queueRequest) {
	if(queueRequest == null) {
		queueRequest = true;
	}
	if(url == null) {
		url = "http://localhost:2000";
	}
	this.id = "HTTPClient";
	this.client = client;
	this.url = url;
	this.queueRequest = queueRequest;
};
$hxClasses["massive.munit.client.HTTPClient"] = massive_munit_client_HTTPClient;
massive_munit_client_HTTPClient.__name__ = ["massive","munit","client","HTTPClient"];
massive_munit_client_HTTPClient.__interfaces__ = [massive_munit_IAdvancedTestResultClient];
massive_munit_client_HTTPClient.dispatchNextRequest = function() {
	if(massive_munit_client_HTTPClient.responsePending || massive_munit_client_HTTPClient.queue.length == 0) {
		return;
	}
	massive_munit_client_HTTPClient.responsePending = true;
	var request = massive_munit_client_HTTPClient.queue.pop();
	request.send();
};
massive_munit_client_HTTPClient.prototype = {
	get_completionHandler: function() {
		return this.completionHandler;
	}
	,set_completionHandler: function(value) {
		return this.completionHandler = value;
	}
	,setCurrentTestClass: function(className) {
		if(js_Boot.__instanceof(this.client,massive_munit_IAdvancedTestResultClient)) {
			(js_Boot.__cast(this.client , massive_munit_IAdvancedTestResultClient)).setCurrentTestClass(className);
		}
	}
	,addPass: function(result) {
		this.client.addPass(result);
	}
	,addFail: function(result) {
		this.client.addFail(result);
	}
	,addError: function(result) {
		this.client.addError(result);
	}
	,addIgnore: function(result) {
		this.client.addIgnore(result);
	}
	,reportFinalStatistics: function(testCount,passCount,failCount,errorCount,ignoreCount,time) {
		var result = this.client.reportFinalStatistics(testCount,passCount,failCount,errorCount,ignoreCount,time);
		this.sendResult(result);
		return result;
	}
	,sendResult: function(result) {
		this.request = new massive_munit_client_URLRequest(this.url);
		this.request.setHeader("munit-clientId",this.client.id);
		this.request.setHeader("munit-platformId",this.platform());
		this.request.onData = $bind(this,this.onData);
		this.request.onError = $bind(this,this.onError);
		this.request.data = result;
		if(this.queueRequest) {
			massive_munit_client_HTTPClient.queue.unshift(this.request);
			massive_munit_client_HTTPClient.dispatchNextRequest();
		} else {
			this.request.send();
		}
	}
	,platform: function() {
		return "js";
	}
	,onData: function(data) {
		if(this.queueRequest) {
			massive_munit_client_HTTPClient.responsePending = false;
			massive_munit_client_HTTPClient.dispatchNextRequest();
		}
		if(this.get_completionHandler() != null) {
			(this.get_completionHandler())(this);
		}
	}
	,onError: function(msg) {
		if(this.queueRequest) {
			massive_munit_client_HTTPClient.responsePending = false;
			massive_munit_client_HTTPClient.dispatchNextRequest();
		}
		if(this.get_completionHandler() != null) {
			(this.get_completionHandler())(this);
		}
	}
	,__class__: massive_munit_client_HTTPClient
};
var massive_munit_client_URLRequest = function(url) {
	this.url = url;
	this.createClient(url);
	this.setHeader("Content-Type","text/plain");
};
$hxClasses["massive.munit.client.URLRequest"] = massive_munit_client_URLRequest;
massive_munit_client_URLRequest.__name__ = ["massive","munit","client","URLRequest"];
massive_munit_client_URLRequest.prototype = {
	createClient: function(url) {
		this.client = new haxe_Http(url);
	}
	,setHeader: function(name,value) {
		this.client.setHeader(name,value);
	}
	,send: function() {
		this.client.onData = this.onData;
		this.client.onError = this.onError;
		this.client.setPostData(this.data);
		this.client.request(true);
	}
	,__class__: massive_munit_client_URLRequest
};
var massive_munit_client_JUnitReportClient = function() {
	this.id = "junit";
	this.xml = new StringBuf();
	this.currentTestClass = "";
	this.newline = "\n";
	this.testSuiteXML = null;
	this.xml.b += Std.string("<testsuites>" + this.newline);
};
$hxClasses["massive.munit.client.JUnitReportClient"] = massive_munit_client_JUnitReportClient;
massive_munit_client_JUnitReportClient.__name__ = ["massive","munit","client","JUnitReportClient"];
massive_munit_client_JUnitReportClient.__interfaces__ = [massive_munit_IAdvancedTestResultClient];
massive_munit_client_JUnitReportClient.prototype = {
	get_completionHandler: function() {
		return this.completionHandler;
	}
	,set_completionHandler: function(value) {
		return this.completionHandler = value;
	}
	,setCurrentTestClass: function(className) {
		if(this.currentTestClass == className) {
			return;
		}
		if(this.currentTestClass != null) {
			this.endTestSuite();
		}
		this.currentTestClass = className;
		if(this.currentTestClass != null) {
			this.startTestSuite();
		}
	}
	,addPass: function(result) {
		this.suitePassCount++;
		var _this = this.testSuiteXML;
		var x = "<testcase classname=\"" + result.className + "\" name=\"" + result.name + "\" time=\"" + massive_munit_util_MathUtil.round(result.executionTime,5) + "\" />" + this.newline;
		_this.b += Std.string(x);
	}
	,addFail: function(result) {
		this.suiteFailCount++;
		var _this = this.testSuiteXML;
		var x = "<testcase classname=\"" + result.className + "\" name=\"" + result.name + "\" time=\"" + massive_munit_util_MathUtil.round(result.executionTime,5) + "\" >" + this.newline;
		_this.b += Std.string(x);
		this.testSuiteXML.b += Std.string("<failure message=\"" + result.failure.message + "\" type=\"" + result.failure.type + "\">");
		this.testSuiteXML.b += Std.string(result.failure);
		this.testSuiteXML.b += Std.string("</failure>" + this.newline);
		this.testSuiteXML.b += Std.string("</testcase>" + this.newline);
	}
	,addError: function(result) {
		this.suiteErrorCount++;
		var _this = this.testSuiteXML;
		var x = "<testcase classname=\"" + result.className + "\" name=\"" + result.name + "\" time=\"" + massive_munit_util_MathUtil.round(result.executionTime,5) + "\" >" + this.newline;
		_this.b += Std.string(x);
		this.testSuiteXML.b += Std.string("<error message=\"" + Std.string(result.error.message) + "\" type=\"" + Std.string(result.error.type) + "\">");
		this.testSuiteXML.b += Std.string(result.error);
		this.testSuiteXML.b += Std.string("</error>" + this.newline);
		this.testSuiteXML.b += Std.string("</testcase>" + this.newline);
	}
	,addIgnore: function(result) {
	}
	,reportFinalStatistics: function(testCount,passCount,failCount,errorCount,ignoreCount,time) {
		this.xml.b += "</testsuites>";
		if(this.get_completionHandler() != null) {
			(this.get_completionHandler())(this);
		}
		return this.xml.b;
	}
	,endTestSuite: function() {
		if(this.testSuiteXML == null) {
			return;
		}
		var suiteTestCount = this.suitePassCount + this.suiteFailCount + this.suiteErrorCount;
		this.suiteExecutionTime = massive_munit_util_Timer.stamp() - this.suiteExecutionTime;
		var header = "<testsuite errors=\"" + this.suiteErrorCount + "\" failures=\"" + this.suiteFailCount + "\" hostname=\"\" name=\"" + this.currentTestClass + "\" tests=\"" + suiteTestCount + "\" time=\"" + massive_munit_util_MathUtil.round(this.suiteExecutionTime,5) + "\" timestamp=\"" + Std.string(new Date()) + "\">" + this.newline;
		var footer = "</testsuite>" + this.newline;
		this.testSuiteXML.b += Std.string("<system-out></system-out>" + this.newline);
		this.testSuiteXML.b += Std.string("<system-err></system-err>" + this.newline);
		this.xml.b += header == null ? "null" : "" + header;
		this.xml.b += Std.string(this.testSuiteXML.b);
		this.xml.b += footer == null ? "null" : "" + footer;
	}
	,startTestSuite: function() {
		this.suitePassCount = 0;
		this.suiteFailCount = 0;
		this.suiteErrorCount = 0;
		this.suiteExecutionTime = massive_munit_util_Timer.stamp();
		this.testSuiteXML = new StringBuf();
	}
	,__class__: massive_munit_client_JUnitReportClient
};
var massive_munit_client_PrintClientBase = function(includeIgnoredReport) {
	if(includeIgnoredReport == null) {
		includeIgnoredReport = true;
	}
	massive_munit_client_AbstractTestResultClient.call(this);
	this.id = "simple";
	this.verbose = false;
	this.includeIgnoredReport = includeIgnoredReport;
	this.printLine("MUnit Results");
	this.printLine(this.divider);
};
$hxClasses["massive.munit.client.PrintClientBase"] = massive_munit_client_PrintClientBase;
massive_munit_client_PrintClientBase.__name__ = ["massive","munit","client","PrintClientBase"];
massive_munit_client_PrintClientBase.__super__ = massive_munit_client_AbstractTestResultClient;
massive_munit_client_PrintClientBase.prototype = $extend(massive_munit_client_AbstractTestResultClient.prototype,{
	init: function() {
		massive_munit_client_AbstractTestResultClient.prototype.init.call(this);
		this.divider = "------------------------------";
		this.divider2 = "==============================";
	}
	,initializeTestClass: function() {
		massive_munit_client_AbstractTestResultClient.prototype.initializeTestClass.call(this);
		this.printLine("Class: " + this.currentTestClass + " ");
	}
	,updateTestClass: function(result) {
		massive_munit_client_AbstractTestResultClient.prototype.updateTestClass.call(this,result);
		if(this.verbose) {
			this.printLine(" " + result.name + ": " + Std.string(result.get_type()) + " ");
		} else {
			var _g = result.get_type();
			switch(_g[1]) {
			case 0:
				break;
			case 1:
				this.print(".");
				break;
			case 2:
				this.print("!");
				break;
			case 3:
				this.print("x");
				break;
			case 4:
				this.print(",");
				break;
			}
		}
	}
	,finalizeTestClass: function() {
		massive_munit_client_AbstractTestResultClient.prototype.finalizeTestClass.call(this);
		var _g = 0;
		var _g1 = this.getTraces();
		while(_g < _g1.length) {
			var item = _g1[_g];
			++_g;
			this.printLine("TRACE: " + item,1);
		}
		var _g2 = 0;
		var _g11 = this.currentClassResults;
		while(_g2 < _g11.length) {
			var result = _g11[_g2];
			++_g2;
			var _g21 = result.get_type();
			switch(_g21[1]) {
			case 0:case 1:
				break;
			case 2:
				this.printLine("FAIL: " + Std.string(result.failure),1);
				break;
			case 3:
				this.printLine("ERROR: " + Std.string(result.error),1);
				break;
			case 4:
				var ingoredString = result.get_location();
				if(result.description != null) {
					ingoredString += " - " + result.description;
				}
				this.printLine("IGNORE: " + ingoredString,1);
				break;
			}
		}
	}
	,setCurrentTestClassCoverage: function(result) {
		massive_munit_client_AbstractTestResultClient.prototype.setCurrentTestClassCoverage.call(this,result);
		this.print(" [" + result.percent + "%]");
	}
	,reportFinalCoverage: function(percent,missingCoverageResults,summary,classBreakdown,packageBreakdown,executionFrequency) {
		if(percent == null) {
			percent = 0;
		}
		massive_munit_client_AbstractTestResultClient.prototype.reportFinalCoverage.call(this,percent,missingCoverageResults,summary,classBreakdown,packageBreakdown,executionFrequency);
		this.printLine("");
		this.printLine(this.divider);
		this.printLine("COVERAGE REPORT");
		this.printLine(this.divider);
		if(missingCoverageResults != null && missingCoverageResults.length > 0) {
			this.printLine("MISSING CODE BLOCKS:");
			var _g = 0;
			while(_g < missingCoverageResults.length) {
				var result = missingCoverageResults[_g];
				++_g;
				this.printLine(result.className + " [" + result.percent + "%]",1);
				var _g1 = 0;
				var _g2 = result.blocks;
				while(_g1 < _g2.length) {
					var item = _g2[_g1];
					++_g1;
					this.printIndentedLines(item,2);
				}
				this.printLine("");
			}
		}
		if(executionFrequency != null) {
			this.printLine("CODE EXECUTION FREQUENCY:");
			this.printIndentedLines(executionFrequency,1);
			this.printLine("");
		}
		if(classBreakdown != null) {
			this.printIndentedLines(classBreakdown,0);
		}
		if(packageBreakdown != null) {
			this.printIndentedLines(packageBreakdown,0);
		}
		if(summary != null) {
			this.printIndentedLines(summary,0);
		}
	}
	,printIndentedLines: function(value,indent) {
		if(indent == null) {
			indent = 1;
		}
		var lines = value.split("\n");
		var _g = 0;
		while(_g < lines.length) {
			var line = lines[_g];
			++_g;
			this.printLine(line,indent);
		}
	}
	,printReports: function() {
		this.printFinalIgnoredStatistics(this.ignoreCount);
	}
	,printFinalIgnoredStatistics: function(count) {
		if(!this.includeIgnoredReport || count == 0) {
			return;
		}
		var items = Lambda.filter(this.totalResults,$bind(this,this.filterIngored));
		if(items.length == 0) {
			return;
		}
		this.printLine("");
		this.printLine("Ignored (" + count + "):");
		this.printLine(this.divider);
		var _g_head = items.h;
		while(_g_head != null) {
			var val = _g_head.item;
			_g_head = _g_head.next;
			var result = val;
			var ingoredString = result.get_location();
			if(result.description != null) {
				ingoredString += " - " + result.description;
			}
			this.printLine("IGNORE: " + ingoredString,1);
		}
		this.printLine("");
	}
	,filterIngored: function(result) {
		return result.get_type() == massive_munit_TestResultType.IGNORE;
	}
	,printFinalStatistics: function(result,testCount,passCount,failCount,errorCount,ignoreCount,time) {
		this.printLine(this.divider2);
		var resultString = result ? "PASSED" : "FAILED";
		resultString += "\n" + "Tests: " + testCount + "  Passed: " + passCount + "  Failed: " + failCount + " Errors: " + errorCount + " Ignored: " + ignoreCount + " Time: " + massive_munit_util_MathUtil.round(time,5);
		this.printLine(resultString);
		this.printLine("");
	}
	,printOverallResult: function(result) {
		this.printLine("");
	}
	,print: function(value) {
		this.output += Std.string(value);
	}
	,printLine: function(value,indent) {
		if(indent == null) {
			indent = 0;
		}
		value = Std.string(value);
		value = this.indentString(value,indent);
		this.print("\n" + Std.string(value));
	}
	,indentString: function(value,indent) {
		if(indent == null) {
			indent = 0;
		}
		if(indent > 0) {
			value = StringTools.lpad(""," ",indent * 4) + value;
		}
		if(value == "") {
			value = "";
		}
		return value;
	}
	,__class__: massive_munit_client_PrintClientBase
});
var massive_munit_client_PrintClient = function(includeIgnoredReport) {
	if(includeIgnoredReport == null) {
		includeIgnoredReport = true;
	}
	massive_munit_client_PrintClientBase.call(this,includeIgnoredReport);
	this.id = "print";
};
$hxClasses["massive.munit.client.PrintClient"] = massive_munit_client_PrintClient;
massive_munit_client_PrintClient.__name__ = ["massive","munit","client","PrintClient"];
massive_munit_client_PrintClient.__super__ = massive_munit_client_PrintClientBase;
massive_munit_client_PrintClient.prototype = $extend(massive_munit_client_PrintClientBase.prototype,{
	init: function() {
		massive_munit_client_PrintClientBase.prototype.init.call(this);
		this.external = new massive_munit_client_ExternalPrintClientJS();
		this.initJS();
		this.originalTrace = haxe_Log.trace;
		haxe_Log.trace = $bind(this,this.customTrace);
	}
	,initJS: function() {
		var div = window.document.getElementById("haxe:trace");
		if(div == null) {
			var positionInfo = massive_haxe_util_ReflectUtil.here({ fileName : "PrintClient.hx", lineNumber : 141, className : "massive.munit.client.PrintClient", methodName : "initJS"});
			var error = "MissingElementException: 'haxe:trace' element not found at " + positionInfo.className + "#" + positionInfo.methodName + "(" + positionInfo.lineNumber + ")";
			js_Lib.alert(error);
		}
	}
	,printOverallResult: function(result) {
		massive_munit_client_PrintClientBase.prototype.printOverallResult.call(this,result);
		this.external.setResult(result);
		this.external.setResultBackground(result);
	}
	,customTrace: function(value,info) {
		this.addTrace(value,info);
	}
	,reportFinalStatistics: function(testCount,passCount,failCount,errorCount,ignoreCount,time) {
		return massive_munit_client_PrintClientBase.prototype.reportFinalStatistics.call(this,testCount,passCount,failCount,errorCount,ignoreCount,time);
	}
	,print: function(value) {
		massive_munit_client_PrintClientBase.prototype.print.call(this,value);
		this.external.print(value);
	}
	,printLine: function(value,indent) {
		if(indent == null) {
			indent = 0;
		}
		massive_munit_client_PrintClientBase.prototype.printLine.call(this,value,indent);
	}
	,__class__: massive_munit_client_PrintClient
});
var massive_munit_client_ExternalPrintClient = function() { };
$hxClasses["massive.munit.client.ExternalPrintClient"] = massive_munit_client_ExternalPrintClient;
massive_munit_client_ExternalPrintClient.__name__ = ["massive","munit","client","ExternalPrintClient"];
massive_munit_client_ExternalPrintClient.prototype = {
	__class__: massive_munit_client_ExternalPrintClient
};
var massive_munit_client_ExternalPrintClientJS = function() {
	var div = window.document.getElementById("haxe:trace");
	if(div == null) {
		var positionInfo = massive_haxe_util_ReflectUtil.here({ fileName : "PrintClientBase.hx", lineNumber : 347, className : "massive.munit.client.ExternalPrintClientJS", methodName : "new"});
		var error = "MissingElementException: 'haxe:trace' element not found at " + positionInfo.className + "#" + positionInfo.methodName + "(" + positionInfo.lineNumber + ")";
		js_Lib.alert(error);
	}
};
$hxClasses["massive.munit.client.ExternalPrintClientJS"] = massive_munit_client_ExternalPrintClientJS;
massive_munit_client_ExternalPrintClientJS.__name__ = ["massive","munit","client","ExternalPrintClientJS"];
massive_munit_client_ExternalPrintClientJS.__interfaces__ = [massive_munit_client_ExternalPrintClient];
massive_munit_client_ExternalPrintClientJS.prototype = {
	print: function(value) {
		this.queue("munitPrint",value);
	}
	,printLine: function(value) {
		this.queue("munitPrintLine",value);
	}
	,setResult: function(value) {
		this.queue("setResult",value);
	}
	,setResultBackground: function(value) {
		this.queue("setResultBackground",value);
	}
	,trace: function(value) {
		this.queue("munitTrace",value);
	}
	,createTestClass: function(className) {
		this.queue("createTestClass",className);
	}
	,printToTestClassSummary: function(value) {
		this.queue("updateTestSummary",value);
	}
	,setTestClassResult: function(resultType) {
		this.queue("setTestClassResult",resultType);
	}
	,addTestPass: function(value) {
		if(value == null) {
			return;
		}
		this.queue("addTestPass",value);
	}
	,addTestFail: function(value) {
		this.queue("addTestFail",value);
	}
	,addTestError: function(value) {
		this.queue("addTestError",value);
	}
	,addTestIgnore: function(value) {
		this.queue("addTestIgnore",value);
	}
	,addTestClassCoverage: function(className,percent) {
		if(percent == null) {
			percent = 0;
		}
		this.queue("addTestCoverageClass",[className,percent]);
	}
	,addTestClassCoverageItem: function(value) {
		this.queue("addTestCoverageItem",value);
	}
	,createCoverageReport: function(percent) {
		if(percent == null) {
			percent = 0;
		}
		this.queue("createCoverageReport",percent);
	}
	,addMissingCoverageClass: function(className,percent) {
		if(percent == null) {
			percent = 0;
		}
		this.queue("addMissingCoverageClass",[className,percent]);
	}
	,addCoverageReportSection: function(name,value) {
		this.queue("addCoverageReportSection",[name,value]);
	}
	,addCoverageSummary: function(value) {
		this.queue("addCoverageSummary",value);
	}
	,printSummary: function(value) {
		this.queue("printSummary",value);
	}
	,queue: function(method,args) {
		var a = [];
		if((args instanceof Array) && args.__enum__ == null) {
			a = a.concat(js_Boot.__cast(args , Array));
		} else {
			a.push(args);
		}
		var jsCode = this.convertToJavaScript(method,a);
		return eval(jsCode);
	}
	,convertToJavaScript: function(method,args) {
		var htmlArgs = [];
		var _g = 0;
		while(_g < args.length) {
			var arg = args[_g];
			++_g;
			var html = this.serialiseToHTML(Std.string(arg));
			htmlArgs.push(html);
		}
		var jsCode;
		if(htmlArgs == null || htmlArgs.length == 0) {
			jsCode = "addToQueue(\"" + method + "\")";
		} else {
			jsCode = "addToQueue(\"" + method + "\"";
			var _g1 = 0;
			while(_g1 < htmlArgs.length) {
				var arg1 = htmlArgs[_g1];
				++_g1;
				jsCode += ",\"" + arg1 + "\"";
			}
			jsCode += ")";
		}
		return jsCode;
	}
	,serialiseToHTML: function(value) {
		value = js_Boot.__string_rec(value,"");
		var v = StringTools.htmlEscape(value);
		v = v.split("\n").join("<br/>");
		v = v.split(" ").join("&nbsp;");
		v = v.split("\"").join("\\'");
		return v;
	}
	,__class__: massive_munit_client_ExternalPrintClientJS
};
var massive_munit_client_RichPrintClient = function() {
	massive_munit_client_PrintClientBase.call(this);
	this.id = "RichPrintClient";
};
$hxClasses["massive.munit.client.RichPrintClient"] = massive_munit_client_RichPrintClient;
massive_munit_client_RichPrintClient.__name__ = ["massive","munit","client","RichPrintClient"];
massive_munit_client_RichPrintClient.__super__ = massive_munit_client_PrintClientBase;
massive_munit_client_RichPrintClient.prototype = $extend(massive_munit_client_PrintClientBase.prototype,{
	init: function() {
		massive_munit_client_PrintClientBase.prototype.init.call(this);
		this.originalTrace = haxe_Log.trace;
		haxe_Log.trace = $bind(this,this.customTrace);
		this.external = new massive_munit_client_ExternalPrintClientJS();
	}
	,initializeTestClass: function() {
		massive_munit_client_PrintClientBase.prototype.initializeTestClass.call(this);
		this.external.createTestClass(this.currentTestClass);
		this.external.printToTestClassSummary("Class: " + this.currentTestClass + " ");
	}
	,updateTestClass: function(result) {
		massive_munit_client_PrintClientBase.prototype.updateTestClass.call(this,result);
		var value = this.serializeTestResult(result);
		var _g = result.get_type();
		switch(_g[1]) {
		case 0:
			break;
		case 1:
			this.external.printToTestClassSummary(".");
			this.external.addTestPass(value);
			break;
		case 2:
			this.external.printToTestClassSummary("!");
			this.external.addTestFail(value);
			break;
		case 3:
			this.external.printToTestClassSummary("x");
			this.external.addTestError(value);
			break;
		case 4:
			this.external.printToTestClassSummary(",");
			this.external.addTestIgnore(value);
			break;
		}
	}
	,serializeTestResult: function(result) {
		var summary = result.name;
		if(result.description != null && result.description != "") {
			summary += " - " + result.description + " -";
		}
		summary += " (" + massive_munit_util_MathUtil.round(result.executionTime,4) + "s)";
		var str = null;
		if(result.error != null) {
			str = "Error: " + summary + "\n" + Std.string(result.error);
		} else if(result.failure != null) {
			str = "Failure: " + summary + "\n" + Std.string(result.failure);
		} else if(result.ignore) {
			str = "Ignore: " + summary;
		} else {
			var result1 = result.passed;
		}
		return str;
	}
	,finalizeTestClass: function() {
		massive_munit_client_PrintClientBase.prototype.finalizeTestClass.call(this);
		this.testClassResultType = this.getTestClassResultType();
		var code;
		var _g = this.testClassResultType;
		switch(_g[1]) {
		case 1:
			code = 0;
			break;
		case 2:
			code = 1;
			break;
		case 3:
			code = 2;
			break;
		case 4:
			code = 3;
			break;
		default:
			code = -1;
		}
		if(code == -1) {
			return;
		}
		this.external.setTestClassResult(code);
	}
	,getTestClassResultType: function() {
		if(this.errorCount > 0) {
			return massive_munit_TestResultType.ERROR;
		} else if(this.failCount > 0) {
			return massive_munit_TestResultType.FAIL;
		} else if(this.ignoreCount > 0) {
			return massive_munit_TestResultType.IGNORE;
		} else {
			return massive_munit_TestResultType.PASS;
		}
	}
	,setCurrentTestClassCoverage: function(result) {
		massive_munit_client_PrintClientBase.prototype.setCurrentTestClassCoverage.call(this,result);
		this.external.printToTestClassSummary(" [" + result.percent + "%]");
		if(result.percent == 100) {
			return;
		}
		this.external.addTestClassCoverage(result.className,result.percent);
		var _g = 0;
		var _g1 = result.blocks;
		while(_g < _g1.length) {
			var item = _g1[_g];
			++_g;
			this.external.addTestClassCoverageItem(item);
		}
	}
	,reportFinalCoverage: function(percent,missingCoverageResults,summary,classBreakdown,packageBreakdown,executionFrequency) {
		if(percent == null) {
			percent = 0;
		}
		massive_munit_client_PrintClientBase.prototype.reportFinalCoverage.call(this,percent,missingCoverageResults,summary,classBreakdown,packageBreakdown,executionFrequency);
		this.external.createCoverageReport(percent);
		this.printMissingCoverage(missingCoverageResults);
		if(executionFrequency != null) {
			this.external.addCoverageReportSection("Code Execution Frequency",this.trim(executionFrequency));
		}
		if(classBreakdown != null) {
			this.external.addCoverageReportSection("Class Breakdown",this.trim(classBreakdown));
		}
		if(packageBreakdown != null) {
			this.external.addCoverageReportSection("Package Breakdown",this.trim(packageBreakdown));
		}
		if(packageBreakdown != null) {
			this.external.addCoverageReportSection("Summary",this.trim(summary));
		}
	}
	,trim: function(output) {
		while(output.indexOf("\n") == 0) output = HxOverrides.substr(output,1,null);
		while(output.lastIndexOf("\n") == output.length - 2) output = HxOverrides.substr(output,0,output.length - 2);
		return output;
	}
	,printMissingCoverage: function(missingCoverageResults) {
		if(missingCoverageResults == null || missingCoverageResults.length == 0) {
			return;
		}
		var _g = 0;
		while(_g < missingCoverageResults.length) {
			var result = missingCoverageResults[_g];
			++_g;
			this.external.addMissingCoverageClass(result.className,result.percent);
			var _g1 = 0;
			var _g2 = result.blocks;
			while(_g1 < _g2.length) {
				var item = _g2[_g1];
				++_g1;
				this.external.addTestClassCoverageItem(item);
			}
		}
	}
	,printReports: function() {
		massive_munit_client_PrintClientBase.prototype.printReports.call(this);
	}
	,printFinalStatistics: function(result,testCount,passCount,failCount,errorCount,ignoreCount,time) {
		massive_munit_client_PrintClientBase.prototype.printFinalStatistics.call(this,result,testCount,passCount,failCount,errorCount,ignoreCount,time);
		var resultString = result ? "PASSED" : "FAILED";
		resultString += "\n" + "Tests: " + testCount + "  Passed: " + passCount + "  Failed: " + failCount + " Errors: " + errorCount + " Ignored: " + ignoreCount + " Time: " + massive_munit_util_MathUtil.round(time,5);
		this.external.printSummary(resultString);
	}
	,printOverallResult: function(result) {
		massive_munit_client_PrintClientBase.prototype.printOverallResult.call(this,result);
		this.external.setResult(result);
	}
	,customTrace: function(value,info) {
		this.addTrace(value,info);
		var traces = this.getTraces();
		var t = traces[traces.length - 1];
		this.external.trace(t);
	}
	,print: function(value) {
		massive_munit_client_PrintClientBase.prototype.print.call(this,value);
		return;
	}
	,printLine: function(value,indent) {
		if(indent == null) {
			indent = 0;
		}
		massive_munit_client_PrintClientBase.prototype.printLine.call(this,value,indent);
	}
	,__class__: massive_munit_client_RichPrintClient
});
var massive_munit_client_SummaryReportClient = function() {
	massive_munit_client_AbstractTestResultClient.call(this);
	this.id = "summary";
};
$hxClasses["massive.munit.client.SummaryReportClient"] = massive_munit_client_SummaryReportClient;
massive_munit_client_SummaryReportClient.__name__ = ["massive","munit","client","SummaryReportClient"];
massive_munit_client_SummaryReportClient.__super__ = massive_munit_client_AbstractTestResultClient;
massive_munit_client_SummaryReportClient.prototype = $extend(massive_munit_client_AbstractTestResultClient.prototype,{
	printFinalStatistics: function(result,testCount,passCount,failCount,errorCount,ignoreCount,time) {
		this.output = "";
		this.output += "result:" + (result == null ? "null" : "" + result);
		this.output += "\ncount:" + testCount;
		this.output += "\npass:" + passCount;
		this.output += "\nfail:" + failCount;
		this.output += "\nerror:" + errorCount;
		this.output += "\nignore:" + ignoreCount;
		this.output += "\ntime:" + time;
		this.output += "\n";
		var resultCount = 0;
		while(this.totalResults.length > 0 && resultCount < 10) {
			var result1 = this.totalResults.shift();
			if(!result1.passed) {
				this.output += "\n# " + result1.get_location();
				++resultCount;
			}
		}
		var remainder = failCount + errorCount - resultCount;
		if(remainder > 0) {
			this.output += "# ... plus " + remainder + " more";
		}
	}
	,printOverallResult: function(result) {
	}
	,printReports: function() {
	}
	,__class__: massive_munit_client_SummaryReportClient
});
var massive_munit_util_MathUtil = function() {
};
$hxClasses["massive.munit.util.MathUtil"] = massive_munit_util_MathUtil;
massive_munit_util_MathUtil.__name__ = ["massive","munit","util","MathUtil"];
massive_munit_util_MathUtil.round = function(value,precision) {
	value *= Math.pow(10,precision);
	return Math.round(value) / Math.pow(10,precision);
};
massive_munit_util_MathUtil.prototype = {
	__class__: massive_munit_util_MathUtil
};
var massive_munit_util_Timer = $hx_exports["massive"]["munit"]["util"]["Timer"] = function(time_ms) {
	this.id = massive_munit_util_Timer.arr.length;
	massive_munit_util_Timer.arr[this.id] = this;
	this.timerId = window.setInterval("massive.munit.util.Timer.arr[" + this.id + "].run();",time_ms);
};
$hxClasses["massive.munit.util.Timer"] = massive_munit_util_Timer;
massive_munit_util_Timer.__name__ = ["massive","munit","util","Timer"];
massive_munit_util_Timer.delay = function(f,time_ms) {
	var t = new massive_munit_util_Timer(time_ms);
	t.run = function() {
		t.stop();
		f();
	};
	return t;
};
massive_munit_util_Timer.stamp = function() {
	return new Date().getTime() / 1000;
};
massive_munit_util_Timer.prototype = {
	stop: function() {
		if(this.id == null) {
			return;
		}
		window.clearInterval(this.timerId);
		massive_munit_util_Timer.arr[this.id] = null;
		if(this.id > 100 && this.id == massive_munit_util_Timer.arr.length - 1) {
			var p = this.id - 1;
			while(p >= 0 && massive_munit_util_Timer.arr[p] == null) --p;
			massive_munit_util_Timer.arr = massive_munit_util_Timer.arr.slice(0,p + 1);
		}
		this.id = null;
	}
	,run: function() {
	}
	,__class__: massive_munit_util_Timer
};
var mcover_Exception = function(message,cause,info) {
	this.type = this.here({ fileName : "Exception.hx", lineNumber : 72, className : "mcover.Exception", methodName : "new"}).className;
	this.message = message;
	this.cause = cause;
	this.info = info;
	if(cause != null) {
		this.causeExceptionStack = haxe_CallStack.exceptionStack();
		this.causeCallStack = haxe_CallStack.callStack();
	}
};
$hxClasses["mcover.Exception"] = mcover_Exception;
mcover_Exception.__name__ = ["mcover","Exception"];
mcover_Exception.prototype = {
	toString: function() {
		var str = this.type + ": " + this.message;
		if(this.info != null) {
			str += " at " + this.info.className + "#" + this.info.methodName + " (" + this.info.lineNumber + ")";
		}
		if(this.cause != null) {
			str += "\n\t Caused by: " + Std.string(this.cause);
		}
		return str;
	}
	,here: function(info) {
		return info;
	}
	,__class__: mcover_Exception
};
var mcover_coverage_CoverageException = function(message,cause,info) {
	mcover_Exception.call(this,message,cause,info);
	this.type = this.here({ fileName : "CoverageException.hx", lineNumber : 39, className : "mcover.coverage.CoverageException", methodName : "new"}).className;
};
$hxClasses["mcover.coverage.CoverageException"] = mcover_coverage_CoverageException;
mcover_coverage_CoverageException.__name__ = ["mcover","coverage","CoverageException"];
mcover_coverage_CoverageException.__super__ = mcover_Exception;
mcover_coverage_CoverageException.prototype = $extend(mcover_Exception.prototype,{
	__class__: mcover_coverage_CoverageException
});
var mcover_coverage_CoverageLogger = function() { };
$hxClasses["mcover.coverage.CoverageLogger"] = mcover_coverage_CoverageLogger;
mcover_coverage_CoverageLogger.__name__ = ["mcover","coverage","CoverageLogger"];
mcover_coverage_CoverageLogger.prototype = {
	__class__: mcover_coverage_CoverageLogger
};
var mcover_coverage_CoverageLoggerImpl = function() {
	this.allStatementResultsById = new haxe_ds_IntMap();
	this.allBranchResultsById = new haxe_ds_IntMap();
	this.filteredResultsMap = new haxe_ds_StringMap();
	this.clients = [];
};
$hxClasses["mcover.coverage.CoverageLoggerImpl"] = mcover_coverage_CoverageLoggerImpl;
mcover_coverage_CoverageLoggerImpl.__name__ = ["mcover","coverage","CoverageLoggerImpl"];
mcover_coverage_CoverageLoggerImpl.__interfaces__ = [mcover_coverage_CoverageLogger];
mcover_coverage_CoverageLoggerImpl.prototype = {
	report: function(skipClients) {
		if(skipClients == null) {
			skipClients = false;
		}
		this.generateReportResults(false);
		if(!skipClients) {
			this.reportToClients();
		}
	}
	,reportCurrentTest: function(skipClients) {
		if(skipClients == null) {
			skipClients = false;
		}
		if(this.currentTest == null) {
			throw new js__$Boot_HaxeError(new mcover_coverage_CoverageException("No test specified to report on.",null,{ fileName : "CoverageLogger.hx", lineNumber : 149, className : "mcover.coverage.CoverageLoggerImpl", methodName : "reportCurrentTest"}));
		}
		this.generateReportResults(true);
		if(!skipClients) {
			this.reportToClients();
		}
	}
	,generateReportResults: function(currentTestOnly) {
		if(currentTestOnly == null) {
			currentTestOnly = false;
		}
		if(this.coverage == null) {
			this.initializeCoverage(null);
		}
		if(currentTestOnly) {
			this.coverage.setStatementResultsMap(this.currentFilteredResults.statementResultsById);
			this.coverage.setBranchResultsMap(this.currentFilteredResults.branchResultsById);
		} else {
			this.coverage.setStatementResultsMap(this.allStatementResultsById);
			this.coverage.setBranchResultsMap(this.allBranchResultsById);
		}
		this.coverage.getResults(false);
	}
	,addClient: function(client) {
		if(client == null) {
			throw new js__$Boot_HaxeError("Null Client");
		}
		var _g = 0;
		var _g1 = this.clients;
		while(_g < _g1.length) {
			var c = _g1[_g];
			++_g;
			if(c == client) {
				return;
			}
		}
		client.completionHandler = $bind(this,this.clientCompletionHandler);
		this.clients.push(client);
	}
	,removeClient: function(client) {
		client.completionHandler = null;
		HxOverrides.remove(this.clients,client);
	}
	,getClients: function() {
		return this.clients.concat([]);
	}
	,initializeCoverage: function(resourceName) {
		if(resourceName == null) {
			resourceName = mcover_coverage_MCoverage.RESOURCE_DATA;
		}
		var serializedData = haxe_Resource.getString(resourceName);
		if(serializedData == null) {
			throw new js__$Boot_HaxeError(new mcover_coverage_CoverageException("No generated coverage data found in haxe Resource '" + resourceName + "'",null,{ fileName : "CoverageLogger.hx", lineNumber : 207, className : "mcover.coverage.CoverageLoggerImpl", methodName : "initializeCoverage"}));
		}
		try {
			this.coverage = haxe_Unserializer.run(serializedData);
		} catch( e ) {
			haxe_CallStack.lastException = e;
			if (e instanceof js__$Boot_HaxeError) e = e.val;
			throw new js__$Boot_HaxeError(new mcover_coverage_CoverageException("Unable to unserialize coverage data in " + resourceName,e,{ fileName : "CoverageLogger.hx", lineNumber : 214, className : "mcover.coverage.CoverageLoggerImpl", methodName : "initializeCoverage"}));
		}
	}
	,logStatement: function(id) {
		this.updateStatementMap(this.allStatementResultsById,id);
		if(this.currentFilteredResults != null) {
			this.updateStatementMap(this.currentFilteredResults.statementResultsById,id);
		}
	}
	,updateStatementMap: function(map,id) {
		var count = 1;
		if(map.h.hasOwnProperty(id)) {
			count = map.h[id] + 1;
		}
		map.h[id] = count;
	}
	,logBranch: function(id,value,compareValue) {
		var bool = false;
		if(compareValue != null) {
			bool = value == compareValue;
		} else {
			bool = value;
		}
		this.updateBranchMap(this.allBranchResultsById,id,bool);
		if(this.currentFilteredResults != null) {
			this.updateBranchMap(this.currentFilteredResults.branchResultsById,id,bool);
		}
		return value;
	}
	,updateBranchMap: function(map,id,value) {
		var r = null;
		if(map.h.hasOwnProperty(id)) {
			r = map.h[id];
		} else {
			r = { id : id, trueCount : 0, falseCount : 0, total : 0};
			map.h[id] = r;
		}
		if(value) {
			r.trueCount++;
		} else {
			r.falseCount++;
		}
		r.total++;
	}
	,set_currentTest: function(value) {
		this.currentTest = value;
		if(value == null) {
			this.currentFilteredResults = null;
			return value;
		}
		var _this = this.filteredResultsMap;
		if(!(__map_reserved[value] != null ? _this.existsReserved(value) : _this.h.hasOwnProperty(value))) {
			var result = { filter : value, statementResultsById : new haxe_ds_IntMap(), branchResultsById : new haxe_ds_IntMap()};
			var _this1 = this.filteredResultsMap;
			if(__map_reserved[value] != null) {
				_this1.setReserved(value,result);
			} else {
				_this1.h[value] = result;
			}
		}
		var _this2 = this.filteredResultsMap;
		this.currentFilteredResults = __map_reserved[value] != null ? _this2.getReserved(value) : _this2.h[value];
		return value;
	}
	,reportToClients: function() {
		if(this.clients.length == 0) {
			this.addClient(new mcover_coverage_client_TraceClient());
		}
		this.clientCompleteCount = 0;
		var _g = 0;
		var _g1 = this.clients;
		while(_g < _g1.length) {
			var client = _g1[_g];
			++_g;
			client.report(this.coverage);
		}
	}
	,clientCompletionHandler: function(client) {
		this.clientCompleteCount++;
		if(this.clientCompleteCount == this.clients.length) {
			if(this.completionHandler != null) {
				this.executeCompletionHandler();
			}
		}
	}
	,executeCompletionHandler: function() {
		var percent = this.coverage.getPercentage();
		this.completionHandler(percent);
	}
	,__class__: mcover_coverage_CoverageLoggerImpl
};
var mcover_coverage_CoverageReportClient = function() { };
$hxClasses["mcover.coverage.CoverageReportClient"] = mcover_coverage_CoverageReportClient;
mcover_coverage_CoverageReportClient.__name__ = ["mcover","coverage","CoverageReportClient"];
mcover_coverage_CoverageReportClient.prototype = {
	__class__: mcover_coverage_CoverageReportClient
};
var mcover_coverage_AdvancedCoverageReportClient = function() { };
$hxClasses["mcover.coverage.AdvancedCoverageReportClient"] = mcover_coverage_AdvancedCoverageReportClient;
mcover_coverage_AdvancedCoverageReportClient.__name__ = ["mcover","coverage","AdvancedCoverageReportClient"];
mcover_coverage_AdvancedCoverageReportClient.__interfaces__ = [mcover_coverage_CoverageReportClient];
mcover_coverage_AdvancedCoverageReportClient.prototype = {
	__class__: mcover_coverage_AdvancedCoverageReportClient
};
var mcover_coverage_MCoverage = function() {
};
$hxClasses["mcover.coverage.MCoverage"] = mcover_coverage_MCoverage;
mcover_coverage_MCoverage.__name__ = ["mcover","coverage","MCoverage"];
mcover_coverage_MCoverage.getLogger = function() {
	if(mcover_coverage_MCoverage.logger == null) {
		mcover_coverage_MCoverage.logger = new mcover_coverage_CoverageLoggerImpl();
	}
	return mcover_coverage_MCoverage.logger;
};
mcover_coverage_MCoverage.prototype = {
	__class__: mcover_coverage_MCoverage
};
var mcover_coverage_client_PrintClient = function() {
	this.includeHeader = true;
	this.includeMissingBlocks = true;
	this.includeExecutionFrequency = true;
	this.includeClassBreakdown = true;
	this.includePackageBreakdown = true;
	this.includeSummary = true;
	this.includeOverallPercentage = true;
	this.maxBlockExecutionListSize = 25;
	this.newline = "\n";
	this.tab = " ";
	this.divider = this.newline + "----------------------------------------------------------------";
};
$hxClasses["mcover.coverage.client.PrintClient"] = mcover_coverage_client_PrintClient;
mcover_coverage_client_PrintClient.__name__ = ["mcover","coverage","client","PrintClient"];
mcover_coverage_client_PrintClient.__interfaces__ = [mcover_coverage_AdvancedCoverageReportClient];
mcover_coverage_client_PrintClient.prototype = {
	report: function(coverage) {
		this.output = "";
		this.header = "";
		this.executionFrequency = "";
		this.missingBlocks = "";
		this.classBreakdown = "";
		this.packageBreakdown = "";
		this.summary = "";
		this.overallPercentage = "";
		this.coverage = coverage;
		this.printReport();
		var timer = mcover_util_Timer.delay($bind(this,this.reportComplete),10);
	}
	,reportComplete: function() {
		if(this.completionHandler != null) {
			this.completionHandler(this);
		}
	}
	,printReport: function() {
		this.header = this.serializeHeader();
		this.executionFrequency = this.serializeExecutionFrequency();
		this.missingBlocks = this.serializeMissingBlocks();
		this.classBreakdown = this.serializeClassResults();
		this.packageBreakdown = this.serializePackageResults();
		this.summary = this.serializeSummary();
		this.overallPercentage = this.serializeOverallPercentage();
		this.output = this.serializeFinalOutput();
	}
	,serializeFinalOutput: function() {
		var output = "";
		if(this.includeHeader) {
			output += this.divider;
			output += this.newline;
			output += this.header;
			output += this.divider;
		}
		if(this.includeExecutionFrequency) {
			output += this.newline;
			output += this.executionFrequency;
		}
		if(this.includeMissingBlocks) {
			output += this.newline;
			output += this.missingBlocks;
		}
		if(this.includeClassBreakdown) {
			output += this.newline;
			output += this.classBreakdown;
		}
		if(this.includePackageBreakdown) {
			output += this.newline;
			output += this.packageBreakdown;
		}
		if(this.includeSummary) {
			output += this.newline;
			output += this.divider;
			output += this.newline;
			output += this.summary;
		}
		if(this.includeOverallPercentage) {
			output += this.newline;
			output += this.divider;
			output += this.overallPercentage;
			output += this.divider;
		}
		output += this.newline;
		return output;
	}
	,serializeHeader: function() {
		return "MCover Coverage Report, generated " + HxOverrides.dateStr(new Date());
	}
	,serializeOverallPercentage: function() {
		return this.printTabs(["COVERAGE RESULT",this.coverage.getPercentage() + "%"],20);
	}
	,serializeSummary: function() {
		var output = "";
		var r = this.coverage.getResults();
		output = this.printLine("OVERALL COVERAGE STATS:");
		output += this.printLine("");
		output += this.printSummaryLine("packages",r.pc,r.p);
		output += this.printSummaryLine("files",r.fc,r.f);
		output += this.printSummaryLine("classes",r.cc,r.c);
		output += this.printSummaryLine("methods",r.mc,r.m);
		output += this.printSummaryLine("statements",r.sc,r.s);
		output += this.printSummaryLine("branches",r.bc,r.b);
		output += this.printSummaryLine("lines",r.lc,r.l);
		return output;
	}
	,printSummaryLine: function(name,count,total) {
		var a = [""];
		a.push(name);
		if(count == 0) {
			a.push("0%");
		} else {
			a.push("" + mcover_util_NumberUtil.round(count / total * 100,2) + "%");
		}
		a.push("" + count + " / " + total);
		var s = 4;
		var w = 12;
		return this.printTabs(a,s,11,w);
	}
	,getPercentage: function(count,total) {
		return mcover_util_NumberUtil.round(count / total * 100,2);
	}
	,serializePackageResults: function() {
		var output = "";
		output = this.printLine("COVERAGE BREAKDOWN BY PACKAGE:");
		output += this.newline;
		var packages = this.coverage.getPackages();
		if(Lambda.count(packages) == 0) {
			output += this.printTabs(["","None"]);
			return output;
		}
		output += this.printTabs(["","Result","Files","Classes","Package"]);
		var _g = 0;
		while(_g < packages.length) {
			var pckg = packages[_g];
			++_g;
			var r = pckg.getResults();
			var packgName = pckg.name == "" ? "[Default]" : pckg.name;
			output += this.printTabs(["",pckg.getPercentage() + "%",r.fc + "/" + r.f,r.cc + "/" + r.c,packgName]);
		}
		return output;
	}
	,serializeClassResults: function() {
		var output = "";
		output = this.printLine("COVERAGE BREAKDOWN BY CLASSES:");
		output += this.newline;
		var classes = this.coverage.getClasses();
		if(Lambda.count(classes) == 0) {
			output += this.printTabs(["","None"]);
			return output;
		}
		output += this.printTabs(["","Result","Methods","Statements","Branches","Lines","Class"]);
		var _g = 0;
		while(_g < classes.length) {
			var cls = classes[_g];
			++_g;
			var r = cls.getResults();
			output += this.printTabs(["",cls.getPercentage() + "%",r.mc + "/" + r.m,r.sc + "/" + r.s,r.bc + "/" + r.b,r.lc + "/" + r.l,cls.name]);
		}
		return output;
	}
	,serializeMissingBlocks: function() {
		var output = "";
		output = this.printLine("MISSING STATEMENT COVERAGE:");
		output += this.newline;
		var statements = this.coverage.getMissingStatements();
		if(Lambda.count(statements) == 0) {
			output += this.printTabs(["","None"]);
		} else {
			var currentClass = null;
			var _g = 0;
			while(_g < statements.length) {
				var block = statements[_g];
				++_g;
				if(currentClass != block.qualifiedClassName) {
					currentClass = block.qualifiedClassName;
					output += this.printTabs(["","Class: " + block.qualifiedClassName]);
				}
				output += this.printTabs(["",block.toLocalString()],8);
			}
		}
		output += this.newline;
		output += this.printLine("MISSING BRANCH COVERAGE:");
		output += this.newline;
		var branches = this.coverage.getMissingBranches();
		if(Lambda.count(branches) == 0) {
			output += this.printTabs(["","None"]);
		} else {
			var currentClass1 = null;
			var _g1 = 0;
			while(_g1 < branches.length) {
				var block1 = branches[_g1];
				++_g1;
				if(currentClass1 != block1.qualifiedClassName) {
					currentClass1 = block1.qualifiedClassName;
					output += this.printTabs(["","Class: " + block1.qualifiedClassName]);
				}
				output += this.printTabs(["",block1.toLocalString()],8);
			}
		}
		return output;
	}
	,serializeExecutionFrequency: function() {
		var output = "";
		var statements = [];
		var key = this.coverage.statementResultsById.keys();
		while(key.hasNext()) {
			var key1 = key.next();
			var statement = this.coverage.getStatementById(key1);
			if(statement.count > 0) {
				statements.push(statement);
			}
		}
		output = this.printLine("TOP " + this.maxBlockExecutionListSize + " STATEMENTS BY EXECUTION FREQUENCY:");
		output += this.newline;
		if(Lambda.count(statements) == 0) {
			output += this.printTabs(["","None"]);
		} else {
			var statementSort = function(a,b) {
				return -a.count + b.count;
			};
			statements.sort(statementSort);
			output += this.printTabs(["","Count","Statement"]);
			var count = 0;
			var _g = 0;
			while(_g < statements.length) {
				var statement1 = statements[_g];
				++_g;
				output += this.printTabs(["",statement1.count,statement1.toString()]);
				++count;
				if(count >= this.maxBlockExecutionListSize) {
					break;
				}
			}
		}
		var branches = [];
		var key2 = this.coverage.branchResultsById.keys();
		while(key2.hasNext()) {
			var key3 = key2.next();
			var branch = this.coverage.getBranchById(key3);
			if(branch.get_totalCount() > 0) {
				branches.push(branch);
			}
		}
		output += this.newline;
		output += this.printLine("TOP " + this.maxBlockExecutionListSize + " BRANCHES BY EXECUTION FREQUENCY:");
		output += this.newline;
		if(Lambda.count(branches) == 0) {
			output += this.printTabs(["","None"]);
		} else {
			var branchSort = function(a1,b1) {
				return -a1.get_totalCount() + b1.get_totalCount();
			};
			branches.sort(branchSort);
			output += this.printTabs(["","Count","True","False","Branch"]);
			var count1 = 0;
			var _g1 = 0;
			while(_g1 < branches.length) {
				var branch1 = branches[_g1];
				++_g1;
				output += this.printTabs(["",branch1.get_totalCount(),branch1.trueCount,branch1.falseCount,branch1.toString()]);
				++count1;
				if(count1 >= this.maxBlockExecutionListSize) {
					break;
				}
			}
		}
		return output;
	}
	,printLine: function(value) {
		return this.newline + Std.string(value);
	}
	,printTabs: function(args,initialColumnWidth,columnWidth,secondColumnWidth) {
		if(secondColumnWidth == null) {
			secondColumnWidth = -1;
		}
		if(columnWidth == null) {
			columnWidth = 11;
		}
		if(initialColumnWidth == null) {
			initialColumnWidth = 4;
		}
		var s = "";
		var isFirst = true;
		var isSecond = false;
		if(secondColumnWidth == -1) {
			secondColumnWidth = columnWidth;
		}
		var _g = 0;
		while(_g < args.length) {
			var arg = args[_g];
			++_g;
			arg = Std.string(arg);
			if(isFirst) {
				isFirst = false;
				isSecond = true;
				s += StringTools.rpad(arg,this.tab,initialColumnWidth);
			} else if(isSecond) {
				isSecond = false;
				s += StringTools.rpad(arg,this.tab,secondColumnWidth);
			} else {
				s += StringTools.rpad(arg,this.tab,columnWidth);
			}
		}
		return this.newline + s;
	}
	,__class__: mcover_coverage_client_PrintClient
};
var mcover_coverage_client_TraceClient = function() {
	mcover_coverage_client_PrintClient.call(this);
	this.newline = "<br/>";
	this.tab = "&nbsp;";
};
$hxClasses["mcover.coverage.client.TraceClient"] = mcover_coverage_client_TraceClient;
mcover_coverage_client_TraceClient.__name__ = ["mcover","coverage","client","TraceClient"];
mcover_coverage_client_TraceClient.__super__ = mcover_coverage_client_PrintClient;
mcover_coverage_client_TraceClient.prototype = $extend(mcover_coverage_client_PrintClient.prototype,{
	printReport: function() {
		mcover_coverage_client_PrintClient.prototype.printReport.call(this);
		this.output += this.newline;
		haxe_Log.trace(this.newline + this.output,{ fileName : "TraceClient.hx", lineNumber : 46, className : "mcover.coverage.client.TraceClient", methodName : "printReport"});
	}
	,__class__: mcover_coverage_client_TraceClient
});
var mcover_coverage_data_AbstractNode = function() {
};
$hxClasses["mcover.coverage.data.AbstractNode"] = mcover_coverage_data_AbstractNode;
mcover_coverage_data_AbstractNode.__name__ = ["mcover","coverage","data","AbstractNode"];
mcover_coverage_data_AbstractNode.prototype = {
	getResults: function(cache) {
		if(cache == null) {
			cache = true;
		}
		if(this.resultCache == null || !cache) {
			this.resultCache = this.emptyResult();
		}
		return this.resultCache;
	}
	,getPercentage: function() {
		var r = this.getResults();
		try {
			var count = r.bt + r.bf + r.sc + r.mc;
			var total = 2 * r.b + r.s + r.m;
			if(count == 0 || total == 0) {
				return 0;
			}
			return Math.round(count / total * 10000) / 100;
		} catch( e ) {
			haxe_CallStack.lastException = e;
		}
		return 0;
	}
	,getClasses: function() {
		return [];
	}
	,lookupBranch: function(path) {
		return null;
	}
	,lookupStatement: function(path) {
		return null;
	}
	,getMissingBranches: function() {
		return [];
	}
	,getMissingStatements: function() {
		return [];
	}
	,emptyResult: function() {
		return { lc : 0, lp : 0, l : 0, sc : 0, s : 0, bt : 0, bf : 0, bc : 0, b : 0, mc : 0, m : 0, cc : 0, c : 0, fc : 0, f : 0, pc : 0, p : 0};
	}
	,hxSerialize: function(s) {
		s.serialize(this.id);
		s.serialize(this.name);
	}
	,hxUnserialize: function(s) {
		this.id = s.unserialize();
		this.name = s.unserialize();
	}
	,__class__: mcover_coverage_data_AbstractNode
};
var mcover_coverage_data_AbstractBlock = function() {
	mcover_coverage_data_AbstractNode.call(this);
	this.lines = [];
};
$hxClasses["mcover.coverage.data.AbstractBlock"] = mcover_coverage_data_AbstractBlock;
mcover_coverage_data_AbstractBlock.__name__ = ["mcover","coverage","data","AbstractBlock"];
mcover_coverage_data_AbstractBlock.__super__ = mcover_coverage_data_AbstractNode;
mcover_coverage_data_AbstractBlock.prototype = $extend(mcover_coverage_data_AbstractNode.prototype,{
	isCovered: function() {
		return false;
	}
	,toString: function() {
		return this.qualifiedClassName + "#" + this.toLocalString();
	}
	,toLocalString: function() {
		return this.methodName + " | " + this.location;
	}
	,hxSerialize: function(s) {
		mcover_coverage_data_AbstractNode.prototype.hxSerialize.call(this,s);
		s.serialize(this.file);
		s.serialize(this.packageName);
		s.serialize(this.className);
		s.serialize(this.qualifiedClassName);
		s.serialize(this.methodName);
		s.serialize(this.min);
		s.serialize(this.max);
		s.serialize(this.location);
		s.serialize(this.lookup);
		s.serialize(this.lines);
	}
	,hxUnserialize: function(s) {
		mcover_coverage_data_AbstractNode.prototype.hxUnserialize.call(this,s);
		this.file = s.unserialize();
		this.packageName = s.unserialize();
		this.className = s.unserialize();
		this.qualifiedClassName = s.unserialize();
		this.methodName = s.unserialize();
		this.min = s.unserialize();
		this.max = s.unserialize();
		this.location = s.unserialize();
		this.lookup = s.unserialize();
		this.lines = s.unserialize();
	}
	,__class__: mcover_coverage_data_AbstractBlock
});
var mcover_coverage_data_AbstractNodeList = function() {
	mcover_coverage_data_AbstractNode.call(this);
	this.itemCount = 0;
	this.itemsById = new haxe_ds_IntMap();
	this.items = new haxe_ds_StringMap();
};
$hxClasses["mcover.coverage.data.AbstractNodeList"] = mcover_coverage_data_AbstractNodeList;
mcover_coverage_data_AbstractNodeList.__name__ = ["mcover","coverage","data","AbstractNodeList"];
mcover_coverage_data_AbstractNodeList.__super__ = mcover_coverage_data_AbstractNode;
mcover_coverage_data_AbstractNodeList.prototype = $extend(mcover_coverage_data_AbstractNode.prototype,{
	getItemByName: function(name,cls) {
		var _this = this.items;
		if(!(__map_reserved[name] != null ? _this.existsReserved(name) : _this.h.hasOwnProperty(name))) {
			var item = Type.createInstance(cls,[]);
			item.id = this.itemCount++;
			item.name = name;
			var _this1 = this.items;
			var value = item.id;
			if(__map_reserved[name] != null) {
				_this1.setReserved(name,value);
			} else {
				_this1.h[name] = value;
			}
			this.itemsById.h[item.id] = item;
		}
		var _this2 = this.itemsById;
		var _this3 = this.items;
		var key = __map_reserved[name] != null ? _this3.getReserved(name) : _this3.h[name];
		return _this2.h[key];
	}
	,lookupBranch: function(path) {
		var itemId = path.shift();
		if(itemId == null || !this.itemsById.h.hasOwnProperty(itemId)) {
			return null;
		}
		return this.itemsById.h[itemId].lookupBranch(path);
	}
	,lookupStatement: function(path) {
		var itemId = path.shift();
		if(itemId == null || !this.itemsById.h.hasOwnProperty(itemId)) {
			return null;
		}
		return this.itemsById.h[itemId].lookupStatement(path);
	}
	,getMissingBranches: function() {
		var a = [];
		var node = this.itemsById.iterator();
		while(node.hasNext()) {
			var node1 = node.next();
			var tmp = node1.getMissingBranches();
			a = a.concat(tmp);
		}
		a.sort(mcover_coverage_data_DataUtil.sortOnBlockName);
		return a;
	}
	,getMissingStatements: function() {
		var a = [];
		var node = this.itemsById.iterator();
		while(node.hasNext()) {
			var node1 = node.next();
			var tmp = node1.getMissingStatements();
			a = a.concat(tmp);
		}
		a.sort(mcover_coverage_data_DataUtil.sortOnBlockName);
		return a;
	}
	,getClasses: function() {
		var a = [];
		var node = this.itemsById.iterator();
		while(node.hasNext()) {
			var node1 = node.next();
			var tmp = node1.getClasses();
			a = a.concat(tmp);
		}
		return a;
	}
	,getResults: function(cache) {
		if(cache == null) {
			cache = true;
		}
		if(this.resultCache == null || !cache) {
			this.resultCache = this.emptyResult();
			var node = this.itemsById.iterator();
			while(node.hasNext()) {
				var node1 = node.next();
				var tmp = node1.getResults(cache);
				this.resultCache = this.appendResults(this.resultCache,tmp);
			}
		}
		return this.resultCache;
	}
	,appendResults: function(to,from) {
		to.sc += from.sc;
		to.s += from.s;
		to.bt += from.bt;
		to.bf += from.bf;
		to.bc += from.bc;
		to.b += from.b;
		to.mc += from.mc;
		to.m += from.m;
		to.cc += from.cc;
		to.c += from.c;
		to.fc += from.fc;
		to.f += from.f;
		to.pc += from.pc;
		to.p += from.p;
		to.lc += from.lc;
		to.lp += from.lp;
		to.l += from.l;
		return to;
	}
	,hxSerialize: function(s) {
		mcover_coverage_data_AbstractNode.prototype.hxSerialize.call(this,s);
		s.serialize(this.itemsById);
		s.serialize(this.items);
		s.serialize(this.itemCount);
	}
	,hxUnserialize: function(s) {
		mcover_coverage_data_AbstractNode.prototype.hxUnserialize.call(this,s);
		this.itemsById = s.unserialize();
		this.items = s.unserialize();
		this.itemCount = s.unserialize();
	}
	,__class__: mcover_coverage_data_AbstractNodeList
});
var mcover_coverage_data_Branch = function() {
	mcover_coverage_data_AbstractBlock.call(this);
	this.trueCount = 0;
	this.falseCount = 0;
};
$hxClasses["mcover.coverage.data.Branch"] = mcover_coverage_data_Branch;
mcover_coverage_data_Branch.__name__ = ["mcover","coverage","data","Branch"];
mcover_coverage_data_Branch.__super__ = mcover_coverage_data_AbstractBlock;
mcover_coverage_data_Branch.prototype = $extend(mcover_coverage_data_AbstractBlock.prototype,{
	get_totalCount: function() {
		return this.trueCount + this.falseCount;
	}
	,isCovered: function() {
		if(this.trueCount > 0) {
			return this.falseCount > 0;
		} else {
			return false;
		}
	}
	,isPartiallyCovered: function() {
		if(!this.isCovered()) {
			if(this.trueCount <= 0) {
				return this.falseCount > 0;
			} else {
				return true;
			}
		} else {
			return false;
		}
	}
	,toLocalString: function() {
		var s = mcover_coverage_data_AbstractBlock.prototype.toLocalString.call(this);
		if(!this.isCovered()) {
			s += " | ";
			if(this.trueCount == 0) {
				s += "t";
			}
			if(this.trueCount == 0 && this.falseCount == 0) {
				s += ",";
			}
			if(this.falseCount == 0) {
				s += "f";
			}
		}
		return s;
	}
	,hxSerialize: function(s) {
		mcover_coverage_data_AbstractBlock.prototype.hxSerialize.call(this,s);
		s.serialize(this.trueCount);
		s.serialize(this.falseCount);
	}
	,hxUnserialize: function(s) {
		mcover_coverage_data_AbstractBlock.prototype.hxUnserialize.call(this,s);
		this.trueCount = s.unserialize();
		this.falseCount = s.unserialize();
	}
	,__class__: mcover_coverage_data_Branch
});
var mcover_coverage_data_Clazz = function() {
	mcover_coverage_data_AbstractNodeList.call(this);
};
$hxClasses["mcover.coverage.data.Clazz"] = mcover_coverage_data_Clazz;
mcover_coverage_data_Clazz.__name__ = ["mcover","coverage","data","Clazz"];
mcover_coverage_data_Clazz.__super__ = mcover_coverage_data_AbstractNodeList;
mcover_coverage_data_Clazz.prototype = $extend(mcover_coverage_data_AbstractNodeList.prototype,{
	getMethods: function() {
		var a = [];
		var item = this.itemsById.iterator();
		while(item.hasNext()) {
			var item1 = item.next();
			if((item1 == null ? null : js_Boot.getClass(item1)) == mcover_coverage_data_Method) {
				a.push(js_Boot.__cast(item1 , mcover_coverage_data_Method));
			}
		}
		return a;
	}
	,appendResults: function(to,from) {
		to = mcover_coverage_data_AbstractNodeList.prototype.appendResults.call(this,to,from);
		to.mc += from.sc > 0 ? 1 : 0;
		to.m += 1;
		return to;
	}
	,__class__: mcover_coverage_data_Clazz
});
var mcover_coverage_data_Coverage = function() {
	mcover_coverage_data_AbstractNodeList.call(this);
	this.statements = new haxe_ds_IntMap();
	this.branches = new haxe_ds_IntMap();
	this.statementResultsById = new haxe_ds_IntMap();
	this.branchResultsById = new haxe_ds_IntMap();
};
$hxClasses["mcover.coverage.data.Coverage"] = mcover_coverage_data_Coverage;
mcover_coverage_data_Coverage.__name__ = ["mcover","coverage","data","Coverage"];
mcover_coverage_data_Coverage.__super__ = mcover_coverage_data_AbstractNodeList;
mcover_coverage_data_Coverage.prototype = $extend(mcover_coverage_data_AbstractNodeList.prototype,{
	setStatementResultsMap: function(map) {
		this.statementResultsById = map;
	}
	,setBranchResultsMap: function(map) {
		this.branchResultsById = map;
	}
	,addStatement: function(block) {
		this.verifyBlockData(block);
		if(this.statements.h.hasOwnProperty(block.id)) {
			throw new js__$Boot_HaxeError(new mcover_Exception("Statement already exists: " + block.id + " " + block.toString(),null,{ fileName : "Coverage.hx", lineNumber : 78, className : "mcover.coverage.data.Coverage", methodName : "addStatement"}));
		}
		var packg = js_Boot.__cast(this.getItemByName(block.packageName,mcover_coverage_data_Package) , mcover_coverage_data_Package);
		var file = js_Boot.__cast(packg.getItemByName(block.file,mcover_coverage_data_File) , mcover_coverage_data_File);
		var clazz = js_Boot.__cast(file.getItemByName(block.qualifiedClassName,mcover_coverage_data_Clazz) , mcover_coverage_data_Clazz);
		var method = js_Boot.__cast(clazz.getItemByName(block.methodName,mcover_coverage_data_Method) , mcover_coverage_data_Method);
		method.addStatement(block);
		block.lookup = [packg.id,file.id,clazz.id,method.id,block.id];
		var _this = this.statements;
		var key = block.id;
		var value = block.lookup.concat([]);
		_this.h[key] = value;
	}
	,addBranch: function(block) {
		this.verifyBlockData(block);
		if(this.branches.h.hasOwnProperty(block.id)) {
			throw new js__$Boot_HaxeError(new mcover_Exception("Branch already exists: " + block.id + " " + block.toString(),null,{ fileName : "Coverage.hx", lineNumber : 94, className : "mcover.coverage.data.Coverage", methodName : "addBranch"}));
		}
		var packg = js_Boot.__cast(this.getItemByName(block.packageName,mcover_coverage_data_Package) , mcover_coverage_data_Package);
		var file = js_Boot.__cast(packg.getItemByName(block.file,mcover_coverage_data_File) , mcover_coverage_data_File);
		var clazz = js_Boot.__cast(file.getItemByName(block.qualifiedClassName,mcover_coverage_data_Clazz) , mcover_coverage_data_Clazz);
		var method = js_Boot.__cast(clazz.getItemByName(block.methodName,mcover_coverage_data_Method) , mcover_coverage_data_Method);
		method.addBranch(block);
		block.lookup = [packg.id,file.id,clazz.id,method.id,block.id];
		var _this = this.branches;
		var key = block.id;
		var value = block.lookup.concat([]);
		_this.h[key] = value;
	}
	,verifyBlockData: function(block) {
		if(block.id == null) {
			throw new js__$Boot_HaxeError(new mcover_Exception("id cannot be null",null,{ fileName : "Coverage.hx", lineNumber : 109, className : "mcover.coverage.data.Coverage", methodName : "verifyBlockData"}));
		}
		if(block.packageName == null) {
			throw new js__$Boot_HaxeError(new mcover_Exception("packageName cannot be null",null,{ fileName : "Coverage.hx", lineNumber : 110, className : "mcover.coverage.data.Coverage", methodName : "verifyBlockData"}));
		}
		if(block.file == null) {
			throw new js__$Boot_HaxeError(new mcover_Exception("file cannot be null",null,{ fileName : "Coverage.hx", lineNumber : 111, className : "mcover.coverage.data.Coverage", methodName : "verifyBlockData"}));
		}
		if(block.qualifiedClassName == null) {
			throw new js__$Boot_HaxeError(new mcover_Exception("qualifiedClassName cannot be null",null,{ fileName : "Coverage.hx", lineNumber : 112, className : "mcover.coverage.data.Coverage", methodName : "verifyBlockData"}));
		}
		if(block.methodName == null) {
			throw new js__$Boot_HaxeError(new mcover_Exception("methodName cannot be null",null,{ fileName : "Coverage.hx", lineNumber : 113, className : "mcover.coverage.data.Coverage", methodName : "verifyBlockData"}));
		}
	}
	,getBranchById: function(id) {
		if(!this.branches.h.hasOwnProperty(id)) {
			throw new js__$Boot_HaxeError(new mcover_Exception("Branch does not exist: " + id,null,{ fileName : "Coverage.hx", lineNumber : 118, className : "mcover.coverage.data.Coverage", methodName : "getBranchById"}));
		}
		var lookup = this.branches.h[id].concat([]);
		return this.lookupBranch(lookup);
	}
	,getStatementById: function(id) {
		if(!this.statements.h.hasOwnProperty(id)) {
			throw new js__$Boot_HaxeError(new mcover_Exception("Statement does not exist: " + id,null,{ fileName : "Coverage.hx", lineNumber : 127, className : "mcover.coverage.data.Coverage", methodName : "getStatementById"}));
		}
		var lookup = this.statements.h[id].concat([]);
		return this.lookupStatement(lookup);
	}
	,getMissingBranches: function() {
		var a = mcover_coverage_data_AbstractNodeList.prototype.getMissingBranches.call(this);
		a.sort(mcover_coverage_data_DataUtil.sortOnBlockName);
		return a;
	}
	,getMissingStatements: function() {
		var a = mcover_coverage_data_AbstractNodeList.prototype.getMissingStatements.call(this);
		a.sort(mcover_coverage_data_DataUtil.sortOnBlockName);
		return a;
	}
	,getClasses: function() {
		var a = mcover_coverage_data_AbstractNodeList.prototype.getClasses.call(this);
		a.sort(mcover_coverage_data_DataUtil.sortOnNodeName);
		return a;
	}
	,getClassByName: function(name) {
		var index = name.lastIndexOf(".");
		var packageName = index > 1 ? HxOverrides.substr(name,0,index) : "";
		var _this = this.items;
		if(!(__map_reserved[packageName] != null ? _this.existsReserved(packageName) : _this.h.hasOwnProperty(packageName))) {
			return null;
		}
		var _this1 = this.items;
		var pckgId = __map_reserved[packageName] != null ? _this1.getReserved(packageName) : _this1.h[packageName];
		var pckg = js_Boot.__cast(this.itemsById.h[pckgId] , mcover_coverage_data_Package);
		var classes = pckg.getClasses();
		var _g = 0;
		while(_g < classes.length) {
			var cls = classes[_g];
			++_g;
			if(cls.name == name) {
				return cls;
			}
		}
		return null;
	}
	,getPackages: function() {
		var a = [];
		var item = this.itemsById.iterator();
		while(item.hasNext()) {
			var item1 = item.next();
			a.push(js_Boot.__cast(item1 , mcover_coverage_data_Package));
		}
		a.sort(mcover_coverage_data_DataUtil.sortOnNodeName);
		return a;
	}
	,getResults: function(cache) {
		if(cache == null) {
			cache = true;
		}
		if(this.resultCache == null || !cache) {
			var lookup = this.statements.iterator();
			while(lookup.hasNext()) {
				var lookup1 = lookup.next();
				var statement = this.lookupStatement(lookup1.concat([]));
				if(this.statementResultsById.h.hasOwnProperty(statement.id)) {
					statement.count = this.statementResultsById.h[statement.id];
				} else {
					statement.count = 0;
				}
			}
			var lookup2 = this.branches.iterator();
			while(lookup2.hasNext()) {
				var lookup3 = lookup2.next();
				var branch = this.lookupBranch(lookup3.concat([]));
				if(this.branchResultsById.h.hasOwnProperty(branch.id)) {
					var result = this.branchResultsById.h[branch.id];
					branch.trueCount = result.trueCount;
					branch.falseCount = result.falseCount;
				} else {
					branch.trueCount = 0;
					branch.falseCount = 0;
				}
			}
			mcover_coverage_data_AbstractNodeList.prototype.getResults.call(this,cache);
		}
		return this.resultCache;
	}
	,appendResults: function(to,from) {
		to = mcover_coverage_data_AbstractNodeList.prototype.appendResults.call(this,to,from);
		to.pc += from.sc > 0 ? 1 : 0;
		to.p += 1;
		return to;
	}
	,hxSerialize: function(s) {
		mcover_coverage_data_AbstractNodeList.prototype.hxSerialize.call(this,s);
		s.serialize(this.statements);
		s.serialize(this.branches);
		s.serialize(this.statementResultsById);
		s.serialize(this.branchResultsById);
	}
	,hxUnserialize: function(s) {
		mcover_coverage_data_AbstractNodeList.prototype.hxUnserialize.call(this,s);
		this.statements = s.unserialize();
		this.branches = s.unserialize();
		this.statementResultsById = s.unserialize();
		this.branchResultsById = s.unserialize();
	}
	,__class__: mcover_coverage_data_Coverage
});
var mcover_coverage_data_DataUtil = function() {
};
$hxClasses["mcover.coverage.data.DataUtil"] = mcover_coverage_data_DataUtil;
mcover_coverage_data_DataUtil.__name__ = ["mcover","coverage","data","DataUtil"];
mcover_coverage_data_DataUtil.sortOnNodeId = function(a,b) {
	return a.id - b.id;
};
mcover_coverage_data_DataUtil.sortOnNodeName = function(a,b) {
	var nodeA = a.name.toLowerCase();
	var nodeB = b.name.toLowerCase();
	if(nodeA < nodeB) {
		return -1;
	}
	if(nodeA > nodeB) {
		return 1;
	}
	return 0;
};
mcover_coverage_data_DataUtil.sortOnBlockName = function(a,b) {
	var blockA = a.toString().toLowerCase();
	var blockB = b.toString().toLowerCase();
	if(blockA < blockB) {
		return -1;
	}
	if(blockA > blockB) {
		return 1;
	}
	return 0;
};
mcover_coverage_data_DataUtil.prototype = {
	__class__: mcover_coverage_data_DataUtil
};
var mcover_coverage_data_File = function() {
	mcover_coverage_data_AbstractNodeList.call(this);
};
$hxClasses["mcover.coverage.data.File"] = mcover_coverage_data_File;
mcover_coverage_data_File.__name__ = ["mcover","coverage","data","File"];
mcover_coverage_data_File.__super__ = mcover_coverage_data_AbstractNodeList;
mcover_coverage_data_File.prototype = $extend(mcover_coverage_data_AbstractNodeList.prototype,{
	getClasses: function() {
		var a = [];
		var item = this.itemsById.iterator();
		while(item.hasNext()) {
			var item1 = item.next();
			if((item1 == null ? null : js_Boot.getClass(item1)) == mcover_coverage_data_Clazz) {
				a.push(js_Boot.__cast(item1 , mcover_coverage_data_Clazz));
			}
		}
		return a;
	}
	,appendResults: function(to,from) {
		to = mcover_coverage_data_AbstractNodeList.prototype.appendResults.call(this,to,from);
		to.cc += from.sc > 0 ? 1 : 0;
		to.c += 1;
		return to;
	}
	,__class__: mcover_coverage_data_File
});
var mcover_coverage_data_Method = function() {
	mcover_coverage_data_AbstractNode.call(this);
	this.statementsById = new haxe_ds_IntMap();
	this.branchesById = new haxe_ds_IntMap();
};
$hxClasses["mcover.coverage.data.Method"] = mcover_coverage_data_Method;
mcover_coverage_data_Method.__name__ = ["mcover","coverage","data","Method"];
mcover_coverage_data_Method.__super__ = mcover_coverage_data_AbstractNode;
mcover_coverage_data_Method.prototype = $extend(mcover_coverage_data_AbstractNode.prototype,{
	addStatement: function(value) {
		this.statementsById.h[value.id] = value;
	}
	,addBranch: function(value) {
		this.branchesById.h[value.id] = value;
	}
	,getStatementById: function(id) {
		if(this.statementsById.h.hasOwnProperty(id)) {
			return this.statementsById.h[id];
		}
		return null;
	}
	,getBranchById: function(id) {
		if(this.branchesById.h.hasOwnProperty(id)) {
			return this.branchesById.h[id];
		}
		return null;
	}
	,lookupBranch: function(path) {
		var itemId = path.shift();
		if(itemId == null || !this.branchesById.h.hasOwnProperty(itemId)) {
			return null;
		}
		return this.branchesById.h[itemId];
	}
	,lookupStatement: function(path) {
		var itemId = path.shift();
		if(itemId == null || !this.statementsById.h.hasOwnProperty(itemId)) {
			return null;
		}
		return this.statementsById.h[itemId];
	}
	,getMissingBranches: function() {
		var a = [];
		var branch = this.branchesById.iterator();
		while(branch.hasNext()) {
			var branch1 = branch.next();
			if(!branch1.isCovered()) {
				a.push(branch1);
			}
		}
		return a;
	}
	,getMissingStatements: function() {
		var a = [];
		var statement = this.statementsById.iterator();
		while(statement.hasNext()) {
			var statement1 = statement.next();
			if(!statement1.isCovered()) {
				a.push(statement1);
			}
		}
		return a;
	}
	,getResults: function(cache) {
		if(cache == null) {
			cache = true;
		}
		if(this.resultCache == null || !cache) {
			this.resultCache = this.emptyResult();
			var covered;
			var statement = this.statementsById.iterator();
			while(statement.hasNext()) {
				var statement1 = statement.next();
				covered = statement1.count > 0;
				this.resultCache.sc += covered ? 1 : 0;
				this.resultCache.s += 1;
				var _g = 0;
				var _g1 = statement1.lines;
				while(_g < _g1.length) {
					var line = _g1[_g];
					++_g;
					this.resultCache.lc += covered ? 1 : 0;
					this.resultCache.l += 1;
				}
			}
			var branch = this.branchesById.iterator();
			while(branch.hasNext()) {
				var branch1 = branch.next();
				covered = branch1.isCovered();
				this.resultCache.bt += branch1.trueCount > 0 ? 1 : 0;
				this.resultCache.bf += branch1.falseCount > 0 ? 1 : 0;
				this.resultCache.bc += covered ? 1 : 0;
				this.resultCache.b += 1;
				var partiallyCovered = branch1.isPartiallyCovered();
				var _g2 = 0;
				var _g11 = branch1.lines;
				while(_g2 < _g11.length) {
					var line1 = _g11[_g2];
					++_g2;
					if(covered) {
						this.resultCache.lc += 1;
					} else if(partiallyCovered) {
						this.resultCache.lp += 1;
					}
					this.resultCache.l += 1;
				}
			}
		}
		return this.resultCache;
	}
	,hxSerialize: function(s) {
		mcover_coverage_data_AbstractNode.prototype.hxSerialize.call(this,s);
		s.serialize(this.statementsById);
		s.serialize(this.branchesById);
	}
	,hxUnserialize: function(s) {
		mcover_coverage_data_AbstractNode.prototype.hxUnserialize.call(this,s);
		this.statementsById = s.unserialize();
		this.branchesById = s.unserialize();
	}
	,__class__: mcover_coverage_data_Method
});
var mcover_coverage_data_Package = function() {
	mcover_coverage_data_AbstractNodeList.call(this);
};
$hxClasses["mcover.coverage.data.Package"] = mcover_coverage_data_Package;
mcover_coverage_data_Package.__name__ = ["mcover","coverage","data","Package"];
mcover_coverage_data_Package.__super__ = mcover_coverage_data_AbstractNodeList;
mcover_coverage_data_Package.prototype = $extend(mcover_coverage_data_AbstractNodeList.prototype,{
	getFiles: function() {
		var a = [];
		var item = this.itemsById.iterator();
		while(item.hasNext()) {
			var item1 = item.next();
			if((item1 == null ? null : js_Boot.getClass(item1)) == mcover_coverage_data_File) {
				a.push(js_Boot.__cast(item1 , mcover_coverage_data_File));
			}
		}
		return a;
	}
	,appendResults: function(to,from) {
		to = mcover_coverage_data_AbstractNodeList.prototype.appendResults.call(this,to,from);
		to.fc += from.sc > 0 ? 1 : 0;
		to.f += 1;
		return to;
	}
	,__class__: mcover_coverage_data_Package
});
var mcover_coverage_data_Statement = function() {
	mcover_coverage_data_AbstractBlock.call(this);
	this.count = 0;
};
$hxClasses["mcover.coverage.data.Statement"] = mcover_coverage_data_Statement;
mcover_coverage_data_Statement.__name__ = ["mcover","coverage","data","Statement"];
mcover_coverage_data_Statement.__super__ = mcover_coverage_data_AbstractBlock;
mcover_coverage_data_Statement.prototype = $extend(mcover_coverage_data_AbstractBlock.prototype,{
	isCovered: function() {
		return this.count > 0;
	}
	,hxSerialize: function(s) {
		mcover_coverage_data_AbstractBlock.prototype.hxSerialize.call(this,s);
		s.serialize(this.count);
	}
	,hxUnserialize: function(s) {
		mcover_coverage_data_AbstractBlock.prototype.hxUnserialize.call(this,s);
		this.count = s.unserialize();
	}
	,__class__: mcover_coverage_data_Statement
});
var mcover_coverage_munit_client_MCoverPrintClient = function(munitClient,mcoverClient,mcoverLogger) {
	this.id = "MCoverPrintClient";
	if(munitClient == null) {
		munitClient = new massive_munit_client_RichPrintClient();
	}
	this.client = munitClient;
	if(mcoverClient == null) {
		mcoverClient = new mcover_coverage_client_PrintClient();
	}
	this.mcoverClient = mcoverClient;
	if(mcoverLogger == null) {
		mcoverLogger = this.initializeMCoverLogger();
	}
	this.mcoverLogger = mcoverLogger;
	this.init();
};
$hxClasses["mcover.coverage.munit.client.MCoverPrintClient"] = mcover_coverage_munit_client_MCoverPrintClient;
mcover_coverage_munit_client_MCoverPrintClient.__name__ = ["mcover","coverage","munit","client","MCoverPrintClient"];
mcover_coverage_munit_client_MCoverPrintClient.__interfaces__ = [massive_munit_IAdvancedTestResultClient];
mcover_coverage_munit_client_MCoverPrintClient.prototype = {
	get_completionHandler: function() {
		return this.completionHandler;
	}
	,set_completionHandler: function(value) {
		return this.completionHandler = value;
	}
	,addPass: function(result) {
		this.client.addPass(result);
	}
	,addFail: function(result) {
		this.client.addFail(result);
	}
	,addError: function(result) {
		this.client.addError(result);
	}
	,addIgnore: function(result) {
		this.client.addIgnore(result);
	}
	,initializeMCoverLogger: function() {
		try {
			return mcover_coverage_MCoverage.getLogger();
		} catch( e ) {
			haxe_CallStack.lastException = e;
			if (e instanceof js__$Boot_HaxeError) e = e.val;
			var msg = "ERROR: Unable to initialize MCover Logger\n" + Std.string(e);
			haxe_Log.trace(msg,{ fileName : "MCoverPrintClient.hx", lineNumber : 172, className : "mcover.coverage.munit.client.MCoverPrintClient", methodName : "initializeMCoverLogger"});
		}
		return null;
	}
	,init: function() {
		var VERBOSE = js_Boot.__instanceof(this.client,massive_munit_client_RichPrintClient);
		this.includeMissingBlocks = VERBOSE;
		this.includeExecutionFrequency = VERBOSE;
		this.includeClassAndPackageBreakdowns = VERBOSE;
		this.currentCoveredClass = null;
		this.classPercentage = 0;
		this.coveredClasses = new haxe_ds_StringMap();
		this.mcoverClient.includeMissingBlocks = this.includeMissingBlocks;
		this.mcoverClient.includeExecutionFrequency = this.includeExecutionFrequency;
		this.mcoverLogger.addClient(this.mcoverClient);
	}
	,setCurrentTestClass: function(className) {
		var hasMatch = className != null && className.lastIndexOf("Test") == className.length - 4;
		var coveredClassName = hasMatch ? HxOverrides.substr(className,0,className.length - 4) : null;
		var hasChanged = this.currentCoveredClass != coveredClassName;
		if(hasChanged && this.currentCoveredClass != null) {
			if(this.mcoverLogger.currentTest != null) {
				this.updateTestClassCoverage();
			}
		}
		this.client.setCurrentTestClass(className);
		if(hasChanged) {
			this.currentCoveredClass = coveredClassName;
			this.mcoverLogger.set_currentTest(this.currentCoveredClass);
		}
	}
	,reportFinalStatistics: function(testCount,passCount,failCount,errorCount,ignoreCount,time) {
		this.updateFinalCoverageReport();
		var result = this.client.reportFinalStatistics(testCount,passCount,failCount,errorCount,ignoreCount,time);
		if(this.get_completionHandler() != null) {
			(this.get_completionHandler())(this);
		}
		return result;
	}
	,updateTestClassCoverage: function() {
		this.mcoverLogger.reportCurrentTest(true);
		var cls = this.mcoverLogger.coverage.getClassByName(this.currentCoveredClass);
		if(cls == null) {
			return;
		}
		var _this = this.coveredClasses;
		var key = cls.name;
		if(__map_reserved[key] != null) {
			_this.setReserved(key,cls);
		} else {
			_this.h[key] = cls;
		}
		this.classPercentage = cls.getPercentage();
		var coverageResult = this.createCoverageResultForClass(cls);
		this.client.setCurrentTestClassCoverage(coverageResult);
	}
	,updateFinalCoverageReport: function() {
		this.mcoverLogger.report(false);
		var percent = this.mcoverLogger.coverage.getPercentage();
		var coverageResults = null;
		var executionFrequencies = null;
		var classBreakdown = null;
		var packageBreakdown = null;
		if(this.includeMissingBlocks) {
			coverageResults = this.createOutstandingCoverageResults();
		}
		if(this.includeClassAndPackageBreakdowns) {
			classBreakdown = this.mcoverClient.classBreakdown;
			packageBreakdown = this.mcoverClient.packageBreakdown;
		}
		if(this.includeExecutionFrequency) {
			executionFrequencies = this.mcoverClient.executionFrequency;
		}
		var summary = this.mcoverClient.summary + "\n" + this.mcoverClient.overallPercentage;
		this.client.reportFinalCoverage(percent,coverageResults,summary,classBreakdown,packageBreakdown,executionFrequencies);
	}
	,createOutstandingCoverageResults: function() {
		var classes = this.mcoverLogger.coverage.getClasses();
		var results = [];
		var _g = 0;
		while(_g < classes.length) {
			var cls = classes[_g];
			++_g;
			if(cls.getPercentage() == 100) {
				continue;
			}
			var result = this.createCoverageResultForClass(cls);
			results.push(result);
		}
		return results;
	}
	,createCoverageResultForClass: function(cls) {
		var percent = cls.getPercentage();
		var blocks = [];
		if(percent != 100 && this.includeMissingBlocks) {
			var str = "";
			var statements = cls.getMissingStatements();
			if(statements.length > 0) {
				var _g = 0;
				while(_g < statements.length) {
					var block = statements[_g];
					++_g;
					var blockString = block.methodName + " (" + block.location + ")";
					if(str != "") {
						str += "\n";
					}
					str += blockString;
				}
				blocks.push(str);
			}
			var branches = cls.getMissingBranches();
			if(branches.length > 0) {
				str = "";
				var _g1 = 0;
				while(_g1 < branches.length) {
					var block1 = branches[_g1];
					++_g1;
					var blockString1 = block1.methodName + " (" + block1.location + ")";
					if(!block1.isCovered()) {
						blockString1 += " ";
						if(block1.trueCount == 0) {
							blockString1 += "t";
						}
						if(block1.trueCount == 0 && block1.falseCount == 0) {
							blockString1 += ",";
						}
						if(block1.falseCount == 0) {
							blockString1 += "f";
						}
					}
					if(str != "") {
						str += "\n";
					}
					str += blockString1;
				}
				blocks.push(str);
			}
		}
		return { className : cls.name, percent : percent, blocks : blocks};
	}
	,__class__: mcover_coverage_munit_client_MCoverPrintClient
};
var mcover_coverage_munit_client_MCoverSummaryReportClient = function() {
	massive_munit_client_SummaryReportClient.call(this);
	this.initializeLogger();
};
$hxClasses["mcover.coverage.munit.client.MCoverSummaryReportClient"] = mcover_coverage_munit_client_MCoverSummaryReportClient;
mcover_coverage_munit_client_MCoverSummaryReportClient.__name__ = ["mcover","coverage","munit","client","MCoverSummaryReportClient"];
mcover_coverage_munit_client_MCoverSummaryReportClient.__super__ = massive_munit_client_SummaryReportClient;
mcover_coverage_munit_client_MCoverSummaryReportClient.prototype = $extend(massive_munit_client_SummaryReportClient.prototype,{
	initializeLogger: function() {
		try {
			this.mcoverLogger = mcover_coverage_MCoverage.getLogger();
		} catch( e ) {
			haxe_CallStack.lastException = e;
			if (e instanceof js__$Boot_HaxeError) e = e.val;
			var msg = "ERROR: Unable to initialize MCover Logger\n" + Std.string(e);
			haxe_Log.trace(msg,{ fileName : "MCoverSummaryReportClient.hx", lineNumber : 76, className : "mcover.coverage.munit.client.MCoverSummaryReportClient", methodName : "initializeLogger"});
		}
		return null;
	}
	,printFinalStatistics: function(result,testCount,passCount,failCount,errorCount,ignoreCount,time) {
		massive_munit_client_SummaryReportClient.prototype.printFinalStatistics.call(this,result,testCount,passCount,failCount,errorCount,ignoreCount,time);
		this.mcoverLogger.report(false);
		this.coverage = this.mcoverLogger.coverage;
		this.output += "\n#coverage:percent,count/total";
		this.output += "\ncoverage:" + this.coverage.getPercentage() + "%";
		var r = this.coverage.getResults();
		this.output += "\n" + this.appendResult("packages",r.pc,r.p);
		this.output += "\n" + this.appendResult("files",r.fc,r.f);
		this.output += "\n" + this.appendResult("classes",r.cc,r.c);
		this.output += "\n" + this.appendResult("methods",r.mc,r.m);
		this.output += "\n" + this.appendResult("statements",r.sc,r.s);
		this.output += "\n" + this.appendResult("branches",r.bc,r.b);
		this.output += "\n" + this.appendResult("lines",r.lc,r.l);
		this.output += "\n";
	}
	,appendResult: function(name,count,total) {
		var percent = count == 0 ? 0 : mcover_util_NumberUtil.round(count / total * 100,2);
		return name + ":" + percent + "%," + count + "/" + total;
	}
	,__class__: mcover_coverage_munit_client_MCoverSummaryReportClient
});
var mcover_util_NumberUtil = function() { };
$hxClasses["mcover.util.NumberUtil"] = mcover_util_NumberUtil;
mcover_util_NumberUtil.__name__ = ["mcover","util","NumberUtil"];
mcover_util_NumberUtil.round = function(value,precision) {
	if(precision == null) {
		precision = 4;
	}
	value *= Math.pow(10,precision);
	return Math.round(value) / Math.pow(10,precision);
};
var mcover_util_Timer = $hx_exports["mcover"]["util"]["Timer"] = function(time_ms) {
	this.run = $bind(this,this.defaultRun);
	this.id = mcover_util_Timer.arr.length;
	mcover_util_Timer.arr[this.id] = this;
	this.timerId = window.setInterval("mcover.util.Timer.arr[" + this.id + "].run();",time_ms);
};
$hxClasses["mcover.util.Timer"] = mcover_util_Timer;
mcover_util_Timer.__name__ = ["mcover","util","Timer"];
mcover_util_Timer.delay = function(f,time_ms) {
	var t = new mcover_util_Timer(time_ms);
	t.run = function() {
		t.stop();
		f();
	};
	return t;
};
mcover_util_Timer.stamp = function() {
	return new Date().getTime() / 1000;
};
mcover_util_Timer.inlineStamp = function() {
	return new Date().getTime() / 1000;
};
mcover_util_Timer.prototype = {
	defaultRun: function() {
	}
	,stop: function() {
		if(this.id == null) {
			return;
		}
		window.clearInterval(this.timerId);
		mcover_util_Timer.arr[this.id] = null;
		if(this.id > 100 && this.id == mcover_util_Timer.arr.length - 1) {
			var p = this.id - 1;
			while(p >= 0 && mcover_util_Timer.arr[p] == null) --p;
			mcover_util_Timer.arr = mcover_util_Timer.arr.slice(0,p + 1);
		}
		this.id = null;
	}
	,__class__: mcover_util_Timer
};
var org_hamcrest_Exception = function(message,cause,info) {
	if(message == null) {
		message = "";
	}
	this.name = Type.getClassName(js_Boot.getClass(this));
	this.message = message;
	this.cause = cause;
	this.info = info;
};
$hxClasses["org.hamcrest.Exception"] = org_hamcrest_Exception;
org_hamcrest_Exception.__name__ = ["org","hamcrest","Exception"];
org_hamcrest_Exception.prototype = {
	get_name: function() {
		return this.name;
	}
	,get_message: function() {
		return this.message;
	}
	,get_cause: function() {
		return this.cause;
	}
	,toString: function() {
		var str = this.get_name() + ": " + this.get_message();
		if(this.info != null) {
			str += " at " + this.info.className + "#" + this.info.methodName + " (" + this.info.lineNumber + ")";
		}
		if(this.get_cause() != null) {
			str += "\n\t Caused by: " + Std.string(this.get_cause());
		}
		return str;
	}
	,__class__: org_hamcrest_Exception
};
var org_hamcrest_AssertionException = function(message,cause,info) {
	if(message == null) {
		message = "";
	}
	org_hamcrest_Exception.call(this,message,cause,info);
};
$hxClasses["org.hamcrest.AssertionException"] = org_hamcrest_AssertionException;
org_hamcrest_AssertionException.__name__ = ["org","hamcrest","AssertionException"];
org_hamcrest_AssertionException.__super__ = org_hamcrest_Exception;
org_hamcrest_AssertionException.prototype = $extend(org_hamcrest_Exception.prototype,{
	__class__: org_hamcrest_AssertionException
});
var org_hamcrest_IllegalArgumentException = function(message,cause,info) {
	if(message == null) {
		message = "Argument could not be processed.";
	}
	org_hamcrest_Exception.call(this,message,cause,info);
};
$hxClasses["org.hamcrest.IllegalArgumentException"] = org_hamcrest_IllegalArgumentException;
org_hamcrest_IllegalArgumentException.__name__ = ["org","hamcrest","IllegalArgumentException"];
org_hamcrest_IllegalArgumentException.__super__ = org_hamcrest_Exception;
org_hamcrest_IllegalArgumentException.prototype = $extend(org_hamcrest_Exception.prototype,{
	__class__: org_hamcrest_IllegalArgumentException
});
var org_hamcrest_MissingImplementationException = function(message,cause,info) {
	if(message == null) {
		message = "Abstract method not overridden.";
	}
	org_hamcrest_Exception.call(this,message,cause,info);
};
$hxClasses["org.hamcrest.MissingImplementationException"] = org_hamcrest_MissingImplementationException;
org_hamcrest_MissingImplementationException.__name__ = ["org","hamcrest","MissingImplementationException"];
org_hamcrest_MissingImplementationException.__super__ = org_hamcrest_Exception;
org_hamcrest_MissingImplementationException.prototype = $extend(org_hamcrest_Exception.prototype,{
	__class__: org_hamcrest_MissingImplementationException
});
var org_hamcrest_UnsupportedOperationException = function(message,cause,info) {
	if(message == null) {
		message = "";
	}
	org_hamcrest_Exception.call(this,message,cause,info);
};
$hxClasses["org.hamcrest.UnsupportedOperationException"] = org_hamcrest_UnsupportedOperationException;
org_hamcrest_UnsupportedOperationException.__name__ = ["org","hamcrest","UnsupportedOperationException"];
org_hamcrest_UnsupportedOperationException.__super__ = org_hamcrest_Exception;
org_hamcrest_UnsupportedOperationException.prototype = $extend(org_hamcrest_Exception.prototype,{
	__class__: org_hamcrest_UnsupportedOperationException
});
function $iterator(o) { if( o instanceof Array ) return function() { return HxOverrides.iter(o); }; return typeof(o.iterator) == 'function' ? $bind(o,o.iterator) : o.iterator; }
var $_, $fid = 0;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $fid++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = function(){ return f.method.apply(f.scope, arguments); }; f.scope = o; f.method = m; o.hx__closures__[m.__id__] = f; } return f; }
$hxClasses["Math"] = Math;
String.prototype.__class__ = $hxClasses["String"] = String;
String.__name__ = ["String"];
$hxClasses["Array"] = Array;
Array.__name__ = ["Array"];
Date.prototype.__class__ = $hxClasses["Date"] = Date;
Date.__name__ = ["Date"];
var Int = $hxClasses["Int"] = { __name__ : ["Int"]};
var Dynamic = $hxClasses["Dynamic"] = { __name__ : ["Dynamic"]};
var Float = $hxClasses["Float"] = Number;
Float.__name__ = ["Float"];
var Bool = $hxClasses["Bool"] = Boolean;
Bool.__ename__ = ["Bool"];
var Class = $hxClasses["Class"] = { __name__ : ["Class"]};
var Enum = { };
haxe_Resource.content = [{ name : "MCoverData", data : "Q3kyOTptY292ZXIuY292ZXJhZ2UuZGF0YS5Db3ZlcmFnZW5ucTowQ3kyODptY292ZXIuY292ZXJhZ2UuZGF0YS5QYWNrYWdlenkyMDppb2Rldi5nZW9tMi5pbnRlcnNlY3E6MEN5MjU6bWNvdmVyLmNvdmVyYWdlLmRhdGEuRmlsZXp5NDQ6aW9kZXYlNUNnZW9tMiU1Q2ludGVyc2VjJTVDQ2lyY2xlSW50ZXJzZWMuaHhxOjBDeTI2Om1jb3Zlci5jb3ZlcmFnZS5kYXRhLkNsYXp6enkzNTppb2Rldi5nZW9tMi5pbnRlcnNlYy5DaXJjbGVJbnRlcnNlY3E6MEN5Mjc6bWNvdmVyLmNvdmVyYWdlLmRhdGEuTWV0aG9kenkxMDpjaXJjbGVMaW5lcTowQ3kzMDptY292ZXIuY292ZXJhZ2UuZGF0YS5TdGF0ZW1lbnR6blI0UjJ5MTQ6Q2lyY2xlSW50ZXJzZWNSNlI4aTM3NWk0NDZ5MTIxOnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNpbnRlcnNlYyU1Q0NpcmNsZUludGVyc2VjLmh4JTNBMTQlM0ElMjBjaGFycyUyMDItNzNhenp6enpoYWktMXppMWkyaTNpNGk1aTZpN2k4aTlpMTBpMTFpMTJpMTNpMTRpMTVpMTZpMTdoemdocWhnOjRDUjdpNHkxMDpjaXJjbGVTZWdtcTo0Q1I5aTRuUjRSMlIxMFI2UjEyaTE2ODlpMTc2MHkxMjE6eiUzQSU1Q3Byb2plY3RzJTVDaW9kZXYlNUNnaXRodWIlNUNoYXhlLWdlb20yJTVDc3JjJTVDaW9kZXYlNUNnZW9tMiU1Q2ludGVyc2VjJTVDQ2lyY2xlSW50ZXJzZWMuaHglM0E0NCUzQSUyMGNoYXJzJTIwMi03M2F6enppNGk0aGFpNDBpNDFpNDJpNDNpNDRpNDVpNDZpNDdoemdocWhnOjNDUjdpM3kxMTpjaXJjbGVSYXlUb3E6M0NSOWkzblI0UjJSMTBSNlIxNGkxNDIyaTE0MzR5MTIxOnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNpbnRlcnNlYyU1Q0NpcmNsZUludGVyc2VjLmh4JTNBMzclM0ElMjBjaGFycyUyMDItMTRhenp6aTNpM2hhaTMzaTM0aTM1aTM2aTM3aTM4aTM5aHpnaHFoZzoxQ1I3aTF5MTI6Y2lyY2xlTGluZVRvcToxQ1I5aTFuUjRSMlIxMFI2UjE2aTc2Nmk3Nzh5MTIxOnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNpbnRlcnNlYyU1Q0NpcmNsZUludGVyc2VjLmh4JTNBMjIlM0ElMjBjaGFycyUyMDItMTRhenp6aTFpMWhhaTE4aTE5aTIwaTIxaTIyaTIzaTI0aHpnaHFoZzoyQ1I3aTJ5OTpjaXJjbGVSYXlxOjJDUjlpMm5SNFIyUjEwUjZSMThpMTAzM2kxMTA0eTEyMTp6JTNBJTVDcHJvamVjdHMlNUNpb2RldiU1Q2dpdGh1YiU1Q2hheGUtZ2VvbTIlNUNzcmMlNUNpb2RldiU1Q2dlb20yJTVDaW50ZXJzZWMlNUNDaXJjbGVJbnRlcnNlYy5oeCUzQTI5JTNBJTIwY2hhcnMlMjAyLTczYXp6emkyaTJoYWkyNWkyNmkyN2kyOGkyOWkzMGkzMWkzMmh6Z2hxaGc6NUNSN2k1eTEyOmNpcmNsZVNlZ21Ub3E6NUNSOWk1blI0UjJSMTBSNlIyMGkyMDgwaTIwOTJ5MTIxOnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNpbnRlcnNlYyU1Q0NpcmNsZUludGVyc2VjLmh4JTNBNTIlM0ElMjBjaGFycyUyMDItMTRhenp6aTVpNWhhaTQ4aTQ5aTUwaTUxaTUyaTUzaTU0aHpnaHFoZ2hiUjE4aTJSMTJpNFIxNGkzUjh6UjIwaTVSMTZpMWhpNmdoYlI2emhpMWc6MUNSM2kxeTQyOmlvZGV2JTVDZ2VvbTIlNUNpbnRlcnNlYyU1Q0xpbmVJbnRlcnNlYy5oeHE6MENSNXp5MzM6aW9kZXYuZ2VvbTIuaW50ZXJzZWMuTGluZUludGVyc2VjcToxMENSN2kxMHk4OnNlZ21TZWdtcTo3OENSOWk3OG5SMjJSMnkxMjpMaW5lSW50ZXJzZWNSMjNSMjRpMzI4NmkzMzEyeTExOTp6JTNBJTVDcHJvamVjdHMlNUNpb2RldiU1Q2dpdGh1YiU1Q2hheGUtZ2VvbTIlNUNzcmMlNUNpb2RldiU1Q2dlb20yJTVDaW50ZXJzZWMlNUNMaW5lSW50ZXJzZWMuaHglM0E5NiUzQSUyMGNoYXJzJTIwMy0yOWF6aTF6aTEwaTc4aGFpODlpOTBpOTFpOTJpOTNpOTRpOTVpOTZoemc6NzlDUjlpNzluUjIyUjJSMjVSMjNSMjRpMzEwOGkzMTQ4eTExOTp6JTNBJTVDcHJvamVjdHMlNUNpb2RldiU1Q2dpdGh1YiU1Q2hheGUtZ2VvbTIlNUNzcmMlNUNpb2RldiU1Q2dlb20yJTVDaW50ZXJzZWMlNUNMaW5lSW50ZXJzZWMuaHglM0E5MyUzQSUyMGNoYXJzJTIwMi00MmF6aTF6aTEwaTc5aGFpOTdpOThoemdocTo0Q3kyNzptY292ZXIuY292ZXJhZ2UuZGF0YS5CcmFuY2hpNG5SMjJSMlIyNVIyM1IyNGkzMjcyaTMyNzh5MTE5OnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNpbnRlcnNlYyU1Q0xpbmVJbnRlcnNlYy5oeCUzQTk1JTNBJTIwY2hhcnMlMjA2LTEyYXppMXppMTBpNGhhaHp6Z2hnOjZDUjdpNnk2OnJheVJheXE6NzNDUjlpNzNuUjIyUjJSMjVSMjNSMzBpMTk1MGkxOTkweTExOTp6JTNBJTVDcHJvamVjdHMlNUNpb2RldiU1Q2dpdGh1YiU1Q2hheGUtZ2VvbTIlNUNzcmMlNUNpb2RldiU1Q2dlb20yJTVDaW50ZXJzZWMlNUNMaW5lSW50ZXJzZWMuaHglM0E1OSUzQSUyMGNoYXJzJTIwMi00MmF6aTF6aTZpNzNoYWk2M2k2NGh6Zzo3MkNSOWk3Mm5SMjJSMlIyNVIyM1IzMGkyMTI2aTIxNTJ5MTE5OnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNpbnRlcnNlYyU1Q0xpbmVJbnRlcnNlYy5oeCUzQTYyJTNBJTIwY2hhcnMlMjAzLTI5YXppMXppNmk3MmhhaTU1aTU2aTU3aTU4aTU5aTYwaTYxaTYyaHpnaHE6MkNSMjhpMm5SMjJSMlIyNVIyM1IzMGkyMTEyaTIxMTh5MTE5OnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNpbnRlcnNlYyU1Q0xpbmVJbnRlcnNlYy5oeCUzQTYxJTNBJTIwY2hhcnMlMjA2LTEyYXppMXppNmkyaGFoenpnaGc6MENSN3p5ODpsaW5lTGluZXE6NjRDUjlpNjRuUjIyUjJSMjVSMjNSMzRpMzEwaTMzN3kxMTk6eiUzQSU1Q3Byb2plY3RzJTVDaW9kZXYlNUNnaXRodWIlNUNoYXhlLWdlb20yJTVDc3JjJTVDaW9kZXYlNUNnZW9tMiU1Q2ludGVyc2VjJTVDTGluZUludGVyc2VjLmh4JTNBMTMlM0ElMjBjaGFycyUyMDItMjlhemkxenppNjRoYWktMXppMWkyaTNpNGk1aTZpN2k4aTlpMTBpMTFpMTJpMTNpMTRpMTVoemdocWhnOjRDUjdpNHk4OmxpbmVTZWdtcTo3MENSOWk3MG5SMjJSMlIyNVIyM1IzNmkxMzY4aTE0MDh5MTE5OnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNpbnRlcnNlYyU1Q0xpbmVJbnRlcnNlYy5oeCUzQTQyJTNBJTIwY2hhcnMlMjAyLTQyYXppMXppNGk3MGhhaTQ2aTQ3aHpnOjY5Q1I5aTY5blIyMlIyUjI1UjIzUjM2aTE1NDZpMTU3MnkxMTk6eiUzQSU1Q3Byb2plY3RzJTVDaW9kZXYlNUNnaXRodWIlNUNoYXhlLWdlb20yJTVDc3JjJTVDaW9kZXYlNUNnZW9tMiU1Q2ludGVyc2VjJTVDTGluZUludGVyc2VjLmh4JTNBNDUlM0ElMjBjaGFycyUyMDMtMjlhemkxemk0aTY5aGFpMzhpMzlpNDBpNDFpNDJpNDNpNDRpNDVoemdocToxQ1IyOGkxblIyMlIyUjI1UjIzUjM2aTE1MzJpMTUzOHkxMTk6eiUzQSU1Q3Byb2plY3RzJTVDaW9kZXYlNUNnaXRodWIlNUNoYXhlLWdlb20yJTVDc3JjJTVDaW9kZXYlNUNnZW9tMiU1Q2ludGVyc2VjJTVDTGluZUludGVyc2VjLmh4JTNBNDQlM0ElMjBjaGFycyUyMDYtMTJhemkxemk0aTFoYWh6emdoZzozQ1I3aTN5OTpsaW5lUmF5VG9xOjY4Q1I5aTY4blIyMlIyUjI1UjIzUjQwaTExMjBpMTEzNnkxMTk6eiUzQSU1Q3Byb2plY3RzJTVDaW9kZXYlNUNnaXRodWIlNUNoYXhlLWdlb20yJTVDc3JjJTVDaW9kZXYlNUNnZW9tMiU1Q2ludGVyc2VjJTVDTGluZUludGVyc2VjLmh4JTNBMzUlM0ElMjBjaGFycyUyMDItMThhemkxemkzaTY4aGFpMzFpMzJpMzNpMzRpMzVpMzZpMzdoemdocWhnOjExQ1I3aTExeTEwOnNlZ21TZWdtVG9xOjgwQ1I5aTgwblIyMlIyUjI1UjIzUjQyaTM0NDNpMzQ1OXkxMjA6eiUzQSU1Q3Byb2plY3RzJTVDaW9kZXYlNUNnaXRodWIlNUNoYXhlLWdlb20yJTVDc3JjJTVDaW9kZXYlNUNnZW9tMiU1Q2ludGVyc2VjJTVDTGluZUludGVyc2VjLmh4JTNBMTAzJTNBJTIwY2hhcnMlMjAyLTE4YXppMXppMTFpODBoYWk5OWkxMDBpMTAxaTEwMmkxMDNpMTA0aTEwNWh6Z2hxaGc6N0NSN2k3eTg6cmF5UmF5VG9xOjc0Q1I5aTc0blIyMlIyUjI1UjIzUjQ0aTIyODFpMjI5N3kxMTk6eiUzQSU1Q3Byb2plY3RzJTVDaW9kZXYlNUNnaXRodWIlNUNoYXhlLWdlb20yJTVDc3JjJTVDaW9kZXYlNUNnZW9tMiU1Q2ludGVyc2VjJTVDTGluZUludGVyc2VjLmh4JTNBNjklM0ElMjBjaGFycyUyMDItMThhemkxemk3aTc0aGFpNjVpNjZpNjdpNjhpNjlpNzBpNzFoemdocWhnOjFDUjdpMXkxMDpsaW5lTGluZVRvcTo2NUNSOWk2NW5SMjJSMlIyNVIyM1I0Nmk1ODVpNjkweTEyMDp6JTNBJTVDcHJvamVjdHMlNUNpb2RldiU1Q2dpdGh1YiU1Q2hheGUtZ2VvbTIlNUNzcmMlNUNpb2RldiU1Q2dlb20yJTVDaW50ZXJzZWMlNUNMaW5lSW50ZXJzZWMuaHglM0EyMCUzQSUyMGNoYXJzJTIwMi0xMDdhemkxemkxaTY1aGFpMTZpMTdpMThpMTlpMjBoemdocWhnOjJDUjdpMnk3OmxpbmVSYXlxOjY3Q1I5aTY3blIyMlIyUjI1UjIzUjQ4aTc4N2k4Mjd5MTE5OnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNpbnRlcnNlYyU1Q0xpbmVJbnRlcnNlYy5oeCUzQTI1JTNBJTIwY2hhcnMlMjAyLTQyYXppMXppMmk2N2hhaTI5aTMwaHpnOjY2Q1I5aTY2blIyMlIyUjI1UjIzUjQ4aTk2NGk5OTB5MTE5OnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNpbnRlcnNlYyU1Q0xpbmVJbnRlcnNlYy5oeCUzQTI4JTNBJTIwY2hhcnMlMjAzLTI5YXppMXppMmk2NmhhaTIxaTIyaTIzaTI0aTI1aTI2aTI3aTI4aHpnaHE6MENSMjh6blIyMlIyUjI1UjIzUjQ4aTk1MGk5NTZ5MTE5OnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNpbnRlcnNlYyU1Q0xpbmVJbnRlcnNlYy5oeCUzQTI3JTNBJTIwY2hhcnMlMjA2LTEyYXppMXppMnpoYWh6emdoZzo1Q1I3aTV5MTA6bGluZVNlZ21Ub3E6NzFDUjlpNzFuUjIyUjJSMjVSMjNSNTJpMTcwM2kxNzE5eTExOTp6JTNBJTVDcHJvamVjdHMlNUNpb2RldiU1Q2dpdGh1YiU1Q2hheGUtZ2VvbTIlNUNzcmMlNUNpb2RldiU1Q2dlb20yJTVDaW50ZXJzZWMlNUNMaW5lSW50ZXJzZWMuaHglM0E1MiUzQSUyMGNoYXJzJTIwMi0xOGF6aTF6aTVpNzFoYWk0OGk0OWk1MGk1MWk1Mmk1M2k1NGh6Z2hxaGc6OENSN2k4eTc6cmF5U2VnbXE6NzVDUjlpNzVuUjIyUjJSMjVSMjNSNTRpMjcwNGkyNzMweTExOTp6JTNBJTVDcHJvamVjdHMlNUNpb2RldiU1Q2dpdGh1YiU1Q2hheGUtZ2VvbTIlNUNzcmMlNUNpb2RldiU1Q2dlb20yJTVDaW50ZXJzZWMlNUNMaW5lSW50ZXJzZWMuaHglM0E3OSUzQSUyMGNoYXJzJTIwMy0yOWF6aTF6aThpNzVoYWk3Mmk3M2k3NGk3NWk3Nmk3N2k3OGk3OWh6Zzo3NkNSOWk3Nm5SMjJSMlIyNVIyM1I1NGkyNTI3aTI1Njd5MTE5OnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNpbnRlcnNlYyU1Q0xpbmVJbnRlcnNlYy5oeCUzQTc2JTNBJTIwY2hhcnMlMjAyLTQyYXppMXppOGk3NmhhaTgwaTgxaHpnaHE6M0NSMjhpM25SMjJSMlIyNVIyM1I1NGkyNjkwaTI2OTZ5MTE5OnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNpbnRlcnNlYyU1Q0xpbmVJbnRlcnNlYy5oeCUzQTc4JTNBJTIwY2hhcnMlMjA2LTEyYXppMXppOGkzaGFoenpnaGc6OUNSN2k5eTk6cmF5U2VnbVRvcTo3N0NSOWk3N25SMjJSMlIyNVIyM1I1OGkyODYwaTI4NzZ5MTE5OnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNpbnRlcnNlYyU1Q0xpbmVJbnRlcnNlYy5oeCUzQTg2JTNBJTIwY2hhcnMlMjAyLTE4YXppMXppOWk3N2hhaTgyaTgzaTg0aTg1aTg2aTg3aTg4aHpnaHFoZ2hiUjQwaTNSNTJpNVI1NGk4UjI0aTEwUjM0elI0MmkxMVI1OGk5UjMwaTZSNDZpMVI0NGk3UjM2aTRSNDhpMmhpMTJnaGJSMjN6aGkxZ2hiUjIyaTFSNHpoaTJnOjFDUjFpMXkxODppb2Rldi5nZW9tMi5tYWNyb3NxOjBDUjN6eTQzOmlvZGV2JTVDZ2VvbTIlNUNtYWNyb3MlNUNTcGFjZVRlc3RNYWNyb3MuaHhxOjBDUjV6eTM0OmlvZGV2Lmdlb20yLm1hY3Jvcy5TcGFjZVRlc3RNYWNyb3NxOjBDUjd6eTEwOmlzUmF5U3BhY2VxOjZDUjlpNm5SNjFSNjB5MTU6U3BhY2VUZXN0TWFjcm9zUjYyUjYzaTE0M2kyNTN5MTE5OnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNtYWNyb3MlNUNTcGFjZVRlc3RNYWNyb3MuaHglM0E3JTNBJTIwbGluZXMlMjA3LTExYWkxenp6aTZoYWk3aThpOWkxMGkxMWh6Z2hxaGc6MUNSN2kxeTExOmlzU2VnbVNwYWNlcTo3Q1I5aTduUjYxUjYwUjY0UjYyUjY2aTM0OWk1NTR5MTIxOnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNtYWNyb3MlNUNTcGFjZVRlc3RNYWNyb3MuaHglM0ExNiUzQSUyMGxpbmVzJTIwMTYtMjFhaTF6emkxaTdoYWkxNmkxN2kxOGkxOWkyMGkyMWh6Z2hxaGc6MkNSN2kyeTEzOmlzQ2lyY2xlU3BhY2VxOjhDUjlpOG5SNjFSNjBSNjRSNjJSNjhpNjQxaTc5M3kxMjE6eiUzQSU1Q3Byb2plY3RzJTVDaW9kZXYlNUNnaXRodWIlNUNoYXhlLWdlb20yJTVDc3JjJTVDaW9kZXYlNUNnZW9tMiU1Q21hY3JvcyU1Q1NwYWNlVGVzdE1hY3Jvcy5oeCUzQTI2JTNBJTIwbGluZXMlMjAyNi0zMGFpMXp6aTJpOGhhaTI2aTI3aTI4aTI5aTMwaHpnaHFoZ2hiUjY4aTJSNjN6UjY2aTFoaTNnaGJSNjJ6aGkxZzo0Q1IzaTR5NDM6aW9kZXYlNUNnZW9tMiU1Q21hY3JvcyU1Q1ByaW1pdGl2ZU1hY3Jvcy5oeHE6MENSNXp5MzQ6aW9kZXYuZ2VvbTIubWFjcm9zLlByaW1pdGl2ZU1hY3Jvc3E6MENSN3p5MTg6cHJvamVjdFBvaW50VG9MaW5lcTo4MUNSOWk4MW5SNzBSNjB5MTU6UHJpbWl0aXZlTWFjcm9zUjcxUjcyaTIwM2k1MzN5MTE5OnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNtYWNyb3MlNUNQcmltaXRpdmVNYWNyb3MuaHglM0E5JTNBJTIwbGluZXMlMjA5LTE5YWkxaTR6emk4MWhhaTlpMTBpMTFpMTJpMTNpMTRpMTVpMTZpMTdpMThpMTloemdocWhnOjFDUjdpMXkyMDp0YW5nZW50UG9pbnRUb0NpcmNsZXE6ODJDUjlpODJuUjcwUjYwUjczUjcxUjc1aTY3MWkxNTk0eTEyMTp6JTNBJTVDcHJvamVjdHMlNUNpb2RldiU1Q2dpdGh1YiU1Q2hheGUtZ2VvbTIlNUNzcmMlNUNpb2RldiU1Q2dlb20yJTVDbWFjcm9zJTVDUHJpbWl0aXZlTWFjcm9zLmh4JTNBMjQlM0ElMjBsaW5lcyUyMDI0LTYxYWkxaTR6aTFpODJoYWkyNGkyNWkyNmkyN2kyOGkyOWkzMGkzMWkzMmkzM2kzNGkzNWkzNmkzN2kzOGkzOWk0MGk0MWk0Mmk0M2k0NGk0NWk0Nmk0N2k0OGk0OWk1MGk1MWk1Mmk1M2k1NGk1NWk1Nmk1N2k1OGk1OWk2MGk2MWh6Z2hxaGdoYlI3MnpSNzVpMWhpMmdoYlI3MXpoaTFnOjNDUjNpM3kzNzppb2RldiU1Q2dlb20yJTVDbWFjcm9zJTVDVmVjTWFjcm9zLmh4cTowQ1I1enkyODppb2Rldi5nZW9tMi5tYWNyb3MuVmVjTWFjcm9zcToxMkNSN2kxMnkxMzpsZW5ndGhCZXR3ZWVucTo1MUNSOWk1MW5SNzdSNjB5OTpWZWNNYWNyb3NSNzhSNzlpMjMzMGkyNDM5eTExODp6JTNBJTVDcHJvamVjdHMlNUNpb2RldiU1Q2dpdGh1YiU1Q2hheGUtZ2VvbTIlNUNzcmMlNUNpb2RldiU1Q2dlb20yJTVDbWFjcm9zJTVDVmVjTWFjcm9zLmh4JTNBMTI0JTNBJTIwbGluZXMlMjAxMjQtMTI4YWkxaTN6aTEyaTUxaGFpMTI0aTEyNWkxMjZpMTI3aTEyOGh6Z2hxaGc6MTlDUjdpMTl5MjE6cmFkaWFuc0JldHdlZW5Ob3JtYWxzcTo1OENSOWk1OG5SNzdSNjBSODBSNzhSODJpMzc0MmkzNzk5eTExODp6JTNBJTVDcHJvamVjdHMlNUNpb2RldiU1Q2dpdGh1YiU1Q2hheGUtZ2VvbTIlNUNzcmMlNUNpb2RldiU1Q2dlb20yJTVDbWFjcm9zJTVDVmVjTWFjcm9zLmh4JTNBMTg5JTNBJTIwbGluZXMlMjAxODktMTkxYWkxaTN6aTE5aTU4aGFpMTg5aTE5MGkxOTFoemdocWhnOjEwQ1I3aTEweTE2Om1hZ25pdHVkZUJldHdlZW5xOjQ5Q1I5aTQ5blI3N1I2MFI4MFI3OFI4NGkxOTcwaTIwODJ5MTE4OnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNtYWNyb3MlNUNWZWNNYWNyb3MuaHglM0ExMDYlM0ElMjBsaW5lcyUyMDEwNi0xMTBhaTFpM3ppMTBpNDloYWkxMDZpMTA3aTEwOGkxMDlpMTEwaHpnaHFoZzoyNENSN2kyNHkxNDptaXJyb3JCeU5vcm1hbHE6NjNDUjlpNjNuUjc3UjYwUjgwUjc4Ujg2aTUyNzlpNTQ2MXkxMTg6eiUzQSU1Q3Byb2plY3RzJTVDaW9kZXYlNUNnaXRodWIlNUNoYXhlLWdlb20yJTVDc3JjJTVDaW9kZXYlNUNnZW9tMiU1Q21hY3JvcyU1Q1ZlY01hY3Jvcy5oeCUzQTI0NiUzQSUyMGxpbmVzJTIwMjQ2LTI1MmFpMWkzemkyNGk2M2hhaTI0NmkyNDdpMjQ4aTI0OWkyNTBpMjUxaTI1Mmh6Z2hxaGc6MTRDUjdpMTR5Nzpkb3RQcm9kcTo1M0NSOWk1M25SNzdSNjBSODBSNzhSODhpMjc1MGkyNzk2eTExODp6JTNBJTVDcHJvamVjdHMlNUNpb2RldiU1Q2dpdGh1YiU1Q2hheGUtZ2VvbTIlNUNzcmMlNUNpb2RldiU1Q2dlb20yJTVDbWFjcm9zJTVDVmVjTWFjcm9zLmh4JTNBMTQ0JTNBJTIwbGluZXMlMjAxNDQtMTQ2YWkxaTN6aTE0aTUzaGFpMTQ0aTE0NWkxNDZoemdocWhnOjZDUjdpNnkzOnN1YnE6NDVDUjlpNDVuUjc3UjYwUjgwUjc4UjkwaTEzMjZpMTM5MXkxMTU6eiUzQSU1Q3Byb2plY3RzJTVDaW9kZXYlNUNnaXRodWIlNUNoYXhlLWdlb20yJTVDc3JjJTVDaW9kZXYlNUNnZW9tMiU1Q21hY3JvcyU1Q1ZlY01hY3Jvcy5oeCUzQTcxJTNBJTIwbGluZXMlMjA3MS03NGFpMWkzemk2aTQ1aGFpNzFpNzJpNzNpNzRoemdocWhnOjIyQ1I3aTIyeTExOnJvdGF0ZVF1YXJ0cTo2MUNSOWk2MW5SNzdSNjBSODBSNzhSOTJpNDY3Nmk0ODg0eTExODp6JTNBJTVDcHJvamVjdHMlNUNpb2RldiU1Q2dpdGh1YiU1Q2hheGUtZ2VvbTIlNUNzcmMlNUNpb2RldiU1Q2dlb20yJTVDbWFjcm9zJTVDVmVjTWFjcm9zLmh4JTNBMjIzJTNBJTIwbGluZXMlMjAyMjMtMjMwYWkxaTN6aTIyaTYxaGFpMjIzaTIyNGkyMjVpMjI2aTIyN2kyMjhpMjI5aTIzMGh6Z2hxaGc6MENSN3p5MTg6YXJyYXlGcm9tVHdvT3JMZXNzcTozOUNSOWkzOW5SNzdSNjBSODBSNzhSOTRpMTU5aTM2MHkxMTM6eiUzQSU1Q3Byb2plY3RzJTVDaW9kZXYlNUNnaXRodWIlNUNoYXhlLWdlb20yJTVDc3JjJTVDaW9kZXYlNUNnZW9tMiU1Q21hY3JvcyU1Q1ZlY01hY3Jvcy5oeCUzQTglM0ElMjBsaW5lcyUyMDgtMTZhaTFpM3p6aTM5aGFpOGk5aTEwaTExaTEyaTEzaTE0aTE1aTE2aHpnaHFoZzoxM0NSN2kxM3k5Om5vcm1hbGl6ZXE6NTJDUjlpNTJuUjc3UjYwUjgwUjc4Ujk2aTI1NDNpMjY1N3kxMTg6eiUzQSU1Q3Byb2plY3RzJTVDaW9kZXYlNUNnaXRodWIlNUNoYXhlLWdlb20yJTVDc3JjJTVDaW9kZXYlNUNnZW9tMiU1Q21hY3JvcyU1Q1ZlY01hY3Jvcy5oeCUzQTEzNCUzQSUyMGxpbmVzJTIwMTM0LTEzOGFpMWkzemkxM2k1MmhhaTEzNGkxMzVpMTM2aTEzN2kxMzhoemdocWhnOjIzQ1I3aTIzeTg6bWlycm9yQnlxOjYyQ1I5aTYyblI3N1I2MFI4MFI3OFI5OGk1MDAwaTUxNjF5MTE4OnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNtYWNyb3MlNUNWZWNNYWNyb3MuaHglM0EyMzYlM0ElMjBsaW5lcyUyMDIzNi0yNDBhaTFpM3ppMjNpNjJoYWkyMzZpMjM3aTIzOGkyMzlpMjQwaHpnaHFoZzoxNUNSN2kxNXk4OnNrZXdQcm9kcTo1NENSOWk1NG5SNzdSNjBSODBSNzhSMTAwaTI4OTBpMjkzNnkxMTg6eiUzQSU1Q3Byb2plY3RzJTVDaW9kZXYlNUNnaXRodWIlNUNoYXhlLWdlb20yJTVDc3JjJTVDaW9kZXYlNUNnZW9tMiU1Q21hY3JvcyU1Q1ZlY01hY3Jvcy5oeCUzQTE1MiUzQSUyMGxpbmVzJTIwMTUyLTE1NGFpMWkzemkxNWk1NGhhaTE1MmkxNTNpMTU0aHpnaHFoZzo0Q1I3aTR5ODpzd2FwVmVjc3E6NDNDUjlpNDNuUjc3UjYwUjgwUjc4UjEwMmk5MzZpMTA0N3kxMTU6eiUzQSU1Q3Byb2plY3RzJTVDaW9kZXYlNUNnaXRodWIlNUNoYXhlLWdlb20yJTVDc3JjJTVDaW9kZXYlNUNnZW9tMiU1Q21hY3JvcyU1Q1ZlY01hY3Jvcy5oeCUzQTQ5JTNBJTIwbGluZXMlMjA0OS01NmFpMWkzemk0aTQzaGFpNDlpNTBpNTFpNTJpNTNpNTRpNTVpNTZoemdocWhnOjE3Q1I3aTE3eTk6cmFkaWFuc09mcTo1NkNSOWk1Nm5SNzdSNjBSODBSNzhSMTA0aTMyMjFpMzI2NnkxMTg6eiUzQSU1Q3Byb2plY3RzJTVDaW9kZXYlNUNnaXRodWIlNUNoYXhlLWdlb20yJTVDc3JjJTVDaW9kZXYlNUNnZW9tMiU1Q21hY3JvcyU1Q1ZlY01hY3Jvcy5oeCUzQTE2OSUzQSUyMGxpbmVzJTIwMTY5LTE3MWFpMWkzemkxN2k1NmhhaTE2OWkxNzBpMTcxaHpnaHFoZzozQ1I3aTN5Njpzd2FwWFlxOjQyQ1I5aTQyblI3N1I2MFI4MFI3OFIxMDZpNzY4aTg0MnkxMTU6eiUzQSU1Q3Byb2plY3RzJTVDaW9kZXYlNUNnaXRodWIlNUNoYXhlLWdlb20yJTVDc3JjJTVDaW9kZXYlNUNnZW9tMiU1Q21hY3JvcyU1Q1ZlY01hY3Jvcy5oeCUzQTM5JTNBJTIwbGluZXMlMjAzOS00M2FpMWkzemkzaTQyaGFpMzlpNDBpNDFpNDJpNDNoemdocWhnOjExQ1I3aTExeTY6bGVuZ3RocTo1MENSOWk1MG5SNzdSNjBSODBSNzhSMTA4aTIxNjZpMjIzMXkxMTg6eiUzQSU1Q3Byb2plY3RzJTVDaW9kZXYlNUNnaXRodWIlNUNoYXhlLWdlb20yJTVDc3JjJTVDaW9kZXYlNUNnZW9tMiU1Q21hY3JvcyU1Q1ZlY01hY3Jvcy5oeCUzQTExNiUzQSUyMGxpbmVzJTIwMTE2LTExOGFpMWkzemkxMWk1MGhhaTExNmkxMTdpMTE4aHpnaHFoZzoyMENSN2kyMHkxNDpub3JtYWxCaXNlY3RvcnE6NTlDUjlpNTluUjc3UjYwUjgwUjc4UjExMGkzOTE3aTQyNjV5MTE4OnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNtYWNyb3MlNUNWZWNNYWNyb3MuaHglM0ExOTclM0ElMjBsaW5lcyUyMDE5Ny0yMDVhaTFpM3ppMjBpNTloYWkxOTdpMTk4aTE5OWkyMDBpMjAxaTIwMmkyMDNpMjA0aTIwNWh6Z2hxaGc6N0NSN2k3eTM6bXVscTo0NkNSOWk0Nm5SNzdSNjBSODBSNzhSMTEyaTE0OThpMTU2M3kxMTU6eiUzQSU1Q3Byb2plY3RzJTVDaW9kZXYlNUNnaXRodWIlNUNoYXhlLWdlb20yJTVDc3JjJTVDaW9kZXYlNUNnZW9tMiU1Q21hY3JvcyU1Q1ZlY01hY3Jvcy5oeCUzQTgwJTNBJTIwbGluZXMlMjA4MC04M2FpMWkzemk3aTQ2aGFpODBpODFpODJpODNoemdocWhnOjFDUjdpMXk2OmVxdWFsc3E6NDBDUjlpNDBuUjc3UjYwUjgwUjc4UjExNGk0NThpNTA5eTExNTp6JTNBJTVDcHJvamVjdHMlNUNpb2RldiU1Q2dpdGh1YiU1Q2hheGUtZ2VvbTIlNUNzcmMlNUNpb2RldiU1Q2dlb20yJTVDbWFjcm9zJTVDVmVjTWFjcm9zLmh4JTNBMjIlM0ElMjBsaW5lcyUyMDIyLTI0YWkxaTN6aTFpNDBoYWkyMmkyM2kyNGh6Z2hxaGc6MTZDUjdpMTZ5NTpwb2xhcnE6NTVDUjlpNTVuUjc3UjYwUjgwUjc4UjExNmkzMDM3aTMxMzR5MTE4OnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNtYWNyb3MlNUNWZWNNYWNyb3MuaHglM0ExNjAlM0ElMjBsaW5lcyUyMDE2MC0xNjNhaTFpM3ppMTZpNTVoYWkxNjBpMTYxaTE2MmkxNjNoemdocWhnOjE4Q1I3aTE4eTE0OnJhZGlhbnNCZXR3ZWVucTo1N0NSOWk1N25SNzdSNjBSODBSNzhSMTE4aTMzNjZpMzYzNXkxMTg6eiUzQSU1Q3Byb2plY3RzJTVDaW9kZXYlNUNnaXRodWIlNUNoYXhlLWdlb20yJTVDc3JjJTVDaW9kZXYlNUNnZW9tMiU1Q21hY3JvcyU1Q1ZlY01hY3Jvcy5oeCUzQTE3NyUzQSUyMGxpbmVzJTIwMTc3LTE4M2FpMWkzemkxOGk1N2hhaTE3N2kxNzhpMTc5aTE4MGkxODFpMTgyaTE4M2h6Z2hxaGc6MjFDUjdpMjF5Njpyb3RhdGVxOjYwQ1I5aTYwblI3N1I2MFI4MFI3OFIxMjBpNDM3Nmk0NTYyeTExODp6JTNBJTVDcHJvamVjdHMlNUNpb2RldiU1Q2dpdGh1YiU1Q2hheGUtZ2VvbTIlNUNzcmMlNUNpb2RldiU1Q2dlb20yJTVDbWFjcm9zJTVDVmVjTWFjcm9zLmh4JTNBMjExJTNBJTIwbGluZXMlMjAyMTEtMjE3YWkxaTN6aTIxaTYwaGFpMjExaTIxMmkyMTNpMjE0aTIxNWkyMTZpMjE3aHpnaHFoZzoyQ1I3aTJ5NjpuZWdhdGVxOjQxQ1I5aTQxblI3N1I2MFI4MFI3OFIxMjJpNjExaTY2NnkxMTU6eiUzQSU1Q3Byb2plY3RzJTVDaW9kZXYlNUNnaXRodWIlNUNoYXhlLWdlb20yJTVDc3JjJTVDaW9kZXYlNUNnZW9tMiU1Q21hY3JvcyU1Q1ZlY01hY3Jvcy5oeCUzQTMwJTNBJTIwbGluZXMlMjAzMC0zM2FpMWkzemkyaTQxaGFpMzBpMzFpMzJpMzNoemdocWhnOjVDUjdpNXkzOmFkZHE6NDRDUjlpNDRuUjc3UjYwUjgwUjc4UjEyNGkxMTU0aTEyMTl5MTE1OnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNtYWNyb3MlNUNWZWNNYWNyb3MuaHglM0E2MiUzQSUyMGxpbmVzJTIwNjItNjVhaTFpM3ppNWk0NGhhaTYyaTYzaTY0aTY1aHpnaHFoZzo4Q1I3aTh5MzpkaXZxOjQ3Q1I5aTQ3blI3N1I2MFI4MFI3OFIxMjZpMTY3MGkxNzM1eTExNTp6JTNBJTVDcHJvamVjdHMlNUNpb2RldiU1Q2dpdGh1YiU1Q2hheGUtZ2VvbTIlNUNzcmMlNUNpb2RldiU1Q2dlb20yJTVDbWFjcm9zJTVDVmVjTWFjcm9zLmh4JTNBODklM0ElMjBsaW5lcyUyMDg5LTkyYWkxaTN6aThpNDdoYWk4OWk5MGk5MWk5Mmh6Z2hxaGc6OUNSN2k5eTk6bWFnbml0dWRlcTo0OENSOWk0OG5SNzdSNjBSODBSNzhSMTI4aTE4MjJpMTg2OHkxMTY6eiUzQSU1Q3Byb2plY3RzJTVDaW9kZXYlNUNnaXRodWIlNUNoYXhlLWdlb20yJTVDc3JjJTVDaW9kZXYlNUNnZW9tMiU1Q21hY3JvcyU1Q1ZlY01hY3Jvcy5oeCUzQTk4JTNBJTIwbGluZXMlMjA5OC0xMDBhaTFpM3ppOWk0OGhhaTk4aTk5aTEwMGh6Z2hxaGdoYlIxMDRpMTdSOTZpMTNSMTIwaTIxUjEwNmkzUjExNmkxNlI4NmkyNFIxMTJpN1IxMjZpOFIxMDBpMTVSMTEwaTIwUjEwMmk0UjgyaTE5UjEyMmkyUjExOGkxOFI5NHpSMTI0aTVSNzlpMTJSMTA4aTExUjk4aTIzUjExNGkxUjkwaTZSMTI4aTlSODRpMTBSODhpMTRSOTJpMjJoaTI1Z2hiUjc4emhpMWc6MUNSM2kxeTQ2OmlvZGV2JTVDZ2VvbTIlNUNtYWNyb3MlNUNMaW5lSW50ZXJzZWNNYWNyb3MuaHhxOjBDUjV6eTM3OmlvZGV2Lmdlb20yLm1hY3Jvcy5MaW5lSW50ZXJzZWNNYWNyb3NxOjBDUjd6UjM0cTo5Q1I5aTluUjEzMFI2MHkxODpMaW5lSW50ZXJzZWNNYWNyb3NSMTMxUjM0aTE5N2k1MzF5MTIyOnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNtYWNyb3MlNUNMaW5lSW50ZXJzZWNNYWNyb3MuaHglM0E4JTNBJTIwbGluZXMlMjA4LTE0YWkxaTF6emk5aGFpOGk5aTEwaTExaTEyaTEzaTE0aHpnaHFoZzo0Q1I3aTRSNTRxOjEzQ1I5aTEzblIxMzBSNjBSMTMyUjEzMVI1NGkxODc5aTIxNzl5MTI0OnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNtYWNyb3MlNUNMaW5lSW50ZXJzZWNNYWNyb3MuaHglM0E0OCUzQSUyMGxpbmVzJTIwNDgtNTJhaTFpMXppNGkxM2hhaTQ4aTQ5aTUwaTUxaTUyaHpnaHFoZzozQ1I3aTNSMzBxOjEyQ1I5aTEyblIxMzBSNjBSMTMyUjEzMVIzMGkxNDI3aTE3MjZ5MTI0OnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNtYWNyb3MlNUNMaW5lSW50ZXJzZWNNYWNyb3MuaHglM0EzOCUzQSUyMGxpbmVzJTIwMzgtNDJhaTFpMXppM2kxMmhhaTM4aTM5aTQwaTQxaTQyaHpnaHFoZzoxQ1I3aTFSNDhxOjEwQ1I5aTEwblIxMzBSNjBSMTMyUjEzMVI0OGk2ODRpOTAyeTEyNDp6JTNBJTVDcHJvamVjdHMlNUNpb2RldiU1Q2dpdGh1YiU1Q2hheGUtZ2VvbTIlNUNzcmMlNUNpb2RldiU1Q2dlb20yJTVDbWFjcm9zJTVDTGluZUludGVyc2VjTWFjcm9zLmh4JTNBMjAlM0ElMjBsaW5lcyUyMDIwLTIzYWkxaTF6aTFpMTBoYWkyMGkyMWkyMmkyM2h6Z2hxaGc6MkNSN2kyUjM2cToxMUNSOWkxMW5SMTMwUjYwUjEzMlIxMzFSMzZpMTA1NmkxMjc1eTEyNDp6JTNBJTVDcHJvamVjdHMlNUNpb2RldiU1Q2dpdGh1YiU1Q2hheGUtZ2VvbTIlNUNzcmMlNUNpb2RldiU1Q2dlb20yJTVDbWFjcm9zJTVDTGluZUludGVyc2VjTWFjcm9zLmh4JTNBMjklM0ElMjBsaW5lcyUyMDI5LTMyYWkxaTF6aTJpMTFoYWkyOWkzMGkzMWkzMmh6Z2hxaGc6NUNSN2k1UjI0cToxNENSOWkxNG5SMTMwUjYwUjEzMlIxMzFSMjRpMjMzM2kyNjM0eTEyNDp6JTNBJTVDcHJvamVjdHMlNUNpb2RldiU1Q2dpdGh1YiU1Q2hheGUtZ2VvbTIlNUNzcmMlNUNpb2RldiU1Q2dlb20yJTVDbWFjcm9zJTVDTGluZUludGVyc2VjTWFjcm9zLmh4JTNBNTglM0ElMjBsaW5lcyUyMDU4LTYyYWkxaTF6aTVpMTRoYWk1OGk1OWk2MGk2MWk2Mmh6Z2hxaGdoYlI1NGk0UjI0aTVSMzR6UjMwaTNSMzZpMlI0OGkxaGk2Z2hiUjEzMXpoaTFnOjJDUjNpMnk0ODppb2RldiU1Q2dlb20yJTVDbWFjcm9zJTVDQ2lyY2xlSW50ZXJzZWNNYWNyb3MuaHhxOjBDUjV6eTM5OmlvZGV2Lmdlb20yLm1hY3Jvcy5DaXJjbGVJbnRlcnNlY01hY3Jvc3E6MENSN3pSOHE6MTVDUjlpMTVuUjEzOVI2MHkyMDpDaXJjbGVJbnRlcnNlY01hY3Jvc1IxNDBSOGkyMDFpMTEzMHkxMjQ6eiUzQSU1Q3Byb2plY3RzJTVDaW9kZXYlNUNnaXRodWIlNUNoYXhlLWdlb20yJTVDc3JjJTVDaW9kZXYlNUNnZW9tMiU1Q21hY3JvcyU1Q0NpcmNsZUludGVyc2VjTWFjcm9zLmh4JTNBNyUzQSUyMGxpbmVzJTIwNy00MmFpMWkyenppMTVoYWk3aThpOWkxMGkxMWkxMmkxM2kxNGkxNWkxNmkxN2kxOGkxOWkyMGkyMWkyMmkyM2kyNGkyNWkyNmkyN2kyOGkyOWkzMGkzMWkzMmkzM2kzNGkzNWkzNmkzN2kzOGkzOWk0MGk0MWk0Mmh6Z2hxaGc6MUNSN2kxUjE4cToxNkNSOWkxNm5SMTM5UjYwUjE0MVIxNDBSMThpMTI3N2kxNzgzeTEyNjp6JTNBJTVDcHJvamVjdHMlNUNpb2RldiU1Q2dpdGh1YiU1Q2hheGUtZ2VvbTIlNUNzcmMlNUNpb2RldiU1Q2dlb20yJTVDbWFjcm9zJTVDQ2lyY2xlSW50ZXJzZWNNYWNyb3MuaHglM0E0NyUzQSUyMGxpbmVzJTIwNDctNjBhaTFpMnppMWkxNmhhaTQ3aTQ4aTQ5aTUwaTUxaTUyaTUzaTU0aTU1aTU2aTU3aTU4aTU5aTYwaHpnaHFoZzoyQ1I3aTJSMTJxOjE3Q1I5aTE3blIxMzlSNjBSMTQxUjE0MFIxMmkxOTMxaTI0Mzl5MTI2OnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNtYWNyb3MlNUNDaXJjbGVJbnRlcnNlY01hY3Jvcy5oeCUzQTY1JTNBJTIwbGluZXMlMjA2NS03OGFpMWkyemkyaTE3aGFpNjVpNjZpNjdpNjhpNjlpNzBpNzFpNzJpNzNpNzRpNzVpNzZpNzdpNzhoemdocWhnaGJSMThpMVIxMmkyUjh6aGkzZ2hiUjE0MHpoaTFnaGJSNzBpNFIxMzBpMVIxMzlpMlI3N2kzUjYxemhpNWc6MkNSMWkyeTExOmlvZGV2Lmdlb20ycTowQ1IzenkyMjppb2RldiU1Q2dlb20yJTVDVmVjLmh4cTowQ1I1enkxNTppb2Rldi5nZW9tMi5WZWNxOjEyQ1I3aTEyUjExOHE6MzBDUjlpMzBuUjE0NlIxNDV5MzpWZWNSMTQ3UjExOGkxODYyaTE5MTN5OTk6eiUzQSU1Q3Byb2plY3RzJTVDaW9kZXYlNUNnaXRodWIlNUNoYXhlLWdlb20yJTVDc3JjJTVDaW9kZXYlNUNnZW9tMiU1Q1ZlYy5oeCUzQTgyJTNBJTIwY2hhcnMlMjAyLTUzYWkyenppMTJpMzBoYWk3OGk3OWk4MGk4MWk4Mmh6Z2hxaGc6MTlDUjdpMTl5OTp0b1JhZGlhbnNxOjM3Q1I5aTM3blIxNDZSMTQ1UjE0OFIxNDdSMTUwaTI2ODFpMjcyM3kxMDA6eiUzQSU1Q3Byb2plY3RzJTVDaW9kZXYlNUNnaXRodWIlNUNoYXhlLWdlb20yJTVDc3JjJTVDaW9kZXYlNUNnZW9tMiU1Q1ZlYy5oeCUzQTEyMiUzQSUyMGNoYXJzJTIwMi00NGFpMnp6aTE5aTM3aGFpMTE4aTExOWkxMjBpMTIxaTEyMmh6Z2hxaGc6MTBDUjdpMTBSNzlxOjI4Q1I5aTI4blIxNDZSMTQ1UjE0OFIxNDdSNzlpMTU5N2kxNjQ3eTk5OnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNWZWMuaHglM0E3MiUzQSUyMGNoYXJzJTIwMi01MmFpMnp6aTEwaTI4aGFpNjhpNjlpNzBpNzFpNzJoemdocWhnOjE0Q1I3aTE0eTM6bmV3cTozMkNSOWkzMm5SMTQ2UjE0NVIxNDhSMTQ3UjE1M2kyMTI4aTIxMzh5OTk6eiUzQSU1Q3Byb2plY3RzJTVDaW9kZXYlNUNnaXRodWIlNUNoYXhlLWdlb20yJTVDc3JjJTVDaW9kZXYlNUNnZW9tMiU1Q1ZlYy5oeCUzQTkzJTNBJTIwY2hhcnMlMjAyLTEyYWkyenppMTRpMzJoYWk4OGk4OWk5MGk5MWk5Mmk5M2k5NGh6Z2hxaGc6NkNSN2k2eTE4Om5vcm1hbEJpc2VjdG9yRnJvbXE6MjRDUjlpMjRuUjE0NlIxNDVSMTQ4UjE0N1IxNTVpMTA2OGkxMDg5eTk5OnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNWZWMuaHglM0E1MCUzQSUyMGNoYXJzJTIwMi0yM2FpMnp6aTZpMjRoYWk0Nmk0N2k0OGk0OWk1MGk1MWk1Mmh6Z2hxaGc6MENSN3p5Njpmcm9tWFlxOjE4Q1I5aTE4blIxNDZSMTQ1UjE0OFIxNDdSMTU3aTE1MmkxNzJ5OTk6eiUzQSU1Q3Byb2plY3RzJTVDaW9kZXYlNUNnaXRodWIlNUNoYXhlLWdlb20yJTVDc3JjJTVDaW9kZXYlNUNnZW9tMiU1Q1ZlYy5oeCUzQTEwJTNBJTIwY2hhcnMlMjAyLTIyYWkyenp6aTE4aGFpLTF6aTFpMmkzaTRpNWk2aTdpOGk5aTEwaHpnaHFoZzoxM0NSN2kxM1I4MnE6MzFDUjlpMzFuUjE0NlIxNDVSMTQ4UjE0N1I4MmkyMDAwaTIwNTh5OTk6eiUzQSU1Q3Byb2plY3RzJTVDaW9kZXYlNUNnaXRodWIlNUNoYXhlLWdlb20yJTVDc3JjJTVDaW9kZXYlNUNnZW9tMiU1Q1ZlYy5oeCUzQTg3JTNBJTIwY2hhcnMlMjAyLTYwYWkyenppMTNpMzFoYWk4M2k4NGk4NWk4Nmk4N2h6Z2hxaGc6MTVDUjdpMTV5NTpjbG9uZXE6MzNDUjlpMzNuUjE0NlIxNDVSMTQ4UjE0N1IxNjBpMjI1OWkyMjg5eTEwMDp6JTNBJTVDcHJvamVjdHMlNUNpb2RldiU1Q2dpdGh1YiU1Q2hheGUtZ2VvbTIlNUNzcmMlNUNpb2RldiU1Q2dlb20yJTVDVmVjLmh4JTNBMTAyJTNBJTIwY2hhcnMlMjAyLTMyYWkyenppMTVpMzNoYWk5NWk5Nmk5N2k5OGk5OWkxMDBpMTAxaTEwMmh6Z2hxaGc6NENSN2k0eTc6ZnJvbU11bHE6MjJDUjlpMjJuUjE0NlIxNDVSMTQ4UjE0N1IxNjJpNzM3aTc1OHk5OTp6JTNBJTVDcHJvamVjdHMlNUNpb2RldiU1Q2dpdGh1YiU1Q2hheGUtZ2VvbTIlNUNzcmMlNUNpb2RldiU1Q2dlb20yJTVDVmVjLmh4JTNBMzYlM0ElMjBjaGFycyUyMDItMjNhaTJ6emk0aTIyaGFpMzJpMzNpMzRpMzVpMzZpMzdpMzhoemdocWhnOjE3Q1I3aTE3UjEyOHE6MzVDUjlpMzVuUjE0NlIxNDVSMTQ4UjE0N1IxMjhpMjQ0N2kyNDg5eTEwMDp6JTNBJTVDcHJvamVjdHMlNUNpb2RldiU1Q2dpdGh1YiU1Q2hheGUtZ2VvbTIlNUNzcmMlNUNpb2RldiU1Q2dlb20yJTVDVmVjLmh4JTNBMTEyJTNBJTIwY2hhcnMlMjAyLTQ0YWkyenppMTdpMzVoYWkxMDhpMTA5aTExMGkxMTFpMTEyaHpnaHFoZzozQ1I3aTN5Nzpmcm9tU3VicToyMUNSOWkyMW5SMTQ2UjE0NVIxNDhSMTQ3UjE2NWk1NzdpNTk4eTk5OnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNWZWMuaHglM0EyOSUzQSUyMGNoYXJzJTIwMi0yM2FpMnp6aTNpMjFoYWkyNWkyNmkyN2kyOGkyOWkzMGkzMWh6Z2hxaGc6MTFDUjdpMTFSODRxOjI5Q1I5aTI5blIxNDZSMTQ1UjE0OFIxNDdSODRpMTcyOWkxNzgyeTk5OnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNWZWMuaHglM0E3NyUzQSUyMGNoYXJzJTIwMi01NWFpMnp6aTExaTI5aGFpNzNpNzRpNzVpNzZpNzdoemdocWhnOjIwQ1I3aTIweTg6dG9TdHJpbmdxOjM4Q1I5aTM4blIxNDZSMTQ1UjE0OFIxNDdSMTY4aTI3NzdpMjgyMXkxMDA6eiUzQSU1Q3Byb2plY3RzJTVDaW9kZXYlNUNnaXRodWIlNUNoYXhlLWdlb20yJTVDc3JjJTVDaW9kZXYlNUNnZW9tMiU1Q1ZlYy5oeCUzQTEyNyUzQSUyMGNoYXJzJTIwMi00NmFpMnp6aTIwaTM4aGFpMTIzaTEyNGkxMjVpMTI2aTEyN2h6Z2hxaGc6N0NSN2k3UjExNHE6MjVDUjlpMjVuUjE0NlIxNDVSMTQ4UjE0N1IxMTRpMTIzOWkxMjgyeTk5OnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNWZWMuaHglM0E1NyUzQSUyMGNoYXJzJTIwMi00NWFpMnp6aTdpMjVoYWk1M2k1NGk1NWk1Nmk1N2h6Z2hxaGc6MUNSN2kxeTk6ZnJvbVBvbGFycToxOUNSOWkxOW5SMTQ2UjE0NVIxNDhSMTQ3UjE3MWkyNjFpMjgyeTk5OnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNWZWMuaHglM0ExNSUzQSUyMGNoYXJzJTIwMi0yM2FpMnp6aTFpMTloYWkxMWkxMmkxM2kxNGkxNWkxNmkxN2h6Z2hxaGc6MTZDUjdpMTZSMTA4cTozNENSOWkzNG5SMTQ2UjE0NVIxNDhSMTQ3UjEwOGkyMzQ3aTIzODZ5MTAwOnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNWZWMuaHglM0ExMDclM0ElMjBjaGFycyUyMDItNDFhaTJ6emkxNmkzNGhhaTEwM2kxMDRpMTA1aTEwNmkxMDdoemdocWhnOjE4Q1I3aTE4Ujk2cTozNkNSOWkzNm5SMTQ2UjE0NVIxNDhSMTQ3Ujk2aTI1NjRpMjYyMHkxMDA6eiUzQSU1Q3Byb2plY3RzJTVDaW9kZXYlNUNnaXRodWIlNUNoYXhlLWdlb20yJTVDc3JjJTVDaW9kZXYlNUNnZW9tMiU1Q1ZlYy5oeCUzQTExNyUzQSUyMGNoYXJzJTIwMi01OGFpMnp6aTE4aTM2aGFpMTEzaTExNGkxMTVpMTE2aTExN2h6Z2hxaGc6MkNSN2kyeTc6ZnJvbUFkZHE6MjBDUjlpMjBuUjE0NlIxNDVSMTQ4UjE0N1IxNzVpNDE3aTQzOHk5OTp6JTNBJTVDcHJvamVjdHMlNUNpb2RldiU1Q2dpdGh1YiU1Q2hheGUtZ2VvbTIlNUNzcmMlNUNpb2RldiU1Q2dlb20yJTVDVmVjLmh4JTNBMjIlM0ElMjBjaGFycyUyMDItMjNhaTJ6emkyaTIwaGFpMThpMTlpMjBpMjFpMjJpMjNpMjRoemdocWhnOjVDUjdpNXk3OmZyb21EaXZxOjIzQ1I5aTIzblIxNDZSMTQ1UjE0OFIxNDdSMTc3aTg5N2k5MTh5OTk6eiUzQSU1Q3Byb2plY3RzJTVDaW9kZXYlNUNnaXRodWIlNUNoYXhlLWdlb20yJTVDc3JjJTVDaW9kZXYlNUNnZW9tMiU1Q1ZlYy5oeCUzQTQzJTNBJTIwY2hhcnMlMjAyLTIzYWkyenppNWkyM2hhaTM5aTQwaTQxaTQyaTQzaTQ0aTQ1aHpnaHFoZzo4Q1I3aThSODhxOjI2Q1I5aTI2blIxNDZSMTQ1UjE0OFIxNDdSODhpMTM1NWkxMzk5eTk5OnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNWZWMuaHglM0E2MiUzQSUyMGNoYXJzJTIwMi00NmFpMnp6aThpMjZoYWk1OGk1OWk2MGk2MWk2Mmh6Z2hxaGc6OUNSN2k5UjEwMHE6MjdDUjlpMjduUjE0NlIxNDVSMTQ4UjE0N1IxMDBpMTQ3M2kxNTE4eTk5OnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNWZWMuaHglM0E2NyUzQSUyMGNoYXJzJTIwMi00N2FpMnp6aTlpMjdoYWk2M2k2NGk2NWk2Nmk2N2h6Z2hxaGdoYlIxNzVpMlI5NmkxOFIxNTBpMTlSMTAwaTlSMTU3elI4MmkxM1IxMThpMTJSMTYyaTRSNzlpMTBSMTYwaTE1UjEwOGkxNlIxNjhpMjBSMTE0aTdSMTI4aTE3UjE3MWkxUjE2NWkzUjg4aThSODRpMTFSMTUzaTE0UjE3N2k1UjE1NWk2aGkyMWdoYlIxNDd6aGkxZzoxQ1IzaTF5Mjk6aW9kZXYlNUNnZW9tMiU1Q1ZlY0J1aWxkZXIuaHhxOjBDUjV6eTIyOmlvZGV2Lmdlb20yLlZlY0J1aWxkZXJxOjI1Q1I3aTI1eTE2Om1pcnJvckJ5Tm9ybWFsWFlxOjEwOENSOWkxMDhuUjE4MVIxNDV5MTA6VmVjQnVpbGRlclIxODJSMTgzaTMyMDhpMzI1NHkxMDc6eiUzQSU1Q3Byb2plY3RzJTVDaW9kZXYlNUNnaXRodWIlNUNoYXhlLWdlb20yJTVDc3JjJTVDaW9kZXYlNUNnZW9tMiU1Q1ZlY0J1aWxkZXIuaHglM0ExNjMlM0ElMjBjaGFycyUyMDItNDhhaTJpMXppMjVpMTA4aGFpMTU5aTE2MGkxNjFpMTYyaTE2M2kxNjRoemdocWhnOjI5Q1I3aTI5eTM6dG9ZcToxMTJDUjlpMTEyblIxODFSMTQ1UjE4NFIxODJSMTg2aTM1NTFpMzU2MHkxMDc6eiUzQSU1Q3Byb2plY3RzJTVDaW9kZXYlNUNnaXRodWIlNUNoYXhlLWdlb20yJTVDc3JjJTVDaW9kZXYlNUNnZW9tMiU1Q1ZlY0J1aWxkZXIuaHglM0ExODYlM0ElMjBjaGFycyUyMDItMTFhaTJpMXppMjlpMTEyaGFpMTgyaTE4M2kxODRpMTg1aTE4Nmh6Z2hxaGc6MjJDUjdpMjJSOThxOjEwNUNSOWkxMDVuUjE4MVIxNDVSMTg0UjE4MlI5OGkyNzkzaTI4Mzd5MTA3OnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNWZWNCdWlsZGVyLmh4JTNBMTQ1JTNBJTIwY2hhcnMlMjAyLTQ2YWkyaTF6aTIyaTEwNWhhaTE0MWkxNDJpMTQzaTE0NGkxNDVpMTQ2aHpnaHFoZzoxM0NSN2kxM3k1OmFkZFhZcTo5NkNSOWk5Nm5SMTgxUjE0NVIxODRSMTgyUjE4OWkxNjc0aTE3MDl5MTA2OnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNWZWNCdWlsZGVyLmh4JTNBOTElM0ElMjBjaGFycyUyMDItMzdhaTJpMXppMTNpOTZoYWk4N2k4OGk4OWk5MGk5MWk5Mmh6Z2hxaGc6MTdDUjdpMTd5MTA6bXVsdGlwbHlYWXE6MTAwQ1I5aTEwMG5SMTgxUjE0NVIxODRSMTgyUjE5MWkyMTcyaTIyMDd5MTA3OnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNWZWNCdWlsZGVyLmh4JTNBMTE1JTNBJTIwY2hhcnMlMjAyLTM3YWkyaTF6aTE3aTEwMGhhaTExMWkxMTJpMTEzaTExNGkxMTVpMTE2aHpnaHFoZzoxMUNSN2kxMVI5NnE6OTRDUjlpOTRuUjE4MVIxNDVSMTg0UjE4MlI5NmkxNDMwaTE0NzB5MTA2OnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNWZWNCdWlsZGVyLmh4JTNBNzklM0ElMjBjaGFycyUyMDItNDJhaTJpMXppMTFpOTRoYWk3NWk3Nmk3N2k3OGk3OWk4MGh6Z2hxaGc6N0NSN2k3eTU6c2V0WFlxOjkwQ1I5aTkwblIxODFSMTQ1UjE4NFIxODJSMTk0aTk3NGk5ODB5MTA1OnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNWZWNCdWlsZGVyLmh4JTNBNTQlM0ElMjBjaGFycyUyMDItOGFpMmkxemk3aTkwaGFpNTBpNTFpNTJpNTNpNTRpNTVpNTZoemdocWhnOjFDUjdpMVIxNTdxOjg0Q1I5aTg0blIxODFSMTQ1UjE4NFIxODJSMTU3aTI2MGkyODd5MTA2OnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNWZWNCdWlsZGVyLmh4JTNBMTUlM0ElMjBjaGFycyUyMDItMjlhaTJpMXppMWk4NGhhaTExaTEyaTEzaTE0aTE1aHpnaHFoZzoxNkNSN2kxNnk4Om11bHRpcGx5cTo5OUNSOWk5OW5SMTgxUjE0NVIxODRSMTgyUjE5N2kyMDM5aTIwNzh5MTA3OnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNWZWNCdWlsZGVyLmh4JTNBMTA5JTNBJTIwY2hhcnMlMjAyLTQxYWkyaTF6aTE2aTk5aGFpMTA1aTEwNmkxMDdpMTA4aTEwOWkxMTBoemdocWhnOjMwQ1I3aTMweTg6dG9MZW5ndGhxOjExM0NSOWkxMTNuUjE4MVIxNDVSMTg0UjE4MlIxOTlpMzYxM2kzNjQ0eTEwNzp6JTNBJTVDcHJvamVjdHMlNUNpb2RldiU1Q2dpdGh1YiU1Q2hheGUtZ2VvbTIlNUNzcmMlNUNpb2RldiU1Q2dlb20yJTVDVmVjQnVpbGRlci5oeCUzQTE5MSUzQSUyMGNoYXJzJTIwMi0zM2FpMmkxemkzMGkxMTNoYWkxODdpMTg4aTE4OWkxOTBpMTkxaHpnaHFoZzoyQ1I3aTJ5Nzpmcm9tVmVjcTo4NUNSOWk4NW5SMTgxUjE0NVIxODRSMTgyUjIwMWkzNThpMzg5eTEwNjp6JTNBJTVDcHJvamVjdHMlNUNpb2RldiU1Q2dpdGh1YiU1Q2hheGUtZ2VvbTIlNUNzcmMlNUNpb2RldiU1Q2dlb20yJTVDVmVjQnVpbGRlci5oeCUzQTIwJTNBJTIwY2hhcnMlMjAyLTMzYWkyaTF6aTJpODVoYWkxNmkxN2kxOGkxOWkyMGh6Z2hxaGc6NUNSN2k1eTQ6c2V0WHE6ODhDUjlpODhuUjE4MVIxNDVSMTg0UjE4MlIyMDNpNzk0aTgwMHkxMDU6eiUzQSU1Q3Byb2plY3RzJTVDaW9kZXYlNUNnaXRodWIlNUNoYXhlLWdlb20yJTVDc3JjJTVDaW9kZXYlNUNnZW9tMiU1Q1ZlY0J1aWxkZXIuaHglM0E0MiUzQSUyMGNoYXJzJTIwMi04YWkyaTF6aTVpODhoYWkzNWkzNmkzN2kzOGkzOWk0MGk0MWk0Mmk0M2h6Z2hxaGc6MTJDUjdpMTJSMTI0cTo5NUNSOWk5NW5SMTgxUjE0NVIxODRSMTgyUjEyNGkxNTQ2aTE1ODV5MTA2OnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNWZWNCdWlsZGVyLmh4JTNBODUlM0ElMjBjaGFycyUyMDItNDFhaTJpMXppMTJpOTVoYWk4MWk4Mmk4M2k4NGk4NWk4Nmh6Z2hxaGc6MTlDUjdpMTl5ODpkaXZpZGVYWXE6MTAyQ1I5aTEwMm5SMTgxUjE0NVIxODRSMTgyUjIwNmkyNDE3aTI0NTJ5MTA3OnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNWZWNCdWlsZGVyLmh4JTNBMTI3JTNBJTIwY2hhcnMlMjAyLTM3YWkyaTF6aTE5aTEwMmhhaTEyM2kxMjRpMTI1aTEyNmkxMjdpMTI4aHpnaHFoZzoyN0NSN2kyN3kxNDp0b1ZlY1NwZWNpZmllZHE6MTEwQ1I5aTExMG5SMTgxUjE0NVIxODRSMTgyUjIwOGkzNDA2aTM0MTZ5MTA3OnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNWZWNCdWlsZGVyLmh4JTNBMTc0JTNBJTIwY2hhcnMlMjAyLTEyYWkyaTF6aTI3aTExMGhhaTE3MGkxNzFpMTcyaTE3M2kxNzRpMTc1aTE3Nmh6Z2hxaGc6MTBDUjdpMTBSMTA2cTo5M0NSOWk5M25SMTgxUjE0NVIxODRSMTgyUjEwNmkxMzA4aTEzNDB5MTA2OnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNWZWNCdWlsZGVyLmh4JTNBNzMlM0ElMjBjaGFycyUyMDItMzRhaTJpMXppMTBpOTNoYWk2OWk3MGk3MWk3Mmk3M2k3NGh6Z2hxaGc6MjRDUjdpMjRSODZxOjEwN0NSOWkxMDduUjE4MVIxNDVSMTg0UjE4MlI4NmkzMDU4aTMxMDh5MTA3OnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNWZWNCdWlsZGVyLmh4JTNBMTU3JTNBJTIwY2hhcnMlMjAyLTUyYWkyaTF6aTI0aTEwN2hhaTE1M2kxNTRpMTU1aTE1NmkxNTdpMTU4aHpnaHFoZzoyNkNSN2kyNnk1OnRvVmVjcToxMDlDUjlpMTA5blIxODFSMTQ1UjE4NFIxODJSMjEyaTMzMThpMzM0MHkxMDc6eiUzQSU1Q3Byb2plY3RzJTVDaW9kZXYlNUNnaXRodWIlNUNoYXhlLWdlb20yJTVDc3JjJTVDaW9kZXYlNUNnZW9tMiU1Q1ZlY0J1aWxkZXIuaHglM0ExNjklM0ElMjBjaGFycyUyMDItMjRhaTJpMXppMjZpMTA5aGFpMTY1aTE2NmkxNjdpMTY4aTE2OWh6Z2hxaGc6MjhDUjdpMjh5Mzp0b1hxOjExMUNSOWkxMTFuUjE4MVIxNDVSMTg0UjE4MlIyMTRpMzQ5NGkzNTAzeTEwNzp6JTNBJTVDcHJvamVjdHMlNUNpb2RldiU1Q2dpdGh1YiU1Q2hheGUtZ2VvbTIlNUNzcmMlNUNpb2RldiU1Q2dlb20yJTVDVmVjQnVpbGRlci5oeCUzQTE4MSUzQSUyMGNoYXJzJTIwMi0xMWFpMmkxemkyOGkxMTFoYWkxNzdpMTc4aTE3OWkxODBpMTgxaHpnaHFoZzoxNENSN2kxNHk4OnN1YnRyYWN0cTo5N0NSOWk5N25SMTgxUjE0NVIxODRSMTgyUjIxNmkxNzkwaTE4Mjl5MTA2OnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNWZWNCdWlsZGVyLmh4JTNBOTclM0ElMjBjaGFycyUyMDItNDFhaTJpMXppMTRpOTdoYWk5M2k5NGk5NWk5Nmk5N2k5OGh6Z2hxaGc6NkNSN2k2eTQ6c2V0WXE6ODlDUjlpODluUjE4MVIxNDVSMTg0UjE4MlIyMThpODc5aTg4NXkxMDU6eiUzQSU1Q3Byb2plY3RzJTVDaW9kZXYlNUNnaXRodWIlNUNoYXhlLWdlb20yJTVDc3JjJTVDaW9kZXYlNUNnZW9tMiU1Q1ZlY0J1aWxkZXIuaHglM0E0OCUzQSUyMGNoYXJzJTIwMi04YWkyaTF6aTZpODloYWk0NGk0NWk0Nmk0N2k0OGk0OWh6Z2hxaGc6MENSN3p5NjpjcmVhdGVxOjgzQ1I5aTgzblIxODFSMTQ1UjE4NFIxODJSMjIwaTE0OGkxNzF5MTA2OnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNWZWNCdWlsZGVyLmh4JTNBMTAlM0ElMjBjaGFycyUyMDItMjVhaTJpMXp6aTgzaGFpLTF6aTFpMmkzaTRpNWk2aTdpOGk5aTEwaHpnaHFoZzoyM0NSN2kyM3kxMDptaXJyb3JCeVhZcToxMDZDUjlpMTA2blIxODFSMTQ1UjE4NFIxODJSMjIyaTI5MzFpMjk3MXkxMDc6eiUzQSU1Q3Byb2plY3RzJTVDaW9kZXYlNUNnaXRodWIlNUNoYXhlLWdlb20yJTVDc3JjJTVDaW9kZXYlNUNnZW9tMiU1Q1ZlY0J1aWxkZXIuaHglM0ExNTElM0ElMjBjaGFycyUyMDItNDJhaTJpMXppMjNpMTA2aGFpMTQ3aTE0OGkxNDlpMTUwaTE1MWkxNTJoemdocWhnOjE1Q1I3aTE1eTEwOnN1YnRyYWN0WFlxOjk4Q1I5aTk4blIxODFSMTQ1UjE4NFIxODJSMjI0aTE5MjNpMTk1OHkxMDc6eiUzQSU1Q3Byb2plY3RzJTVDaW9kZXYlNUNnaXRodWIlNUNoYXhlLWdlb20yJTVDc3JjJTVDaW9kZXYlNUNnZW9tMiU1Q1ZlY0J1aWxkZXIuaHglM0ExMDMlM0ElMjBjaGFycyUyMDItMzdhaTJpMXppMTVpOThoYWk5OWkxMDBpMTAxaTEwMmkxMDNpMTA0aHpnaHFoZzo0Q1I3aTRSMTUzcTo4N0NSOWk4N25SMTgxUjE0NVIxODRSMTgyUjE1M2k2NDdpNjUzeTEwNTp6JTNBJTVDcHJvamVjdHMlNUNpb2RldiU1Q2dpdGh1YiU1Q2hheGUtZ2VvbTIlNUNzcmMlNUNpb2RldiU1Q2dlb20yJTVDVmVjQnVpbGRlci5oeCUzQTMzJTNBJTIwY2hhcnMlMjAyLThhaTJpMXppNGk4N2hhaTI4aTI5aTMwaTMxaTMyaTMzaTM0aHpnaHFoZzozMUNSN2kzMXkxMTp0b01hZ25pdHVkZXE6MTE0Q1I5aTExNG5SMTgxUjE0NVIxODRSMTgyUjIyN2kzNzAwaTM3MzR5MTA3OnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNWZWNCdWlsZGVyLmh4JTNBMTk2JTNBJTIwY2hhcnMlMjAyLTM2YWkyaTF6aTMxaTExNGhhaTE5MmkxOTNpMTk0aTE5NWkxOTZoemdocWhnOjNDUjdpM1IxNzFxOjg2Q1I5aTg2blIxODFSMTQ1UjE4NFIxODJSMTcxaTQ4NWk1MDZ5MTA2OnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNWZWNCdWlsZGVyLmh4JTNBMjUlM0ElMjBjaGFycyUyMDItMjNhaTJpMXppM2k4NmhhaTIxaTIyaTIzaTI0aTI1aTI2aTI3aHpnaHFoZzoyMENSN2kyMFIxMjBxOjEwM0NSOWkxMDNuUjE4MVIxNDVSMTg0UjE4MlIxMjBpMjUzOWkyNTgweTEwNzp6JTNBJTVDcHJvamVjdHMlNUNpb2RldiU1Q2dpdGh1YiU1Q2hheGUtZ2VvbTIlNUNzcmMlNUNpb2RldiU1Q2dlb20yJTVDVmVjQnVpbGRlci5oeCUzQTEzMyUzQSUyMGNoYXJzJTIwMi00M2FpMmkxemkyMGkxMDNoYWkxMjlpMTMwaTEzMWkxMzJpMTMzaTEzNGh6Z2hxaGc6MThDUjdpMTh5NjpkaXZpZGVxOjEwMUNSOWkxMDFuUjE4MVIxNDVSMTg0UjE4MlIyMzFpMjI4NmkyMzI1eTEwNzp6JTNBJTVDcHJvamVjdHMlNUNpb2RldiU1Q2dpdGh1YiU1Q2hheGUtZ2VvbTIlNUNzcmMlNUNpb2RldiU1Q2dlb20yJTVDVmVjQnVpbGRlci5oeCUzQTEyMSUzQSUyMGNoYXJzJTIwMi00MWFpMmkxemkxOGkxMDFoYWkxMTdpMTE4aTExOWkxMjBpMTIxaTEyMmh6Z2hxaGc6MjFDUjdpMjFSOTJxOjEwNENSOWkxMDRuUjE4MVIxNDVSMTg0UjE4MlI5MmkyNjY4aTI3MTJ5MTA3OnolM0ElNUNwcm9qZWN0cyU1Q2lvZGV2JTVDZ2l0aHViJTVDaGF4ZS1nZW9tMiU1Q3NyYyU1Q2lvZGV2JTVDZ2VvbTIlNUNWZWNCdWlsZGVyLmh4JTNBMTM5JTNBJTIwY2hhcnMlMjAyLTQ2YWkyaTF6aTIxaTEwNGhhaTEzNWkxMzZpMTM3aTEzOGkxMzlpMTQwaHpnaHFoZzozMkNSN2kzMlIxNTBxOjExNUNSOWkxMTVuUjE4MVIxNDVSMTg0UjE4MlIxNTBpMzc4OGkzODIyeTEwNzp6JTNBJTVDcHJvamVjdHMlNUNpb2RldiU1Q2dpdGh1YiU1Q2hheGUtZ2VvbTIlNUNzcmMlNUNpb2RldiU1Q2dlb20yJTVDVmVjQnVpbGRlci5oeCUzQTIwMSUzQSUyMGNoYXJzJTIwMi0zNmFpMmkxemkzMmkxMTVoYWkxOTdpMTk4aTE5OWkyMDBpMjAxaHpnaHFoZzo4Q1I3aTh5ODpzZXRQb2xhcnE6OTFDUjlpOTFuUjE4MVIxNDVSMTg0UjE4MlIyMzVpMTA5NWkxMTMyeTEwNjp6JTNBJTVDcHJvamVjdHMlNUNpb2RldiU1Q2dpdGh1YiU1Q2hheGUtZ2VvbTIlNUNzcmMlNUNpb2RldiU1Q2dlb20yJTVDVmVjQnVpbGRlci5oeCUzQTYxJTNBJTIwY2hhcnMlMjAyLTM5YWkyaTF6aThpOTFoYWk1N2k1OGk1OWk2MGk2MWk2Mmh6Z2hxaGc6OUNSN2k5UjEyMnE6OTJDUjlpOTJuUjE4MVIxNDVSMTg0UjE4MlIxMjJpMTIwNGkxMjM2eTEwNjp6JTNBJTVDcHJvamVjdHMlNUNpb2RldiU1Q2dpdGh1YiU1Q2hheGUtZ2VvbTIlNUNzcmMlNUNpb2RldiU1Q2dlb20yJTVDVmVjQnVpbGRlci5oeCUzQTY3JTNBJTIwY2hhcnMlMjAyLTM0YWkyaTF6aTlpOTJoYWk2M2k2NGk2NWk2Nmk2N2k2OGh6Z2hxaGdoYlIyMzVpOFI5NmkxMVIxMjBpMjBSMjAzaTVSMTA2aTEwUjg2aTI0UjE1MGkzMlIxODNpMjVSMTk5aTMwUjIzMWkxOFIyMDZpMTlSMTk0aTdSMjAxaTJSMTcxaTNSMTUzaTRSOTJpMjFSMTg5aTEzUjIwOGkyN1IxODZpMjlSMjI0aTE1UjIxNmkxNFIyMjJpMjNSMjI3aTMxUjIyMHpSMTkxaTE3UjIxNGkyOFIxNTdpMVIyMThpNlIxMjJpOVIxMjRpMTJSMTk3aTE2UjIxMmkyNlI5OGkyMmhpMzNnaGJSMTgyemhpMWdoYlIxODFpMVIxNDZ6aGkyZ2hiUjE0NWkyUjJ6UjYwaTFoaTNxOjM3YWkyenppMTlpMzdoOjY4YXppMXppM2k2OGg6OTBhaTJpMXppN2k5MGg6MjlhaTJ6emkxMWkyOWg6NDhhaTFpM3ppOWk0OGg6NjJhaTFpM3ppMjNpNjJoOjU3YWkxaTN6aTE4aTU3aDo1OWFpMWkzemkyMGk1OWg6OTNhaTJpMXppMTBpOTNoOjIyYWkyenppNGkyMmg6MTNhaTFpMXppNGkxM2g6MzhhaTJ6emkyMGkzOGg6NzhhemkxemkxMGk3OGg6ODBhemkxemkxMWk4MGg6MTdhaTFpMnppMmkxN2g6NDlhaTFpM3ppMTBpNDloOjkyYWkyaTF6aTlpOTJoOjdhaTF6emkxaTdoOjFhenp6aTFpMWg6NTJhaTFpM3ppMTNpNTJoOjk1YWkyaTF6aTEyaTk1aDoxMDdhaTJpMXppMjRpMTA3aDozMGFpMnp6aTEyaTMwaDo1MWFpMWkzemkxMmk1MWg6NzZhemkxemk4aTc2aDozNGFpMnp6aTE2aTM0aDozOWFpMWkzenppMzloOjEyYWkxaTF6aTNpMTJoOjE5YWkyenppMWkxOWg6MjdhaTJ6emk5aTI3aDo4OGFpMmkxemk1aTg4aDoxMDFhaTJpMXppMThpMTAxaDoxMGFpMWkxemkxaTEwaDoyNGFpMnp6aTZpMjRoOjQyYWkxaTN6aTNpNDJoOjY3YXppMXppMmk2N2g6MTA2YWkyaTF6aTIzaTEwNmg6NTNhaTFpM3ppMTRpNTNoOjEwOWFpMmkxemkyNmkxMDloOjg0YWkyaTF6aTFpODRoOjIzYWkyenppNWkyM2g6NzVhemkxemk4aTc1aDoxMTFhaTJpMXppMjhpMTExaDoxNWFpMWkyenppMTVoOjM1YWkyenppMTdpMzVoOjU0YWkxaTN6aTE1aTU0aDo5NGFpMmkxemkxMWk5NGg6MTE1YWkyaTF6aTMyaTExNWg6OTdhaTJpMXppMTRpOTdoOjUwYWkxaTN6aTExaTUwaDo4M2FpMmkxenppODNoOjEwM2FpMmkxemkyMGkxMDNoOjExM2FpMmkxemkzMGkxMTNoOjMyYWkyenppMTRpMzJoOjc0YXppMXppN2k3NGg6OWFpMWkxenppOWg6ODZhaTJpMXppM2k4Nmg6MjVhaTJ6emk3aTI1aDo1OGFpMWkzemkxOWk1OGg6MTEyYWkyaTF6aTI5aTExMmg6NDVhaTFpM3ppNmk0NWg6NzBhemkxemk0aTcwaDo0NmFpMWkzemk3aTQ2aDo1NmFpMWkzemkxN2k1Nmg6NDBhaTFpM3ppMWk0MGg6MTAwYWkyaTF6aTE3aTEwMGg6NjVhemkxemkxaTY1aDoxMDJhaTJpMXppMTlpMTAyaDoxMDRhaTJpMXppMjFpMTA0aDoxMWFpMWkxemkyaTExaDozNmFpMnp6aTE4aTM2aDo2MGFpMWkzemkyMWk2MGg6ODFhaTFpNHp6aTgxaDo4OWFpMmkxemk2aTg5aDo3N2F6aTF6aTlpNzdoOjgyYWkxaTR6aTFpODJoOjE2YWkxaTJ6aTFpMTZoOjExMGFpMmkxemkyN2kxMTBoOjExNGFpMmkxemkzMWkxMTRoOjQ3YWkxaTN6aThpNDdoOjY5YXppMXppNGk2OWg6ODVhaTJpMXppMmk4NWg6MmF6enppMmkyaDo1YXp6emk1aTVoOjc5YXppMXppMTBpNzloOjg3YWkyaTF6aTRpODdoOjk4YWkyaTF6aTE1aTk4aDoyNmFpMnp6aThpMjZoOjI4YWkyenppMTBpMjhoOjE0YWkxaTF6aTVpMTRoOjkxYWkyaTF6aThpOTFoOjk2YWkyaTF6aTEzaTk2aDo2YWkxenp6aTZoOjMzYWkyenppMTVpMzNoOjU1YWkxaTN6aTE2aTU1aDowYXp6enp6aDo0YXp6emk0aTRoOjMxYWkyenppMTNpMzFoOjY0YXppMXp6aTY0aDo2NmF6aTF6aTJpNjZoOjczYXppMXppNmk3M2g6M2F6enppM2kzaDoyMGFpMnp6aTJpMjBoOjYxYWkxaTN6aTIyaTYxaDo0NGFpMWkzemk1aTQ0aDo0MWFpMWkzemkyaTQxaDo0M2FpMWkzemk0aTQzaDo5OWFpMmkxemkxNmk5OWg6MTA1YWkyaTF6aTIyaTEwNWg6MThhaTJ6enppMThoOjIxYWkyenppM2kyMWg6OGFpMXp6aTJpOGg6NjNhaTFpM3ppMjRpNjNoOjcyYXppMXppNmk3Mmg6MTA4YWkyaTF6aTI1aTEwOGg6NzFhemkxemk1aTcxaGhxOjBhemkxemkyemg6NGF6aTF6aTEwaTRoOjNhemkxemk4aTNoOjFhemkxemk0aTFoOjJhemkxemk2aTJoaHFocWhn"}];
var __map_reserved = {};
var ArrayBuffer = $global.ArrayBuffer || js_html_compat_ArrayBuffer;
if(ArrayBuffer.prototype.slice == null) {
	ArrayBuffer.prototype.slice = js_html_compat_ArrayBuffer.sliceImpl;
}
var Uint8Array = $global.Uint8Array || js_html_compat_Uint8Array._new;
haxe_Serializer.BASE64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:";
haxe_Unserializer.DEFAULT_RESOLVER = new haxe__$Unserializer_DefaultResolver();
haxe_Unserializer.BASE64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:";
haxe_crypto_Base64.CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
haxe_crypto_Base64.BYTES = haxe_io_Bytes.ofString(haxe_crypto_Base64.CHARS);
haxe_ds_ObjectMap.count = 0;
iodev_geom2_VecBuilderTest.__meta__ = { fields : { testCreate : { Test : null}, testFromXY : { Test : null}, testFromVec : { Test : null}, testFromPolar : { Test : null}, testConstructorDefaults : { Test : null}, testConstructorParams : { Test : null}, testSetX : { Test : null}, testSetY : { Test : null}, testSetXY : { Test : null}, testSetPolar : { Test : null}, testNegate : { Test : null}, testSwapXY : { Test : null}, testNormalize : { Test : null}, testAdd : { Test : null}, testAddXY : { Test : null}, testSubtract : { Test : null}, testSubtractXY : { Test : null}, testMultiply : { Test : null}, testMultiplyXY : { Test : null}, testDivide : { Test : null}, testDivideXY : { Test : null}, testRotate : { Test : null}, testRotateQuart : { Test : null}, testMirrorBy : { Test : null}, testMirrorByXY : { Test : null}, testMirrorByNormal : { Test : null}, testMirrorByNormalXY : { Test : null}, testToVec : { Test : null}, testToVecSpecified : { Test : null}, testToX : { Test : null}, testToY : { Test : null}, testToLength : { Test : null}, testToMagnitude : { Test : null}, testToRadians : { Test : null}}};
iodev_geom2_VecTest.__meta__ = { fields : { testFromXY : { Test : null}, testFromPolar : { Test : null}, testFromAdd : { Test : null}, testFromSub : { Test : null}, testFromMul : { Test : null}, testFromDiv : { Test : null}, testNormalBisectorFrom : { Test : null}, testEquals : { Test : null}, testDotProd : { Test : null}, testSkewProd : { Test : null}, testLengthBentween : { Test : null}, testMagnitudeBetween : { Test : null}, testRadiansBetween : { Test : null}, testRadiansBetweenNormals : { Test : null}, testRadiansBetweenNormals_notnormal : { Test : null}, testConstructorDefaults : { Test : null}, testConstructorParams : { Test : null}, testFieldsAssign : { Test : null}, testFieldsModifying : { Test : null}, testClone : { Test : null}, testLength : { Test : null}, testMagnitude : { Test : null}, testNormalize : { Test : null}, testToRadians : { Test : null}, testToString : { Test : null}}};
iodev_geom2_intersec_LineIntersecTest.__meta__ = { fields : { testLineLine_cross : { Test : null}, testLineLine_touch : { Test : null}, testLineLine_projectIn : { Test : null}, testLineLine_projectOut : { Test : null}, testLineLine_castIn : { Test : null}, testLineLine_castOut : { Test : null}, testLineLine_castAway : { Test : null}, testLineLine_parallel : { Test : null}, testLineLineTo_cross : { Test : null}, testLineLineTo_touch : { Test : null}, testLineLineTo_projectIn : { Test : null}, testLineLineTo_projectOut : { Test : null}, testLineLineTo_castIn : { Test : null}, testLineLineTo_castOut : { Test : null}, testLineLineTo_castAway : { Test : null}, testLineLineTo_parallel : { Test : null}, testLineRay_cross : { Test : null}, testLineRay_touch : { Test : null}, testLineRay_projectIn_ba : { Test : null}, testLineRay_projectOut_ba : { Test : null}, testLineRay_castIn : { Test : null}, testLineRay_castOut_ba : { Test : null}, testLineRay_castAway : { Test : null}, testLineRay_parallel_lite : { Test : null}, testLineRayTo_cross : { Test : null}, testLineRayTo_touch : { Test : null}, testLineRayTo_projectIn_ba : { Test : null}, testLineRayTo_projectOut_ba : { Test : null}, testLineRayTo_castIn : { Test : null}, testLineRayTo_castOut_ba : { Test : null}, testLineRayTo_castAway : { Test : null}, testLineRayTo_parallel_lite : { Test : null}, testLineSegm_cross : { Test : null}, testLineSegm_touch : { Test : null}, testLineSegm_projectIn_ba : { Test : null}, testLineSegm_projectOut_ba : { Test : null}, testLineSegm_castIn : { Test : null}, testLineSegm_castOut_ba : { Test : null}, testLineSegm_castAway : { Test : null}, testLineSegm_parallel : { Test : null}, testLineSegmTo_cross : { Test : null}, testLineSegmTo_touch : { Test : null}, testLineSegmTo_projectIn_ba : { Test : null}, testLineSegmTo_projectOut_ba : { Test : null}, testLineSegmTo_castIn : { Test : null}, testLineSegmTo_castOut_ba : { Test : null}, testLineSegmTo_castAway : { Test : null}, testLineSegmTo_parallel : { Test : null}, testRayRay_cross : { Test : null}, testRayRay_touch : { Test : null}, testRayRay_projectIn : { Test : null}, testRayRay_projectOut : { Test : null}, testRayRay_castIn : { Test : null}, testRayRay_castOut : { Test : null}, testRayRay_castAway : { Test : null}, testRayRay_parallel_lite : { Test : null}, testRayRayTo_cross : { Test : null}, testRayRayTo_touch : { Test : null}, testRayRayTo_projectIn : { Test : null}, testRayRayTo_projectOut : { Test : null}, testRayRayTo_castIn : { Test : null}, testRayRayTo_castOut : { Test : null}, testRayRayTo_castAway : { Test : null}, testRayRayTo_parallel_lite : { Test : null}, testRaySegm_cross : { Test : null}, testRaySegm_touch : { Test : null}, testRaySegm_projectIn : { Test : null}, testRaySegm_projectOut : { Test : null}, testRaySegm_castIn : { Test : null}, testRaySegm_castOut : { Test : null}, testRaySegm_castAway : { Test : null}, testRaySegm_parallel : { Test : null}, testRaySegmTo_cross : { Test : null}, testRaySegmTo_touch : { Test : null}, testRaySegmTo_projectIn : { Test : null}, testRaySegmTo_projectOut : { Test : null}, testRaySegmTo_castIn : { Test : null}, testRaySegmTo_castOut : { Test : null}, testRaySegmTo_castAway : { Test : null}, testRaySegmTo_parallel : { Test : null}, testSegmSegm_cross : { Test : null}, testSegmSegm_touch : { Test : null}, testSegmSegm_projectIn : { Test : null}, testSegmSegm_projectOut : { Test : null}, testSegmSegm_castIn : { Test : null}, testSegmSegm_castOut : { Test : null}, testSegmSegm_castAway : { Test : null}, testSegmSegm_parallel : { Test : null}, testSegmSegmTo_cross : { Test : null}, testSegmSegmTo_touch : { Test : null}, testSegmSegmTo_projectIn : { Test : null}, testSegmSegmTo_projectOut : { Test : null}, testSegmSegmTo_castIn : { Test : null}, testSegmSegmTo_castOut : { Test : null}, testSegmSegmTo_castAway : { Test : null}, testSegmSegmTo_parallel : { Test : null}}};
iodev_geom2_macros_CircleIntersecMacrosTest.__meta__ = { fields : { testCircleLine_crossFull : { Test : null}, testCircleLine_crossIn : { Test : null}, testCircleLine_crossOut : { Test : null}, testCircleLine_inside : { Test : null}, testCircleLine_touch : { Test : null}, testCircleLine_tangentIn : { Test : null}, testCircleLine_tangentOut : { Test : null}, testCircleLine_projectIn : { Test : null}, testCircleLine_projectOut : { Test : null}, testCircleLine_none : { Test : null}, testCircleRay_crossFull : { Test : null}, testCircleRay_crossIn : { Test : null}, testCircleRay_crossOut : { Test : null}, testCircleRay_inside : { Test : null}, testCircleRay_touch : { Test : null}, testCircleRay_tangentIn : { Test : null}, testCircleRay_tangentOut : { Test : null}, testCircleRay_projectIn : { Test : null}, testCircleRay_projectOut : { Test : null}, testCircleRay_none : { Test : null}, testCircleSegm_crossFull : { Test : null}, testCircleSegm_crossIn : { Test : null}, testCircleSegm_crossOut : { Test : null}, testCircleSegm_inside : { Test : null}, testCircleSegm_touch : { Test : null}, testCircleSegm_tangentIn : { Test : null}, testCircleSegm_tangentOut : { Test : null}, testCircleSegm_projectIn : { Test : null}, testCircleSegm_projectOut : { Test : null}, testCircleSegm_none : { Test : null}}};
iodev_geom2_macros_LineIntersecMacrosTest.__meta__ = { fields : { testLineLine_cross : { Test : null}, testLineLine_touch : { Test : null}, testLineLine_projectIn : { Test : null}, testLineLine_projectOut : { Test : null}, testLineLine_castIn : { Test : null}, testLineLine_castOut : { Test : null}, testLineLine_castAway : { Test : null}, testLineLine_parallel : { Test : null}, testLineRay_cross : { Test : null}, testLineRay_touch : { Test : null}, testLineRay_projectIn_ba : { Test : null}, testLineRay_projectOut_ba : { Test : null}, testLineRay_castIn : { Test : null}, testLineRay_castOut_ba : { Test : null}, testLineRay_castAway : { Test : null}, testLineRay_parallel_lite : { Test : null}, testLineSegm_cross : { Test : null}, testLineSegm_touch : { Test : null}, testLineSegm_projectIn_ba : { Test : null}, testLineSegm_projectOut_ba : { Test : null}, testLineSegm_castIn : { Test : null}, testLineSegm_castOut_ba : { Test : null}, testLineSegm_castAway : { Test : null}, testLineSegm_parallel : { Test : null}, testRayRay_cross : { Test : null}, testRayRay_touch : { Test : null}, testRayRay_projectIn : { Test : null}, testRayRay_projectOut : { Test : null}, testRayRay_castIn : { Test : null}, testRayRay_castOut : { Test : null}, testRayRay_castAway : { Test : null}, testRayRay_parallel_lite : { Test : null}, testRaySegm_cross : { Test : null}, testRaySegm_touch : { Test : null}, testRaySegm_projectIn : { Test : null}, testRaySegm_projectOut : { Test : null}, testRaySegm_castIn : { Test : null}, testRaySegm_castOut : { Test : null}, testRaySegm_castAway : { Test : null}, testRaySegm_parallel : { Test : null}, testSegmSegm_cross : { Test : null}, testSegmSegm_touch : { Test : null}, testSegmSegm_projectIn : { Test : null}, testSegmSegm_projectOut : { Test : null}, testSegmSegm_castIn : { Test : null}, testSegmSegm_castOut : { Test : null}, testSegmSegm_castAway : { Test : null}, testSegmSegm_parallel : { Test : null}}};
iodev_geom2_macros_VecMacrosTest.__meta__ = { fields : { testArrayFromTwoOrLess_two : { Test : null}, testArrayFromTwoOrLess_one : { Test : null}, testArrayFromTwoOrLess_zero : { Test : null}, testEquals : { Test : null}, testNegate : { Test : null}, testSwapXY : { Test : null}, testSwapVecs : { Test : null}, testAdd : { Test : null}, testSub : { Test : null}, testMul : { Test : null}, testDiv : { Test : null}, testMagnitude : { Test : null}, testMagnitudeBetween : { Test : null}, testNormalize : { Test : null}, testLength : { Test : null}, testLengthBetween : { Test : null}, testDotProd : { Test : null}, testSkewProd : { Test : null}, testPolar : { Test : null}, testRadiansOf : { Test : null}, testRadiansBetween : { Test : null}, testRadiansBetweenNormals : { Test : null}, testRadiansBetweenNormals_unnormalized : { Test : null}, testNormalBisector : { Test : null}, testRotate : { Test : null}, testRotateQuart : { Test : null}, testMirrorBy : { Test : null}, testMirrorByNormal : { Test : null}}};
iodev_geom2_macros_VecMacrosTest_$argTest.__meta__ = { fields : { testEquals_immutation : { Test : null}, testNegate_immutation : { Test : null}, testAdd_asOutput : { Test : null}, testSwapXY_immutation : { Test : null}, testSwapXY_asOutput : { Test : null}, testAdd_immutation : { Test : null}, testAdd_asOutput_a : { Test : null}, testAdd_asOutput_b : { Test : null}, testSub_immutation : { Test : null}, testSub_asOutput_a : { Test : null}, testSub_asOutput_b : { Test : null}, testMul_immutation : { Test : null}, testMul_asOutput_a : { Test : null}, testMul_asOutput_b : { Test : null}, testDiv_immutation : { Test : null}, testDiv_asOutput_a : { Test : null}, testDiv_asOutput_b : { Test : null}, testNormalBisector_immutation : { Test : null}, testNormalBisector_asOutput_a : { Test : null}, testNormalBisector_asOutput_b : { Test : null}, testRotate_immutation : { Test : null}, testRotate_asOutput : { Test : null}, testRotateQuart_immutation : { Test : null}, testRotateQuart_asOutput : { Test : null}, testMirrorBy_immutation : { Test : null}, testMirrorBy_asOutput_a : { Test : null}, testMirrorBy_asOutput_b : { Test : null}, testMirrorByNormal_immutation : { Test : null}, testMirrorByNormal_asOutput_a : { Test : null}, testMirrorByNormal_asOutput_b : { Test : null}}};
js_Boot.__toStr = ({ }).toString;
js_html_compat_Uint8Array.BYTES_PER_ELEMENT = 1;
massive_munit_Assert.assertionCount = 0;
massive_munit_TestClassHelper.META_TAG_BEFORE_CLASS = "BeforeClass";
massive_munit_TestClassHelper.META_TAG_AFTER_CLASS = "AfterClass";
massive_munit_TestClassHelper.META_TAG_BEFORE = "Before";
massive_munit_TestClassHelper.META_TAG_AFTER = "After";
massive_munit_TestClassHelper.META_TAG_TEST = "Test";
massive_munit_TestClassHelper.META_TAG_ASYNC_TEST = "AsyncTest";
massive_munit_TestClassHelper.META_TAG_IGNORE = "Ignore";
massive_munit_TestClassHelper.META_PARAM_ASYNC_TEST = "Async";
massive_munit_TestClassHelper.META_TAG_TEST_DEBUG = "TestDebug";
massive_munit_TestClassHelper.META_TAGS = ["BeforeClass","AfterClass","Before","After","Test","AsyncTest","TestDebug"];
massive_munit_async_AsyncDelegate.DEFAULT_TIMEOUT = 400;
massive_munit_client_HTTPClient.queue = [];
massive_munit_client_HTTPClient.responsePending = false;
massive_munit_client_JUnitReportClient.DEFAULT_ID = "junit";
massive_munit_client_PrintClientBase.DEFAULT_ID = "simple";
massive_munit_client_PrintClient.DEFAULT_ID = "print";
massive_munit_client_RichPrintClient.DEFAULT_ID = "RichPrintClient";
massive_munit_client_SummaryReportClient.DEFAULT_ID = "summary";
massive_munit_util_Timer.arr = [];
mcover_coverage_CoverageLoggerImpl.__meta__ = { obj : { IgnoreLogging : null}, fields : { logStatement : { IgnoreCover : null}, updateStatementMap : { IgnoreCover : null}, logBranch : { IgnoreCover : null}, updateBranchMap : { IgnoreCover : null}, _ : { IgnoreCover : null}}};
mcover_coverage_MCoverage.__meta__ = { obj : { IgnoreLogging : null, IgnoreCover : null}, statics : { getLogger : { IgnoreLogging : null, IgnoreCover : null}}};
mcover_coverage_MCoverage.RESOURCE_DATA = "MCoverData";
mcover_coverage_client_PrintClient.__meta__ = { obj : { IgnoreLogging : null}};
mcover_coverage_client_TraceClient.__meta__ = { obj : { IgnoreLogging : null}};
mcover_coverage_data_AbstractNode.__meta__ = { obj : { IgnoreLogging : null}, fields : { getResults : { IgnoreLogging : null}, getPercentage : { IgnoreLogging : null}, emptyResult : { IgnoreLogging : null}, hxSerialize : { IgnoreLogging : null}, hxUnserialize : { IgnoreLogging : null}, _ : { IgnoreCover : null}}};
mcover_coverage_data_AbstractBlock.__meta__ = { obj : { IgnoreLogging : null}, fields : { hxSerialize : { IgnoreLogging : null}, hxUnserialize : { IgnoreLogging : null}}};
mcover_coverage_data_AbstractNodeList.__meta__ = { obj : { IgnoreLogging : null}, fields : { getResults : { IgnoreLogging : null}, hxSerialize : { IgnoreLogging : null}, hxUnserialize : { IgnoreLogging : null}}};
mcover_coverage_data_Branch.__meta__ = { obj : { IgnoreLogging : null}, fields : { hxSerialize : { IgnoreLogging : null}, hxUnserialize : { IgnoreLogging : null}}};
mcover_coverage_data_Clazz.__meta__ = { obj : { IgnoreLogging : null}};
mcover_coverage_data_Coverage.__meta__ = { obj : { IgnoreLogging : null}, fields : { getResults : { IgnoreLogging : null}, hxSerialize : { IgnoreLogging : null}, hxUnserialize : { IgnoreLogging : null}}};
mcover_coverage_data_DataUtil.__meta__ = { statics : { sortOnNodeId : { IgnoreLogging : null}, sortOnNodeName : { IgnoreLogging : null}, sortOnBlockName : { IgnoreLogging : null}}, fields : { _ : { IgnoreCover : null}}};
mcover_coverage_data_File.__meta__ = { obj : { IgnoreLogging : null}};
mcover_coverage_data_Method.__meta__ = { obj : { IgnoreLogging : null}, fields : { hxSerialize : { IgnoreLogging : null}, hxUnserialize : { IgnoreLogging : null}}};
mcover_coverage_data_Package.__meta__ = { obj : { IgnoreLogging : null}};
mcover_coverage_data_Statement.__meta__ = { obj : { IgnoreLogging : null}, fields : { hxSerialize : { IgnoreLogging : null}, hxUnserialize : { IgnoreLogging : null}}};
mcover_coverage_munit_client_MCoverPrintClient.__meta__ = { fields : { initializeMCoverLogger : { IgnoreCover : null}}};
mcover_coverage_munit_client_MCoverSummaryReportClient.__meta__ = { fields : { initializeLogger : { IgnoreCover : null}}};
mcover_util_NumberUtil.__meta__ = { obj : { IgnoreCover : null, IgnoreLogging : null}};
mcover_util_Timer.__meta__ = { obj : { IgnoreCover : null, IgnoreLogging : null}, statics : { inlineStamp : { IgnoreCover : null}}, fields : { defaultRun : { IgnoreCover : null}}};
mcover_util_Timer.arr = [];
TestMain.main();
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this, typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
